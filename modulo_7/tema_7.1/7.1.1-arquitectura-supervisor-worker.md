# 7.1.1 Arquitectura Supervisor-Worker

## Objetivo de Aprendizaje

Al finalizar este subtema, ser√°s capaz de dise√±ar e implementar sistemas multi-agente con arquitectura supervisor-worker, donde un agente coordinador delega tareas a agentes especializados.

## Introducci√≥n

La arquitectura **Supervisor-Worker** es el patr√≥n m√°s com√∫n en sistemas multi-agente. Un agente supervisor act√∫a como orquestador, analizando tareas, deleg√°ndolas a workers especializados, y sintetizando los resultados.

### Arquitectura General

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 ARQUITECTURA SUPERVISOR-WORKER                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                  ‚îÇ
‚îÇ                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                         ‚îÇ
‚îÇ                         ‚îÇ  USUARIO    ‚îÇ                         ‚îÇ
‚îÇ                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                         ‚îÇ
‚îÇ                                ‚îÇ                                 ‚îÇ
‚îÇ                                ‚ñº                                 ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îÇ
‚îÇ                    ‚îÇ     SUPERVISOR        ‚îÇ                    ‚îÇ
‚îÇ                    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ                    ‚îÇ
‚îÇ                    ‚îÇ  ‚îÇ ‚Ä¢ Analizar tarea‚îÇ  ‚îÇ                    ‚îÇ
‚îÇ                    ‚îÇ  ‚îÇ ‚Ä¢ Planificar    ‚îÇ  ‚îÇ                    ‚îÇ
‚îÇ                    ‚îÇ  ‚îÇ ‚Ä¢ Delegar       ‚îÇ  ‚îÇ                    ‚îÇ
‚îÇ                    ‚îÇ  ‚îÇ ‚Ä¢ Sintetizar    ‚îÇ  ‚îÇ                    ‚îÇ
‚îÇ                    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ                    ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ
‚îÇ                                ‚îÇ                                 ‚îÇ
‚îÇ              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
‚îÇ              ‚îÇ                 ‚îÇ                 ‚îÇ              ‚îÇ
‚îÇ              ‚ñº                 ‚ñº                 ‚ñº              ‚îÇ
‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ    ‚îÇ   WORKER 1      ‚îÇ ‚îÇ   WORKER 2      ‚îÇ ‚îÇ   WORKER 3      ‚îÇ ‚îÇ
‚îÇ    ‚îÇ  (Investigador) ‚îÇ ‚îÇ  (Analista)     ‚îÇ ‚îÇ  (Escritor)     ‚îÇ ‚îÇ
‚îÇ    ‚îÇ                 ‚îÇ ‚îÇ                 ‚îÇ ‚îÇ                 ‚îÇ ‚îÇ
‚îÇ    ‚îÇ  ‚Ä¢ Buscar info  ‚îÇ ‚îÇ  ‚Ä¢ Procesar     ‚îÇ ‚îÇ  ‚Ä¢ Redactar     ‚îÇ ‚îÇ
‚îÇ    ‚îÇ  ‚Ä¢ Validar      ‚îÇ ‚îÇ  ‚Ä¢ Calcular     ‚îÇ ‚îÇ  ‚Ä¢ Formatear    ‚îÇ ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n del Supervisor

### Clase Base del Supervisor

```python
"""
Implementaci√≥n de un Supervisor para sistemas multi-agente
"""
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Callable
from enum import Enum
import json
from abc import ABC, abstractmethod


class TaskStatus(Enum):
    """Estados de una tarea."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"


@dataclass
class Task:
    """Representa una tarea asignada a un worker."""
    task_id: str
    description: str
    assigned_to: str
    status: TaskStatus = TaskStatus.PENDING
    result: Any = None
    error: Optional[str] = None
    metadata: Dict = field(default_factory=dict)


@dataclass
class WorkerCapability:
    """Describe las capacidades de un worker."""
    name: str
    description: str
    skills: List[str]
    tools: List[str] = field(default_factory=list)


class BaseWorker(ABC):
    """Clase base para workers."""

    def __init__(self, name: str, capabilities: WorkerCapability):
        self.name = name
        self.capabilities = capabilities

    @abstractmethod
    def execute(self, task: Task) -> Any:
        """Ejecuta una tarea asignada."""
        pass

    def can_handle(self, task_description: str) -> bool:
        """Verifica si puede manejar una tarea."""
        # Por defecto, verificar si alguna skill coincide
        task_lower = task_description.lower()
        return any(
            skill.lower() in task_lower
            for skill in self.capabilities.skills
        )


class Supervisor:
    """
    Agente supervisor que coordina m√∫ltiples workers.
    """

    def __init__(
        self,
        api_key: str,
        model: str = "gemini-2.0-flash",
        max_iterations: int = 10
    ):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel(model)
        self.max_iterations = max_iterations

        self.workers: Dict[str, BaseWorker] = {}
        self.task_history: List[Task] = []

    def register_worker(self, worker: BaseWorker):
        """Registra un worker en el sistema."""
        self.workers[worker.name] = worker
        print(f"Worker registrado: {worker.name}")

    def _get_worker_descriptions(self) -> str:
        """Genera descripci√≥n de workers disponibles."""
        descriptions = []
        for name, worker in self.workers.items():
            cap = worker.capabilities
            descriptions.append(
                f"- {name}: {cap.description}\n"
                f"  Skills: {', '.join(cap.skills)}\n"
                f"  Tools: {', '.join(cap.tools) if cap.tools else 'ninguna'}"
            )
        return "\n".join(descriptions)

    def _plan_task(self, user_request: str) -> List[Dict]:
        """
        Planifica la ejecuci√≥n descomponiendo en subtareas.
        """
        worker_info = self._get_worker_descriptions()

        prompt = f"""Eres un supervisor que coordina un equipo de agentes especializados.

SOLICITUD DEL USUARIO:
{user_request}

WORKERS DISPONIBLES:
{worker_info}

Tu tarea es:
1. Analizar la solicitud del usuario
2. Descomponerla en subtareas
3. Asignar cada subtarea al worker m√°s apropiado
4. Definir el orden de ejecuci√≥n (algunas tareas pueden depender de otras)

Responde en JSON:
{{
    "analysis": "breve an√°lisis de la solicitud",
    "tasks": [
        {{
            "task_id": "t1",
            "description": "descripci√≥n de la tarea",
            "assigned_to": "nombre_del_worker",
            "depends_on": []  // IDs de tareas que deben completarse primero
        }},
        ...
    ],
    "execution_order": ["t1", "t2", ...]
}}"""

        response = self.model.generate_content(prompt)

        try:
            json_str = response.text
            if "```json" in json_str:
                json_str = json_str.split("```json")[1].split("```")[0]
            elif "```" in json_str:
                json_str = json_str.split("```")[1].split("```")[0]

            plan = json.loads(json_str)
            return plan
        except Exception as e:
            print(f"Error planificando: {e}")
            return {"tasks": [], "execution_order": []}

    def _execute_task(self, task: Task) -> Task:
        """Ejecuta una tarea deleg√°ndola al worker asignado."""
        worker = self.workers.get(task.assigned_to)

        if not worker:
            task.status = TaskStatus.FAILED
            task.error = f"Worker '{task.assigned_to}' no encontrado"
            return task

        try:
            task.status = TaskStatus.IN_PROGRESS
            result = worker.execute(task)
            task.result = result
            task.status = TaskStatus.COMPLETED
        except Exception as e:
            task.status = TaskStatus.FAILED
            task.error = str(e)

        self.task_history.append(task)
        return task

    def _synthesize_results(
        self,
        user_request: str,
        completed_tasks: List[Task]
    ) -> str:
        """Sintetiza los resultados de todas las tareas."""
        results_text = "\n\n".join([
            f"[Tarea: {t.description}]\n"
            f"Worker: {t.assigned_to}\n"
            f"Resultado: {t.result}"
            for t in completed_tasks
            if t.status == TaskStatus.COMPLETED
        ])

        prompt = f"""Eres un supervisor sintetizando los resultados del equipo.

SOLICITUD ORIGINAL:
{user_request}

RESULTADOS DE LOS WORKERS:
{results_text}

Genera una respuesta final coherente que:
1. Integre todos los resultados relevantes
2. Responda completamente la solicitud original
3. Sea clara y bien estructurada

RESPUESTA FINAL:"""

        response = self.model.generate_content(prompt)
        return response.text

    def run(self, user_request: str) -> Dict[str, Any]:
        """
        Ejecuta el flujo completo: planificar, ejecutar, sintetizar.
        """
        print(f"\n{'='*60}")
        print(f"SUPERVISOR: Procesando solicitud")
        print(f"{'='*60}")

        # Paso 1: Planificar
        print("\nüìã Planificando tareas...")
        plan = self._plan_task(user_request)

        if not plan.get("tasks"):
            return {
                "success": False,
                "error": "No se pudo generar un plan de tareas",
                "response": None
            }

        print(f"   An√°lisis: {plan.get('analysis', 'N/A')}")
        print(f"   Tareas planificadas: {len(plan['tasks'])}")

        # Paso 2: Ejecutar tareas en orden
        print("\n‚öôÔ∏è Ejecutando tareas...")
        completed_tasks = []
        task_results = {}

        for task_id in plan.get("execution_order", []):
            task_info = next(
                (t for t in plan["tasks"] if t["task_id"] == task_id),
                None
            )

            if not task_info:
                continue

            # Verificar dependencias
            deps = task_info.get("depends_on", [])
            deps_met = all(
                task_results.get(dep, {}).get("status") == "completed"
                for dep in deps
            )

            if not deps_met:
                print(f"   ‚ö†Ô∏è Dependencias no cumplidas para {task_id}")
                continue

            # Crear y ejecutar tarea
            task = Task(
                task_id=task_id,
                description=task_info["description"],
                assigned_to=task_info["assigned_to"],
                metadata={"dependencies": deps}
            )

            # Incluir resultados de dependencias en el contexto
            if deps:
                task.metadata["dependency_results"] = {
                    dep: task_results[dep]["result"]
                    for dep in deps
                    if dep in task_results
                }

            print(f"   ‚Üí Ejecutando: {task.description}")
            print(f"     Asignado a: {task.assigned_to}")

            executed_task = self._execute_task(task)

            task_results[task_id] = {
                "status": executed_task.status.value,
                "result": executed_task.result
            }

            if executed_task.status == TaskStatus.COMPLETED:
                completed_tasks.append(executed_task)
                print(f"     ‚úì Completada")
            else:
                print(f"     ‚úó Fall√≥: {executed_task.error}")

        # Paso 3: Sintetizar resultados
        print("\nüìù Sintetizando resultados...")
        final_response = self._synthesize_results(user_request, completed_tasks)

        return {
            "success": True,
            "plan": plan,
            "tasks_completed": len(completed_tasks),
            "tasks_total": len(plan["tasks"]),
            "response": final_response
        }
```

### Implementaci√≥n de Workers

```python
"""
Workers especializados para el sistema supervisor-worker
"""


class ResearchWorker(BaseWorker):
    """Worker especializado en investigaci√≥n."""

    def __init__(self, api_key: str):
        capabilities = WorkerCapability(
            name="Investigador",
            description="Busca y recopila informaci√≥n sobre cualquier tema",
            skills=["buscar", "investigar", "recopilar", "fuentes", "informaci√≥n"],
            tools=["web_search", "knowledge_base"]
        )
        super().__init__("investigador", capabilities)

        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel("gemini-2.0-flash")

    def execute(self, task: Task) -> str:
        """Ejecuta tarea de investigaci√≥n."""
        prompt = f"""Eres un investigador experto. Tu tarea es:

{task.description}

Proporciona informaci√≥n relevante, precisa y bien estructurada.
Incluye puntos clave y datos importantes.

RESULTADO DE LA INVESTIGACI√ìN:"""

        response = self.model.generate_content(prompt)
        return response.text


class AnalystWorker(BaseWorker):
    """Worker especializado en an√°lisis."""

    def __init__(self, api_key: str):
        capabilities = WorkerCapability(
            name="Analista",
            description="Analiza datos, eval√∫a informaci√≥n y genera insights",
            skills=["analizar", "evaluar", "comparar", "m√©tricas", "datos"],
            tools=["calculator", "data_processor"]
        )
        super().__init__("analista", capabilities)

        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel("gemini-2.0-flash")

    def execute(self, task: Task) -> str:
        """Ejecuta tarea de an√°lisis."""
        # Incluir contexto de dependencias si existe
        context = ""
        if task.metadata.get("dependency_results"):
            context = "INFORMACI√ìN PREVIA:\n"
            for dep_id, result in task.metadata["dependency_results"].items():
                context += f"[{dep_id}]: {result[:500]}...\n\n"

        prompt = f"""Eres un analista experto. Tu tarea es:

{task.description}

{context}

Proporciona un an√°lisis detallado con:
- Hallazgos principales
- Patrones identificados
- Conclusiones

AN√ÅLISIS:"""

        response = self.model.generate_content(prompt)
        return response.text


class WriterWorker(BaseWorker):
    """Worker especializado en redacci√≥n."""

    def __init__(self, api_key: str):
        capabilities = WorkerCapability(
            name="Escritor",
            description="Redacta documentos, reportes y contenido",
            skills=["escribir", "redactar", "documento", "reporte", "resumen"],
            tools=["text_editor", "formatter"]
        )
        super().__init__("escritor", capabilities)

        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel("gemini-2.0-flash")

    def execute(self, task: Task) -> str:
        """Ejecuta tarea de redacci√≥n."""
        context = ""
        if task.metadata.get("dependency_results"):
            context = "CONTENIDO BASE:\n"
            for dep_id, result in task.metadata["dependency_results"].items():
                context += f"{result}\n\n"

        prompt = f"""Eres un escritor profesional. Tu tarea es:

{task.description}

{context}

Genera contenido bien estructurado, claro y profesional.

DOCUMENTO:"""

        response = self.model.generate_content(prompt)
        return response.text


class CodeWorker(BaseWorker):
    """Worker especializado en programaci√≥n."""

    def __init__(self, api_key: str):
        capabilities = WorkerCapability(
            name="Programador",
            description="Escribe, revisa y explica c√≥digo",
            skills=["c√≥digo", "programar", "funci√≥n", "script", "implementar"],
            tools=["code_executor", "linter"]
        )
        super().__init__("programador", capabilities)

        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel("gemini-2.0-flash")

    def execute(self, task: Task) -> str:
        """Ejecuta tarea de programaci√≥n."""
        prompt = f"""Eres un programador experto. Tu tarea es:

{task.description}

Proporciona c√≥digo limpio, bien documentado y funcional.
Incluye comentarios explicativos cuando sea necesario.

C√ìDIGO:"""

        response = self.model.generate_content(prompt)
        return response.text
```

### Ejemplo de Uso Completo

```python
"""
Ejemplo completo del sistema Supervisor-Worker
"""


def demo_supervisor_worker():
    api_key = "TU_API_KEY"

    # Crear supervisor
    supervisor = Supervisor(api_key=api_key)

    # Registrar workers
    supervisor.register_worker(ResearchWorker(api_key))
    supervisor.register_worker(AnalystWorker(api_key))
    supervisor.register_worker(WriterWorker(api_key))
    supervisor.register_worker(CodeWorker(api_key))

    # Solicitud del usuario
    user_request = """
    Necesito un reporte sobre las mejores pr√°cticas de seguridad
    en APIs REST. El reporte debe incluir:
    1. Investigaci√≥n de las vulnerabilidades m√°s comunes
    2. An√°lisis de las mejores pr√°cticas actuales
    3. Un documento final con recomendaciones
    """

    # Ejecutar
    result = supervisor.run(user_request)

    print("\n" + "="*60)
    print("RESULTADO FINAL")
    print("="*60)

    if result["success"]:
        print(f"\n‚úì Tareas completadas: {result['tasks_completed']}/{result['tasks_total']}")
        print(f"\n{result['response']}")
    else:
        print(f"\n‚úó Error: {result.get('error')}")


if __name__ == "__main__":
    demo_supervisor_worker()
```

## Patrones de Delegaci√≥n

### Delegaci√≥n Directa vs Din√°mica

```python
"""
Patrones de delegaci√≥n en sistemas supervisor-worker
"""


class DelegationStrategy(Enum):
    """Estrategias de delegaci√≥n."""
    DIRECT = "direct"      # Asignaci√≥n fija por tipo de tarea
    DYNAMIC = "dynamic"    # Asignaci√≥n basada en disponibilidad y capacidad
    ROUND_ROBIN = "round_robin"  # Rotaci√≥n entre workers
    LOAD_BALANCED = "load_balanced"  # Basado en carga de trabajo


class SmartSupervisor(Supervisor):
    """
    Supervisor con delegaci√≥n inteligente.
    """

    def __init__(
        self,
        api_key: str,
        delegation_strategy: DelegationStrategy = DelegationStrategy.DYNAMIC
    ):
        super().__init__(api_key)
        self.strategy = delegation_strategy
        self.worker_load: Dict[str, int] = {}

    def _select_worker(self, task_description: str) -> Optional[str]:
        """
        Selecciona el mejor worker seg√∫n la estrategia.
        """
        if self.strategy == DelegationStrategy.DIRECT:
            return self._direct_selection(task_description)

        elif self.strategy == DelegationStrategy.DYNAMIC:
            return self._dynamic_selection(task_description)

        elif self.strategy == DelegationStrategy.LOAD_BALANCED:
            return self._load_balanced_selection(task_description)

        elif self.strategy == DelegationStrategy.ROUND_ROBIN:
            return self._round_robin_selection()

        return None

    def _direct_selection(self, task_description: str) -> Optional[str]:
        """Selecci√≥n directa basada en skills."""
        for name, worker in self.workers.items():
            if worker.can_handle(task_description):
                return name
        return None

    def _dynamic_selection(self, task_description: str) -> Optional[str]:
        """Selecci√≥n din√°mica usando el LLM."""
        worker_info = self._get_worker_descriptions()

        prompt = f"""Selecciona el worker m√°s apropiado para esta tarea.

TAREA: {task_description}

WORKERS DISPONIBLES:
{worker_info}

Responde SOLO con el nombre del worker m√°s apropiado."""

        response = self.model.generate_content(prompt)
        worker_name = response.text.strip().lower()

        # Buscar coincidencia
        for name in self.workers:
            if name.lower() in worker_name or worker_name in name.lower():
                return name

        return None

    def _load_balanced_selection(self, task_description: str) -> Optional[str]:
        """Selecci√≥n basada en carga de trabajo."""
        capable_workers = [
            name for name, worker in self.workers.items()
            if worker.can_handle(task_description)
        ]

        if not capable_workers:
            return None

        # Seleccionar el de menor carga
        return min(
            capable_workers,
            key=lambda w: self.worker_load.get(w, 0)
        )

    def _round_robin_selection(self) -> Optional[str]:
        """Selecci√≥n round-robin."""
        if not self.workers:
            return None

        workers = list(self.workers.keys())
        # Usar historial para determinar el siguiente
        last_used = None
        if self.task_history:
            last_used = self.task_history[-1].assigned_to

        if last_used and last_used in workers:
            idx = workers.index(last_used)
            return workers[(idx + 1) % len(workers)]

        return workers[0]
```

## Manejo de Errores y Recuperaci√≥n

```python
"""
Manejo de errores y estrategias de recuperaci√≥n
"""


class ResilientSupervisor(Supervisor):
    """
    Supervisor con manejo robusto de errores.
    """

    def __init__(
        self,
        api_key: str,
        max_retries: int = 3,
        fallback_enabled: bool = True
    ):
        super().__init__(api_key)
        self.max_retries = max_retries
        self.fallback_enabled = fallback_enabled

    def _execute_with_retry(self, task: Task) -> Task:
        """Ejecuta tarea con reintentos."""
        retries = 0

        while retries < self.max_retries:
            executed = self._execute_task(task)

            if executed.status == TaskStatus.COMPLETED:
                return executed

            retries += 1
            print(f"   Reintento {retries}/{self.max_retries}...")

            # Esperar antes de reintentar
            import time
            time.sleep(1)

        return executed

    def _find_fallback_worker(self, original_worker: str, task: Task) -> Optional[str]:
        """Encuentra un worker alternativo."""
        for name, worker in self.workers.items():
            if name != original_worker and worker.can_handle(task.description):
                return name
        return None

    def _execute_with_fallback(self, task: Task) -> Task:
        """Ejecuta con fallback a otro worker si falla."""
        executed = self._execute_with_retry(task)

        if executed.status == TaskStatus.FAILED and self.fallback_enabled:
            fallback_worker = self._find_fallback_worker(
                task.assigned_to,
                task
            )

            if fallback_worker:
                print(f"   Usando fallback: {fallback_worker}")
                task.assigned_to = fallback_worker
                task.status = TaskStatus.PENDING
                executed = self._execute_with_retry(task)

        return executed

    def _handle_partial_failure(
        self,
        completed: List[Task],
        failed: List[Task],
        user_request: str
    ) -> str:
        """Genera respuesta parcial si algunas tareas fallaron."""
        prompt = f"""Algunas tareas fallaron. Genera la mejor respuesta posible
con los resultados disponibles.

SOLICITUD ORIGINAL: {user_request}

TAREAS COMPLETADAS:
{self._format_tasks(completed)}

TAREAS FALLIDAS:
{self._format_failed_tasks(failed)}

Genera una respuesta √∫til indicando qu√© informaci√≥n est√° disponible
y qu√© no se pudo obtener.

RESPUESTA:"""

        response = self.model.generate_content(prompt)
        return response.text

    def _format_tasks(self, tasks: List[Task]) -> str:
        return "\n".join([
            f"- {t.description}: {t.result[:200]}..."
            for t in tasks
        ])

    def _format_failed_tasks(self, tasks: List[Task]) -> str:
        return "\n".join([
            f"- {t.description}: Error - {t.error}"
            for t in tasks
        ])
```

## Ejercicio Pr√°ctico

```python
"""
EJERCICIO: Sistema de Soporte Multi-Agente

Implementa un sistema de soporte al cliente con m√∫ltiples agentes:
- Clasificador: Clasifica el tipo de consulta
- FAQ: Responde preguntas frecuentes
- T√©cnico: Resuelve problemas t√©cnicos
- Escalador: Escala casos complejos
"""


class SupportSupervisor(Supervisor):
    """
    Supervisor especializado para soporte al cliente.

    TODO: Implementar las funcionalidades.
    """

    def __init__(self, api_key: str):
        super().__init__(api_key)
        # TODO: Configurar workers de soporte

    def classify_ticket(self, ticket: str) -> Dict:
        """
        Clasifica un ticket de soporte.

        TODO:
        1. Analizar el contenido del ticket
        2. Determinar categor√≠a (t√©cnico, facturaci√≥n, general)
        3. Determinar prioridad (alta, media, baja)
        4. Determinar si requiere escalaci√≥n
        """
        pass

    def route_ticket(self, ticket: str, classification: Dict) -> str:
        """
        Enruta el ticket al worker apropiado.

        TODO:
        1. Basado en la clasificaci√≥n, seleccionar worker
        2. Ejecutar el flujo correspondiente
        3. Retornar respuesta
        """
        pass

    def handle_escalation(self, ticket: str, context: Dict) -> str:
        """
        Maneja tickets que requieren escalaci√≥n.

        TODO:
        1. Preparar contexto completo
        2. Notificar para revisi√≥n humana
        3. Proporcionar respuesta temporal
        """
        pass


class FAQWorker(BaseWorker):
    """Worker para preguntas frecuentes."""

    def __init__(self, api_key: str, faq_database: Dict):
        # TODO: Implementar
        pass

    def execute(self, task: Task) -> str:
        # TODO: Buscar en FAQ y responder
        pass


class TechnicalWorker(BaseWorker):
    """Worker para soporte t√©cnico."""

    def __init__(self, api_key: str, knowledge_base):
        # TODO: Implementar
        pass

    def execute(self, task: Task) -> str:
        # TODO: Diagnosticar y resolver problema t√©cnico
        pass


def test_support_system():
    """Prueba el sistema de soporte."""
    # TODO: Implementar pruebas
    pass
```

## Resumen

| Componente | Responsabilidad | Caracter√≠sticas |
|------------|-----------------|-----------------|
| Supervisor | Orquestar | Planifica, delega, sintetiza |
| Worker | Ejecutar | Especializado, enfocado |
| Task | Comunicar | Descripci√≥n, estado, resultado |

### Checklist de Implementaci√≥n

- [ ] Definir workers con capacidades claras
- [ ] Implementar planificaci√≥n de tareas
- [ ] Configurar estrategia de delegaci√≥n
- [ ] Agregar manejo de errores y fallbacks
- [ ] Implementar s√≠ntesis de resultados
- [ ] Agregar logging y monitoreo

## Siguiente Paso

En el pr√≥ximo subtema exploraremos **Debate y Consenso entre Agentes**, donde m√∫ltiples agentes discuten y llegan a acuerdos.
