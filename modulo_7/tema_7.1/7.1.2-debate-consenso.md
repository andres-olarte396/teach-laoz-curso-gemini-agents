# 7.1.2 Debate y Consenso entre Agentes

## Objetivo de Aprendizaje

Al finalizar este subtema, ser√°s capaz de implementar sistemas donde m√∫ltiples agentes debaten, argumentan y llegan a consenso para resolver problemas complejos.

## Introducci√≥n

El patr√≥n de **Debate y Consenso** permite que m√∫ltiples agentes con diferentes perspectivas o roles discutan un tema y lleguen a una conclusi√≥n conjunta. Este enfoque mejora la calidad de las decisiones al considerar m√∫ltiples puntos de vista.

### Flujo de Debate

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    FLUJO DE DEBATE Y CONSENSO                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                  ‚îÇ
‚îÇ  1. PROPOSICI√ìN                                                  ‚îÇ
‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îÇ
‚îÇ     ‚îÇ Moderador presenta el tema a debatir        ‚îÇ             ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ
‚îÇ                          ‚îÇ                                       ‚îÇ
‚îÇ                          ‚ñº                                       ‚îÇ
‚îÇ  2. POSICIONES INICIALES                                        ‚îÇ
‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ     ‚îÇAgente A ‚îÇ     ‚îÇAgente B ‚îÇ     ‚îÇAgente C ‚îÇ                ‚îÇ
‚îÇ     ‚îÇPosici√≥n ‚îÇ     ‚îÇPosici√≥n ‚îÇ     ‚îÇPosici√≥n ‚îÇ                ‚îÇ
‚îÇ     ‚îÇ   #1    ‚îÇ     ‚îÇ   #2    ‚îÇ     ‚îÇ   #3    ‚îÇ                ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ          ‚îÇ               ‚îÇ               ‚îÇ                       ‚îÇ
‚îÇ          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ
‚îÇ                          ‚îÇ                                       ‚îÇ
‚îÇ                          ‚ñº                                       ‚îÇ
‚îÇ  3. RONDAS DE DEBATE                                            ‚îÇ
‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îÇ
‚îÇ     ‚îÇ ‚Ä¢ A responde a B y C                        ‚îÇ             ‚îÇ
‚îÇ     ‚îÇ ‚Ä¢ B responde a A y C                        ‚îÇ             ‚îÇ
‚îÇ     ‚îÇ ‚Ä¢ C responde a A y B                        ‚îÇ             ‚îÇ
‚îÇ     ‚îÇ ‚Ä¢ Refinamiento de posiciones                ‚îÇ             ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ
‚îÇ                          ‚îÇ                                       ‚îÇ
‚îÇ                          ‚ñº                                       ‚îÇ
‚îÇ  4. VOTACI√ìN / S√çNTESIS                                         ‚îÇ
‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îÇ
‚îÇ     ‚îÇ Moderador sintetiza consenso o decide       ‚îÇ             ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n del Sistema de Debate

### Estructura Base

```python
"""
Sistema de Debate y Consenso Multi-Agente
"""
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import List, Dict, Optional
from enum import Enum
import json


class DebateRole(Enum):
    """Roles en un debate."""
    PROPONENT = "proponent"      # A favor
    OPPONENT = "opponent"        # En contra
    NEUTRAL = "neutral"          # Neutral/anal√≠tico
    MODERATOR = "moderator"      # Moderador


@dataclass
class Argument:
    """Representa un argumento en el debate."""
    agent_name: str
    role: DebateRole
    content: str
    round_number: int
    responds_to: Optional[str] = None  # Nombre del agente al que responde
    confidence: float = 0.5


@dataclass
class DebateState:
    """Estado actual del debate."""
    topic: str
    arguments: List[Argument] = field(default_factory=list)
    current_round: int = 0
    consensus_reached: bool = False
    final_conclusion: Optional[str] = None


class DebateAgent:
    """
    Agente participante en un debate.
    """

    def __init__(
        self,
        name: str,
        role: DebateRole,
        perspective: str,
        api_key: str
    ):
        self.name = name
        self.role = role
        self.perspective = perspective

        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel("gemini-2.0-flash")

    def generate_initial_position(self, topic: str) -> Argument:
        """Genera posici√≥n inicial sobre el tema."""
        prompt = f"""Eres {self.name}, un debatiente con la siguiente perspectiva:
{self.perspective}

Tu rol en este debate es: {self.role.value}

TEMA A DEBATIR:
{topic}

Genera tu posici√≥n inicial sobre el tema. Incluye:
1. Tu postura principal
2. 2-3 argumentos que la soporten
3. Evidencia o razonamiento

Mant√©n un tono profesional y constructivo.

TU POSICI√ìN INICIAL:"""

        response = self.model.generate_content(prompt)

        return Argument(
            agent_name=self.name,
            role=self.role,
            content=response.text,
            round_number=0
        )

    def respond_to_arguments(
        self,
        topic: str,
        other_arguments: List[Argument],
        round_number: int
    ) -> Argument:
        """Responde a los argumentos de otros agentes."""
        others_text = "\n\n".join([
            f"[{arg.agent_name} ({arg.role.value})]:\n{arg.content}"
            for arg in other_arguments
            if arg.agent_name != self.name
        ])

        prompt = f"""Eres {self.name} en un debate sobre:
{topic}

Tu perspectiva: {self.perspective}
Tu rol: {self.role.value}

ARGUMENTOS DE OTROS PARTICIPANTES:
{others_text}

Responde a estos argumentos:
1. Reconoce puntos v√°lidos de otros
2. Contraargumenta donde no est√©s de acuerdo
3. Refuerza o ajusta tu posici√≥n
4. Busca puntos de consenso si es posible

TU RESPUESTA:"""

        response = self.model.generate_content(prompt)

        return Argument(
            agent_name=self.name,
            role=self.role,
            content=response.text,
            round_number=round_number
        )

    def evaluate_consensus(
        self,
        topic: str,
        all_arguments: List[Argument]
    ) -> Dict:
        """Eval√∫a si hay consenso y cu√°l es su posici√≥n final."""
        all_text = "\n\n".join([
            f"[{arg.agent_name}] (Ronda {arg.round_number}):\n{arg.content}"
            for arg in all_arguments
        ])

        prompt = f"""Eval√∫a el estado del debate sobre:
{topic}

TODOS LOS ARGUMENTOS:
{all_text}

Responde en JSON:
{{
    "consensus_possible": true/false,
    "common_ground": ["punto 1", "punto 2"],
    "remaining_disagreements": ["desacuerdo 1"],
    "your_final_position": "tu posici√≥n final considerando el debate",
    "confidence": 0.0 a 1.0
}}"""

        response = self.model.generate_content(prompt)

        try:
            json_str = response.text
            if "```json" in json_str:
                json_str = json_str.split("```json")[1].split("```")[0]
            return json.loads(json_str)
        except:
            return {
                "consensus_possible": False,
                "common_ground": [],
                "your_final_position": "No se pudo evaluar"
            }


class DebateModerator:
    """
    Moderador que gestiona el debate y sintetiza conclusiones.
    """

    def __init__(self, api_key: str):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel("gemini-2.0-flash")

    def introduce_topic(self, topic: str) -> str:
        """Presenta el tema del debate."""
        prompt = f"""Eres un moderador de debate. Presenta el siguiente tema
de manera neutral y equilibrada:

{topic}

Incluye:
1. Contexto del tema
2. Por qu√© es importante discutirlo
3. Las diferentes perspectivas que existen

INTRODUCCI√ìN:"""

        response = self.model.generate_content(prompt)
        return response.text

    def summarize_round(
        self,
        round_number: int,
        arguments: List[Argument]
    ) -> str:
        """Resume una ronda de debate."""
        args_text = "\n\n".join([
            f"[{arg.agent_name}]: {arg.content[:500]}..."
            for arg in arguments
            if arg.round_number == round_number
        ])

        prompt = f"""Resume objetivamente los puntos principales de esta
ronda de debate:

ARGUMENTOS DE LA RONDA {round_number}:
{args_text}

Incluye:
1. Puntos principales de cada participante
2. √Åreas de acuerdo identificadas
3. Puntos de desacuerdo persistentes

RESUMEN DE LA RONDA:"""

        response = self.model.generate_content(prompt)
        return response.text

    def synthesize_consensus(
        self,
        topic: str,
        all_arguments: List[Argument],
        agent_evaluations: List[Dict]
    ) -> Dict:
        """Sintetiza el consenso final del debate."""
        args_summary = "\n".join([
            f"- {arg.agent_name}: {arg.content[:200]}..."
            for arg in all_arguments
        ])

        evals_summary = "\n".join([
            f"- Evaluaci√≥n: consenso={e.get('consensus_possible')}, "
            f"puntos comunes={len(e.get('common_ground', []))}"
            for e in agent_evaluations
        ])

        prompt = f"""Como moderador, sintetiza la conclusi√≥n del debate.

TEMA: {topic}

RESUMEN DE ARGUMENTOS:
{args_summary}

EVALUACIONES DE LOS AGENTES:
{evals_summary}

Genera una s√≠ntesis final en JSON:
{{
    "consensus_reached": true/false,
    "consensus_summary": "resumen del consenso si se alcanz√≥",
    "key_agreements": ["acuerdo 1", "acuerdo 2"],
    "unresolved_issues": ["tema sin resolver"],
    "recommendation": "recomendaci√≥n final basada en el debate",
    "confidence_level": "high/medium/low"
}}"""

        response = self.model.generate_content(prompt)

        try:
            json_str = response.text
            if "```json" in json_str:
                json_str = json_str.split("```json")[1].split("```")[0]
            return json.loads(json_str)
        except:
            return {
                "consensus_reached": False,
                "recommendation": response.text
            }


class DebateSystem:
    """
    Sistema completo de debate multi-agente.
    """

    def __init__(
        self,
        api_key: str,
        max_rounds: int = 3
    ):
        self.api_key = api_key
        self.max_rounds = max_rounds
        self.moderator = DebateModerator(api_key)
        self.agents: List[DebateAgent] = []
        self.state: Optional[DebateState] = None

    def add_agent(
        self,
        name: str,
        role: DebateRole,
        perspective: str
    ):
        """Agrega un agente al debate."""
        agent = DebateAgent(name, role, perspective, self.api_key)
        self.agents.append(agent)

    def run_debate(self, topic: str, verbose: bool = True) -> Dict:
        """Ejecuta el debate completo."""
        self.state = DebateState(topic=topic)

        if verbose:
            print("="*60)
            print("INICIO DEL DEBATE")
            print("="*60)

            # Introducci√≥n
            intro = self.moderator.introduce_topic(topic)
            print(f"\nüì¢ MODERADOR:\n{intro}")

        # Ronda 0: Posiciones iniciales
        if verbose:
            print("\n" + "-"*40)
            print("RONDA 0: Posiciones Iniciales")
            print("-"*40)

        for agent in self.agents:
            argument = agent.generate_initial_position(topic)
            self.state.arguments.append(argument)

            if verbose:
                print(f"\nüé§ {agent.name} ({agent.role.value}):")
                print(argument.content[:500] + "...")

        # Rondas de debate
        for round_num in range(1, self.max_rounds + 1):
            self.state.current_round = round_num

            if verbose:
                print("\n" + "-"*40)
                print(f"RONDA {round_num}: Respuestas")
                print("-"*40)

            round_arguments = []

            for agent in self.agents:
                # Obtener argumentos previos
                prev_args = [
                    a for a in self.state.arguments
                    if a.round_number == round_num - 1
                ]

                argument = agent.respond_to_arguments(
                    topic, prev_args, round_num
                )
                round_arguments.append(argument)

                if verbose:
                    print(f"\nüé§ {agent.name}:")
                    print(argument.content[:400] + "...")

            self.state.arguments.extend(round_arguments)

            # Resumen de la ronda
            if verbose:
                summary = self.moderator.summarize_round(
                    round_num,
                    self.state.arguments
                )
                print(f"\nüìã MODERADOR - Resumen Ronda {round_num}:")
                print(summary)

        # Evaluaci√≥n final de cada agente
        evaluations = []
        for agent in self.agents:
            eval_result = agent.evaluate_consensus(
                topic,
                self.state.arguments
            )
            evaluations.append(eval_result)

        # S√≠ntesis del moderador
        conclusion = self.moderator.synthesize_consensus(
            topic,
            self.state.arguments,
            evaluations
        )

        self.state.final_conclusion = conclusion.get("recommendation")
        self.state.consensus_reached = conclusion.get("consensus_reached", False)

        if verbose:
            print("\n" + "="*60)
            print("CONCLUSI√ìN DEL DEBATE")
            print("="*60)
            print(f"\n‚úì Consenso alcanzado: {self.state.consensus_reached}")
            print(f"\nüìå Acuerdos clave:")
            for agreement in conclusion.get("key_agreements", []):
                print(f"   - {agreement}")
            print(f"\nüìã Recomendaci√≥n: {conclusion.get('recommendation')}")

        return conclusion


# Ejemplo de uso
def demo_debate():
    api_key = "TU_API_KEY"

    # Crear sistema de debate
    debate = DebateSystem(api_key, max_rounds=2)

    # Agregar agentes con diferentes perspectivas
    debate.add_agent(
        name="TechOptimist",
        role=DebateRole.PROPONENT,
        perspective="Creo firmemente que la IA generativa mejorar√° la productividad "
                   "y crear√° nuevas oportunidades. Los beneficios superan los riesgos."
    )

    debate.add_agent(
        name="CautiousAnalyst",
        role=DebateRole.OPPONENT,
        perspective="Soy esc√©ptico sobre el impacto de la IA generativa. "
                   "Hay riesgos significativos que debemos abordar antes de adopci√≥n masiva."
    )

    debate.add_agent(
        name="BalancedExpert",
        role=DebateRole.NEUTRAL,
        perspective="Busco un enfoque equilibrado. La IA tiene potencial pero "
                   "requiere regulaci√≥n y implementaci√≥n cuidadosa."
    )

    # Ejecutar debate
    topic = """
    ¬øDeber√≠an las empresas adoptar IA generativa para automatizar
    tareas de atenci√≥n al cliente?

    Consideren: calidad del servicio, costos, empleo, satisfacci√≥n del cliente.
    """

    result = debate.run_debate(topic, verbose=True)

    return result


if __name__ == "__main__":
    demo_debate()
```

## Votaci√≥n y Mecanismos de Consenso

```python
"""
Mecanismos de votaci√≥n y consenso para sistemas multi-agente
"""
from typing import List, Dict
from enum import Enum


class VotingMethod(Enum):
    """M√©todos de votaci√≥n."""
    MAJORITY = "majority"           # Mayor√≠a simple
    UNANIMOUS = "unanimous"         # Unanimidad
    WEIGHTED = "weighted"           # Voto ponderado
    RANKED_CHOICE = "ranked_choice" # Voto preferencial


class ConsensusEngine:
    """
    Motor de consenso para decisiones multi-agente.
    """

    def __init__(self, method: VotingMethod = VotingMethod.MAJORITY):
        self.method = method
        self.votes: Dict[str, Dict] = {}

    def cast_vote(
        self,
        agent_name: str,
        vote: str,
        confidence: float = 1.0,
        reasoning: str = ""
    ):
        """Registra el voto de un agente."""
        self.votes[agent_name] = {
            "vote": vote,
            "confidence": confidence,
            "reasoning": reasoning
        }

    def _majority_vote(self, options: List[str]) -> Dict:
        """Votaci√≥n por mayor√≠a simple."""
        vote_counts = {}
        for agent, vote_info in self.votes.items():
            vote = vote_info["vote"]
            vote_counts[vote] = vote_counts.get(vote, 0) + 1

        if not vote_counts:
            return {"winner": None, "method": "majority"}

        winner = max(vote_counts, key=vote_counts.get)
        total_votes = sum(vote_counts.values())

        return {
            "winner": winner,
            "votes": vote_counts,
            "percentage": vote_counts[winner] / total_votes,
            "method": "majority"
        }

    def _weighted_vote(self, options: List[str]) -> Dict:
        """Votaci√≥n ponderada por confianza."""
        weighted_counts = {}

        for agent, vote_info in self.votes.items():
            vote = vote_info["vote"]
            weight = vote_info["confidence"]
            weighted_counts[vote] = weighted_counts.get(vote, 0) + weight

        if not weighted_counts:
            return {"winner": None, "method": "weighted"}

        winner = max(weighted_counts, key=weighted_counts.get)
        total_weight = sum(weighted_counts.values())

        return {
            "winner": winner,
            "weighted_scores": weighted_counts,
            "percentage": weighted_counts[winner] / total_weight,
            "method": "weighted"
        }

    def _unanimous_vote(self, options: List[str]) -> Dict:
        """Requiere unanimidad."""
        votes = [v["vote"] for v in self.votes.values()]
        unique_votes = set(votes)

        if len(unique_votes) == 1:
            return {
                "winner": votes[0],
                "unanimous": True,
                "method": "unanimous"
            }

        return {
            "winner": None,
            "unanimous": False,
            "dissenting_votes": list(unique_votes),
            "method": "unanimous"
        }

    def compute_result(self, options: List[str] = None) -> Dict:
        """Calcula el resultado seg√∫n el m√©todo configurado."""
        if self.method == VotingMethod.MAJORITY:
            return self._majority_vote(options)
        elif self.method == VotingMethod.WEIGHTED:
            return self._weighted_vote(options)
        elif self.method == VotingMethod.UNANIMOUS:
            return self._unanimous_vote(options)
        else:
            return self._majority_vote(options)

    def get_reasoning_summary(self) -> List[Dict]:
        """Retorna resumen de razonamientos."""
        return [
            {
                "agent": agent,
                "vote": info["vote"],
                "confidence": info["confidence"],
                "reasoning": info["reasoning"]
            }
            for agent, info in self.votes.items()
        ]


class DebateWithVoting(DebateSystem):
    """
    Sistema de debate con votaci√≥n formal al final.
    """

    def __init__(
        self,
        api_key: str,
        voting_method: VotingMethod = VotingMethod.WEIGHTED
    ):
        super().__init__(api_key)
        self.consensus_engine = ConsensusEngine(voting_method)

    def _collect_votes(
        self,
        topic: str,
        options: List[str]
    ) -> Dict:
        """Recolecta votos de todos los agentes."""
        for agent in self.agents:
            vote_prompt = f"""Bas√°ndote en el debate sobre:
{topic}

Y considerando todos los argumentos presentados, vota por una de estas opciones:
{', '.join(options)}

Responde en JSON:
{{
    "vote": "tu voto",
    "confidence": 0.0 a 1.0,
    "reasoning": "breve justificaci√≥n"
}}"""

            response = agent.model.generate_content(vote_prompt)

            try:
                vote_data = json.loads(response.text)
                self.consensus_engine.cast_vote(
                    agent.name,
                    vote_data["vote"],
                    vote_data.get("confidence", 0.5),
                    vote_data.get("reasoning", "")
                )
            except:
                pass

        return self.consensus_engine.compute_result(options)

    def run_debate_with_vote(
        self,
        topic: str,
        options: List[str],
        verbose: bool = True
    ) -> Dict:
        """Ejecuta debate con votaci√≥n final."""
        # Ejecutar debate normal
        debate_result = self.run_debate(topic, verbose)

        # Votaci√≥n
        if verbose:
            print("\n" + "="*60)
            print("VOTACI√ìN FINAL")
            print("="*60)
            print(f"Opciones: {options}")

        vote_result = self._collect_votes(topic, options)

        if verbose:
            print(f"\nüìä Resultado: {vote_result['winner']}")
            if 'percentage' in vote_result:
                print(f"   Apoyo: {vote_result['percentage']:.1%}")

            print("\nüìù Votos individuales:")
            for summary in self.consensus_engine.get_reasoning_summary():
                print(f"   {summary['agent']}: {summary['vote']} "
                      f"(confianza: {summary['confidence']:.0%})")

        return {
            "debate_conclusion": debate_result,
            "vote_result": vote_result,
            "reasoning_summary": self.consensus_engine.get_reasoning_summary()
        }
```

## Debate Adversarial

```python
"""
Debate adversarial para mejorar razonamiento
"""


class AdversarialDebate:
    """
    Debate adversarial donde agentes intentan refutar argumentos.
    √ötil para identificar debilidades en razonamientos.
    """

    def __init__(self, api_key: str):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel("gemini-2.0-flash")

    def generate_argument(self, topic: str, position: str) -> str:
        """Genera argumento para una posici√≥n."""
        prompt = f"""Genera un argumento s√≥lido para la siguiente posici√≥n.

TEMA: {topic}
POSICI√ìN: {position}

Incluye:
1. Tesis clara
2. Evidencia o razonamiento
3. Anticipaci√≥n de contraargumentos

ARGUMENTO:"""

        response = self.model.generate_content(prompt)
        return response.text

    def generate_counterargument(self, original_argument: str) -> str:
        """Genera contraargumento intentando refutar."""
        prompt = f"""Tu objetivo es encontrar debilidades y refutar
el siguiente argumento.

ARGUMENTO A REFUTAR:
{original_argument}

Genera un contraargumento que:
1. Identifique falacias o debilidades l√≥gicas
2. Presente evidencia contraria
3. Proponga una perspectiva alternativa

CONTRAARGUMENTO:"""

        response = self.model.generate_content(prompt)
        return response.text

    def evaluate_argument_strength(
        self,
        argument: str,
        counterarguments: List[str]
    ) -> Dict:
        """Eval√∫a la fortaleza de un argumento despu√©s del escrutinio."""
        counter_text = "\n\n".join([
            f"Contraargumento {i+1}:\n{c}"
            for i, c in enumerate(counterarguments)
        ])

        prompt = f"""Eval√∫a la fortaleza del argumento original despu√©s de
considerar los contraargumentos.

ARGUMENTO ORIGINAL:
{argument}

CONTRAARGUMENTOS:
{counter_text}

Eval√∫a en JSON:
{{
    "original_strength": 0-10,
    "post_scrutiny_strength": 0-10,
    "weaknesses_identified": ["debilidad 1", "debilidad 2"],
    "points_that_survived": ["punto fuerte 1"],
    "refined_argument": "versi√≥n mejorada del argumento original"
}}"""

        response = self.model.generate_content(prompt)

        try:
            return json.loads(response.text)
        except:
            return {"evaluation": response.text}

    def run_adversarial_debate(
        self,
        topic: str,
        initial_position: str,
        num_rounds: int = 3
    ) -> Dict:
        """Ejecuta debate adversarial para refinar un argumento."""
        print(f"üéØ Tema: {topic}")
        print(f"üìù Posici√≥n inicial: {initial_position}\n")

        # Generar argumento inicial
        current_argument = self.generate_argument(topic, initial_position)
        print("="*50)
        print("ARGUMENTO INICIAL:")
        print(current_argument)

        all_counterarguments = []

        for round_num in range(num_rounds):
            print(f"\n{'='*50}")
            print(f"RONDA {round_num + 1}: Contraargumentaci√≥n")
            print("="*50)

            # Generar contraargumento
            counter = self.generate_counterargument(current_argument)
            all_counterarguments.append(counter)
            print(f"\n‚öîÔ∏è Contraargumento:\n{counter}")

            # Refinar argumento
            refine_prompt = f"""Tu argumento fue contraargumentado.

TU ARGUMENTO:
{current_argument}

CONTRAARGUMENTO RECIBIDO:
{counter}

Refina tu argumento para:
1. Responder al contraargumento
2. Fortalecer los puntos d√©biles
3. Mantener tu posici√≥n con mejores fundamentos

ARGUMENTO REFINADO:"""

            response = self.model.generate_content(refine_prompt)
            current_argument = response.text
            print(f"\nüîÑ Argumento refinado:\n{current_argument}")

        # Evaluaci√≥n final
        evaluation = self.evaluate_argument_strength(
            current_argument,
            all_counterarguments
        )

        print(f"\n{'='*50}")
        print("EVALUACI√ìN FINAL")
        print("="*50)
        print(f"Fortaleza final: {evaluation.get('post_scrutiny_strength', 'N/A')}/10")

        return {
            "final_argument": current_argument,
            "counterarguments": all_counterarguments,
            "evaluation": evaluation
        }
```

## Ejercicio Pr√°ctico

```python
"""
EJERCICIO: Panel de Expertos para Decisiones T√©cnicas

Implementa un panel de expertos que debatan decisiones
de arquitectura de software.
"""


class TechnicalExpertPanel:
    """
    Panel de expertos t√©cnicos para decisiones de arquitectura.

    TODO: Implementar las funcionalidades.
    """

    def __init__(self, api_key: str):
        """
        TODO:
        1. Crear expertos con diferentes especialidades
        2. Configurar moderador t√©cnico
        """
        pass

    def setup_experts(self):
        """
        Configura expertos con diferentes perspectivas:
        - Arquitecto de Software: escalabilidad, patrones
        - Especialista en Seguridad: vulnerabilidades, compliance
        - DevOps Engineer: operabilidad, deployment
        - Product Owner: costo, tiempo, valor de negocio

        TODO: Implementar
        """
        pass

    def evaluate_architecture_decision(
        self,
        decision: str,
        context: Dict
    ) -> Dict:
        """
        Eval√∫a una decisi√≥n de arquitectura.

        decision: Ejemplo "Migrar a microservicios"
        context: {
            "current_state": "monolito",
            "team_size": 10,
            "budget": "medio",
            "timeline": "6 meses"
        }

        TODO:
        1. Cada experto da su perspectiva
        2. Debaten pros y contras
        3. Votaci√≥n ponderada por √°rea de expertise
        4. Generar recomendaci√≥n final
        """
        pass

    def generate_decision_document(
        self,
        decision: str,
        debate_result: Dict
    ) -> str:
        """
        Genera ADR (Architecture Decision Record).

        TODO:
        1. Formato est√°ndar de ADR
        2. Incluir argumentos de cada experto
        3. Documentar la decisi√≥n final
        4. Listar riesgos y mitigaciones
        """
        pass


def test_expert_panel():
    """Prueba el panel de expertos."""
    # TODO: Implementar pruebas
    pass
```

## Resumen

| Mecanismo | Uso | Ventaja |
|-----------|-----|---------|
| Debate estructurado | Explorar perspectivas | Considera m√∫ltiples √°ngulos |
| Votaci√≥n | Decisi√≥n formal | Clara y democr√°tica |
| Adversarial | Refinar argumentos | Identifica debilidades |
| Consenso | Acuerdo colectivo | Mayor buy-in |

### Checklist de Implementaci√≥n

- [ ] Definir roles claros para cada agente
- [ ] Estructurar rondas de debate
- [ ] Implementar moderaci√≥n neutral
- [ ] Agregar mecanismo de votaci√≥n
- [ ] Sintetizar conclusiones
- [ ] Documentar el proceso de decisi√≥n

## Siguiente Paso

En el pr√≥ximo subtema exploraremos **Pipeline de Agentes Especializados**, donde agentes se encadenan en flujos de procesamiento.
