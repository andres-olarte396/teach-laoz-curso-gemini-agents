# 7.2.3 Manejo de Conflictos y Deadlocks

## Objetivo de Aprendizaje

Implementar estrategias robustas para detectar, prevenir y resolver conflictos entre agentes, incluyendo detección de deadlocks, resolución de disputas y mecanismos de recuperación automática.

## Introducción

En sistemas multi-agente, los conflictos son inevitables cuando múltiples agentes compiten por recursos o tienen objetivos contradictorios. Los deadlocks pueden paralizar el sistema completo. Un diseño robusto requiere mecanismos proactivos de prevención y reactivos de recuperación.

```
┌─────────────────────────────────────────────────────────────────┐
│                    TIPOS DE CONFLICTOS                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  RECURSOS          DATOS             OBJETIVOS     DEADLOCK    │
│  ┌─────┐          ┌─────┐           ┌─────┐      ┌─────┐       │
│  │ R1  │←─A1      │ D1  │←─A1       │ G1  │←A1   │ A1  │→wait  │
│  │     │←─A2      │     │←─A2       │     │←A2   │  ↑  │  ↓    │
│  └─────┘          └─────┘           └─────┘      │wait←│ A2  │ │
│  Competencia      Inconsistencia    Contradicción └─────┘      │
│                                                                 │
│  ESTRATEGIAS DE RESOLUCIÓN:                                    │
│  ├─ Prevención: Evitar condiciones de conflicto                │
│  ├─ Detección: Identificar conflictos temprano                 │
│  ├─ Resolución: Aplicar políticas de resolución                │
│  └─ Recuperación: Restaurar estado consistente                 │
└─────────────────────────────────────────────────────────────────┘
```

## Detección y Prevención de Deadlocks

```python
"""
Sistema de detección y prevención de deadlocks.
"""
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Dict, List, Set, Optional, Any, Tuple
from datetime import datetime, timedelta
from enum import Enum
import threading
import asyncio
from collections import defaultdict
import time


class ResourceState(Enum):
    """Estados de un recurso."""
    FREE = "free"
    HELD = "held"
    WAITING = "waiting"


@dataclass
class Resource:
    """Recurso que puede ser solicitado por agentes."""
    resource_id: str
    resource_type: str
    state: ResourceState = ResourceState.FREE
    holder: Optional[str] = None
    waiters: List[str] = field(default_factory=list)
    acquired_at: Optional[datetime] = None
    max_hold_time: int = 60  # segundos


@dataclass
class ResourceRequest:
    """Solicitud de recurso por un agente."""
    agent_id: str
    resource_id: str
    request_type: str  # "exclusive" o "shared"
    priority: int = 0
    timestamp: datetime = field(default_factory=datetime.now)
    timeout: int = 30


class DeadlockDetector:
    """Detector de deadlocks usando algoritmo de detección de ciclos."""

    def __init__(self):
        self.wait_for_graph: Dict[str, Set[str]] = defaultdict(set)
        self._lock = threading.Lock()

    def add_wait(self, waiter: str, holder: str):
        """Registra que waiter espera por holder."""
        with self._lock:
            self.wait_for_graph[waiter].add(holder)

    def remove_wait(self, waiter: str, holder: str = None):
        """Elimina espera."""
        with self._lock:
            if holder:
                self.wait_for_graph[waiter].discard(holder)
            else:
                self.wait_for_graph.pop(waiter, None)

    def detect_deadlock(self) -> Optional[List[str]]:
        """Detecta deadlock retornando el ciclo si existe."""
        with self._lock:
            # DFS para detectar ciclos
            visited = set()
            rec_stack = set()
            path = []

            def dfs(node: str) -> Optional[List[str]]:
                visited.add(node)
                rec_stack.add(node)
                path.append(node)

                for neighbor in self.wait_for_graph.get(node, set()):
                    if neighbor not in visited:
                        result = dfs(neighbor)
                        if result:
                            return result
                    elif neighbor in rec_stack:
                        # Encontramos ciclo
                        cycle_start = path.index(neighbor)
                        return path[cycle_start:] + [neighbor]

                path.pop()
                rec_stack.remove(node)
                return None

            # Verificar desde cada nodo
            for node in list(self.wait_for_graph.keys()):
                if node not in visited:
                    cycle = dfs(node)
                    if cycle:
                        return cycle

            return None

    def get_wait_chain(self, agent_id: str) -> List[str]:
        """Obtiene la cadena de espera de un agente."""
        chain = [agent_id]
        current = agent_id

        with self._lock:
            visited = set()
            while current not in visited:
                visited.add(current)
                holders = self.wait_for_graph.get(current, set())
                if holders:
                    next_holder = list(holders)[0]
                    chain.append(next_holder)
                    current = next_holder
                else:
                    break

        return chain


class ResourceManager:
    """Gestor de recursos con prevención de deadlocks."""

    def __init__(self, deadlock_strategy: str = "prevention"):
        self.resources: Dict[str, Resource] = {}
        self.deadlock_detector = DeadlockDetector()
        self.strategy = deadlock_strategy  # prevention, detection, avoidance
        self._lock = threading.RLock()
        self._resource_order: Dict[str, int] = {}  # Para ordenamiento de recursos
        self._next_order = 0

    def register_resource(
        self,
        resource_id: str,
        resource_type: str,
        max_hold_time: int = 60
    ):
        """Registra un nuevo recurso."""
        with self._lock:
            self.resources[resource_id] = Resource(
                resource_id=resource_id,
                resource_type=resource_type,
                max_hold_time=max_hold_time
            )
            # Asignar orden para prevención de deadlocks
            self._resource_order[resource_id] = self._next_order
            self._next_order += 1

    def request_resource(
        self,
        agent_id: str,
        resource_id: str,
        timeout: int = 30
    ) -> bool:
        """Solicita un recurso con prevención de deadlock."""
        if resource_id not in self.resources:
            return False

        if self.strategy == "prevention":
            return self._request_with_ordering(agent_id, resource_id, timeout)
        elif self.strategy == "detection":
            return self._request_with_detection(agent_id, resource_id, timeout)
        else:
            return self._request_basic(agent_id, resource_id, timeout)

    def _request_with_ordering(
        self,
        agent_id: str,
        resource_id: str,
        timeout: int
    ) -> bool:
        """Solicitud con ordenamiento de recursos (prevención)."""
        with self._lock:
            resource = self.resources[resource_id]

            # Verificar que el agente no tenga recursos de orden mayor
            held_by_agent = self._get_held_resources(agent_id)
            for held_id in held_by_agent:
                if self._resource_order[held_id] > self._resource_order[resource_id]:
                    raise DeadlockPreventionError(
                        f"Agent {agent_id} debe solicitar recursos en orden. "
                        f"{resource_id} tiene orden menor que recursos ya poseídos."
                    )

            return self._acquire_or_wait(agent_id, resource, timeout)

    def _request_with_detection(
        self,
        agent_id: str,
        resource_id: str,
        timeout: int
    ) -> bool:
        """Solicitud con detección de deadlock."""
        with self._lock:
            resource = self.resources[resource_id]

            if resource.state == ResourceState.FREE:
                return self._acquire_resource(agent_id, resource)

            # Registrar espera
            self.deadlock_detector.add_wait(agent_id, resource.holder)

            # Verificar deadlock
            cycle = self.deadlock_detector.detect_deadlock()
            if cycle:
                self.deadlock_detector.remove_wait(agent_id)
                raise DeadlockDetectedError(f"Deadlock detectado: {' -> '.join(cycle)}")

            # Agregar a waiters
            resource.waiters.append(agent_id)

        # Esperar fuera del lock
        return self._wait_for_resource(agent_id, resource, timeout)

    def _acquire_or_wait(
        self,
        agent_id: str,
        resource: Resource,
        timeout: int
    ) -> bool:
        """Adquiere recurso o espera."""
        if resource.state == ResourceState.FREE:
            return self._acquire_resource(agent_id, resource)

        resource.waiters.append(agent_id)
        return self._wait_for_resource(agent_id, resource, timeout)

    def _acquire_resource(self, agent_id: str, resource: Resource) -> bool:
        """Adquiere el recurso."""
        resource.state = ResourceState.HELD
        resource.holder = agent_id
        resource.acquired_at = datetime.now()
        return True

    def _wait_for_resource(
        self,
        agent_id: str,
        resource: Resource,
        timeout: int
    ) -> bool:
        """Espera por el recurso."""
        start = time.time()

        while time.time() - start < timeout:
            with self._lock:
                if resource.state == ResourceState.FREE:
                    if agent_id in resource.waiters:
                        resource.waiters.remove(agent_id)
                    return self._acquire_resource(agent_id, resource)

            time.sleep(0.1)

        # Timeout - remover de waiters
        with self._lock:
            if agent_id in resource.waiters:
                resource.waiters.remove(agent_id)
            self.deadlock_detector.remove_wait(agent_id)

        return False

    def release_resource(self, agent_id: str, resource_id: str) -> bool:
        """Libera un recurso."""
        with self._lock:
            resource = self.resources.get(resource_id)
            if not resource or resource.holder != agent_id:
                return False

            resource.state = ResourceState.FREE
            resource.holder = None
            resource.acquired_at = None

            # Limpiar esperas en detector
            self.deadlock_detector.remove_wait(agent_id)

            # Notificar al siguiente waiter
            if resource.waiters:
                next_waiter = resource.waiters[0]
                self.deadlock_detector.remove_wait(next_waiter)

            return True

    def _get_held_resources(self, agent_id: str) -> List[str]:
        """Obtiene recursos poseídos por un agente."""
        return [
            r.resource_id
            for r in self.resources.values()
            if r.holder == agent_id
        ]

    def check_for_stale_locks(self) -> List[Tuple[str, str, float]]:
        """Detecta recursos retenidos por demasiado tiempo."""
        stale = []
        now = datetime.now()

        with self._lock:
            for resource in self.resources.values():
                if resource.holder and resource.acquired_at:
                    held_time = (now - resource.acquired_at).total_seconds()
                    if held_time > resource.max_hold_time:
                        stale.append((
                            resource.resource_id,
                            resource.holder,
                            held_time
                        ))

        return stale

    def force_release(self, resource_id: str, reason: str) -> bool:
        """Fuerza liberación de recurso (para recuperación)."""
        with self._lock:
            resource = self.resources.get(resource_id)
            if not resource:
                return False

            old_holder = resource.holder
            resource.state = ResourceState.FREE
            resource.holder = None
            resource.acquired_at = None

            if old_holder:
                self.deadlock_detector.remove_wait(old_holder)

            print(f"Recurso {resource_id} liberado forzosamente: {reason}")
            return True


class DeadlockPreventionError(Exception):
    """Error cuando se previene un deadlock."""
    pass


class DeadlockDetectedError(Exception):
    """Error cuando se detecta un deadlock."""
    pass


# Ejemplo de uso
if __name__ == "__main__":
    manager = ResourceManager(deadlock_strategy="detection")

    # Registrar recursos
    manager.register_resource("database", "db", max_hold_time=30)
    manager.register_resource("file_system", "fs", max_hold_time=30)
    manager.register_resource("network", "net", max_hold_time=30)

    # Simular adquisición
    manager.request_resource("agent_1", "database")
    print("Agent 1 adquirió database")

    manager.request_resource("agent_2", "file_system")
    print("Agent 2 adquirió file_system")

    # Esto podría causar deadlock si agent_1 pide file_system
    # y agent_2 pide database
    try:
        # Simular escenario de deadlock
        manager.deadlock_detector.add_wait("agent_1", "agent_2")
        manager.deadlock_detector.add_wait("agent_2", "agent_1")

        cycle = manager.deadlock_detector.detect_deadlock()
        if cycle:
            print(f"Deadlock detectado: {cycle}")
    finally:
        manager.release_resource("agent_1", "database")
        manager.release_resource("agent_2", "file_system")
```

## Resolución de Conflictos con Políticas

```python
"""
Sistema de resolución de conflictos con múltiples políticas.
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Callable
from datetime import datetime
from enum import Enum
import random


class ConflictType(Enum):
    """Tipos de conflicto."""
    RESOURCE_CONTENTION = "resource_contention"
    DATA_INCONSISTENCY = "data_inconsistency"
    GOAL_CONTRADICTION = "goal_contradiction"
    PRIORITY_CLASH = "priority_clash"
    TIMING_CONFLICT = "timing_conflict"


@dataclass
class Conflict:
    """Representa un conflicto entre agentes."""
    conflict_id: str
    conflict_type: ConflictType
    parties: List[str]
    resource_or_data: str
    description: str
    severity: int = 1  # 1-5
    detected_at: datetime = field(default_factory=datetime.now)
    context: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Resolution:
    """Resultado de una resolución de conflicto."""
    conflict_id: str
    winner: Optional[str]
    action: str
    explanation: str
    resolved_at: datetime = field(default_factory=datetime.now)
    compensation: Dict[str, Any] = field(default_factory=dict)


class ConflictResolutionPolicy(ABC):
    """Política base para resolución de conflictos."""

    @abstractmethod
    def resolve(self, conflict: Conflict, context: Dict[str, Any]) -> Resolution:
        """Resuelve el conflicto según la política."""
        pass

    @abstractmethod
    def name(self) -> str:
        """Nombre de la política."""
        pass


class PriorityBasedPolicy(ConflictResolutionPolicy):
    """Resolución basada en prioridad de agentes."""

    def __init__(self, priority_map: Dict[str, int]):
        self.priority_map = priority_map

    def name(self) -> str:
        return "priority_based"

    def resolve(self, conflict: Conflict, context: Dict[str, Any]) -> Resolution:
        # Encontrar agente con mayor prioridad
        priorities = [
            (agent, self.priority_map.get(agent, 0))
            for agent in conflict.parties
        ]
        priorities.sort(key=lambda x: x[1], reverse=True)

        winner = priorities[0][0]

        return Resolution(
            conflict_id=conflict.conflict_id,
            winner=winner,
            action="grant_to_highest_priority",
            explanation=f"Agente {winner} tiene prioridad {priorities[0][1]}"
        )


class FirstComeFirstServedPolicy(ConflictResolutionPolicy):
    """Resolución por orden de llegada."""

    def __init__(self):
        self.request_order: Dict[str, datetime] = {}

    def name(self) -> str:
        return "first_come_first_served"

    def register_request(self, agent_id: str, timestamp: datetime = None):
        """Registra timestamp de solicitud."""
        self.request_order[agent_id] = timestamp or datetime.now()

    def resolve(self, conflict: Conflict, context: Dict[str, Any]) -> Resolution:
        # Encontrar agente que solicitó primero
        earliest = None
        winner = None

        for agent in conflict.parties:
            ts = self.request_order.get(agent, datetime.now())
            if earliest is None or ts < earliest:
                earliest = ts
                winner = agent

        return Resolution(
            conflict_id=conflict.conflict_id,
            winner=winner,
            action="grant_to_first_requester",
            explanation=f"Agente {winner} solicitó primero ({earliest})"
        )


class NegotiationPolicy(ConflictResolutionPolicy):
    """Resolución mediante negociación."""

    def __init__(self, max_rounds: int = 3):
        self.max_rounds = max_rounds

    def name(self) -> str:
        return "negotiation"

    def resolve(self, conflict: Conflict, context: Dict[str, Any]) -> Resolution:
        # Simular negociación
        offers = context.get("offers", {})

        if not offers:
            # Sin ofertas, usar resolución aleatoria
            winner = random.choice(conflict.parties)
            return Resolution(
                conflict_id=conflict.conflict_id,
                winner=winner,
                action="random_selection",
                explanation="Sin ofertas de negociación, selección aleatoria"
            )

        # Evaluar ofertas
        best_offer = None
        best_value = -1

        for agent, offer in offers.items():
            value = offer.get("value", 0)
            if value > best_value:
                best_value = value
                best_offer = agent

        # Compensación al perdedor
        losers = [a for a in conflict.parties if a != best_offer]
        compensation = {
            loser: {"credit": best_value * 0.1}
            for loser in losers
        }

        return Resolution(
            conflict_id=conflict.conflict_id,
            winner=best_offer,
            action="accept_best_offer",
            explanation=f"Oferta de {best_offer} aceptada (valor: {best_value})",
            compensation=compensation
        )


class ConsensusPolicy(ConflictResolutionPolicy):
    """Resolución por consenso del grupo."""

    def name(self) -> str:
        return "consensus"

    def resolve(self, conflict: Conflict, context: Dict[str, Any]) -> Resolution:
        votes = context.get("votes", {})
        vote_counts: Dict[str, int] = {}

        # Contar votos
        for voter, voted_for in votes.items():
            vote_counts[voted_for] = vote_counts.get(voted_for, 0) + 1

        if not vote_counts:
            return Resolution(
                conflict_id=conflict.conflict_id,
                winner=None,
                action="no_consensus",
                explanation="Sin votos, no hay consenso"
            )

        # Encontrar ganador por mayoría
        max_votes = max(vote_counts.values())
        winners = [a for a, v in vote_counts.items() if v == max_votes]

        if len(winners) == 1:
            return Resolution(
                conflict_id=conflict.conflict_id,
                winner=winners[0],
                action="majority_consensus",
                explanation=f"Consenso alcanzado: {winners[0]} con {max_votes} votos"
            )
        else:
            # Empate - resolver aleatoriamente
            winner = random.choice(winners)
            return Resolution(
                conflict_id=conflict.conflict_id,
                winner=winner,
                action="tie_breaker",
                explanation=f"Empate resuelto: {winner} seleccionado entre {winners}"
            )


class ConflictResolver:
    """Resolutor de conflictos con múltiples políticas."""

    def __init__(self):
        self.policies: Dict[str, ConflictResolutionPolicy] = {}
        self.default_policy: str = "priority_based"
        self.conflict_history: List[Tuple[Conflict, Resolution]] = []
        self._policy_mapping: Dict[ConflictType, str] = {}

    def register_policy(self, policy: ConflictResolutionPolicy):
        """Registra una política de resolución."""
        self.policies[policy.name()] = policy

    def set_policy_for_type(self, conflict_type: ConflictType, policy_name: str):
        """Asigna política a tipo de conflicto."""
        if policy_name in self.policies:
            self._policy_mapping[conflict_type] = policy_name

    def resolve(
        self,
        conflict: Conflict,
        context: Dict[str, Any] = None,
        force_policy: str = None
    ) -> Resolution:
        """Resuelve un conflicto."""
        # Determinar política a usar
        policy_name = force_policy
        if not policy_name:
            policy_name = self._policy_mapping.get(
                conflict.conflict_type,
                self.default_policy
            )

        policy = self.policies.get(policy_name)
        if not policy:
            raise ValueError(f"Política no encontrada: {policy_name}")

        # Resolver
        resolution = policy.resolve(conflict, context or {})

        # Registrar en historial
        self.conflict_history.append((conflict, resolution))

        return resolution

    def get_conflict_stats(self) -> Dict[str, Any]:
        """Obtiene estadísticas de conflictos."""
        stats = {
            "total_conflicts": len(self.conflict_history),
            "by_type": {},
            "by_policy": {},
            "average_resolution_time": 0
        }

        for conflict, resolution in self.conflict_history:
            # Por tipo
            ctype = conflict.conflict_type.value
            stats["by_type"][ctype] = stats["by_type"].get(ctype, 0) + 1

        return stats


# Ejemplo de uso
if __name__ == "__main__":
    resolver = ConflictResolver()

    # Registrar políticas
    resolver.register_policy(PriorityBasedPolicy({
        "supervisor": 10,
        "worker_a": 5,
        "worker_b": 5
    }))
    resolver.register_policy(FirstComeFirstServedPolicy())
    resolver.register_policy(NegotiationPolicy())
    resolver.register_policy(ConsensusPolicy())

    # Configurar políticas por tipo
    resolver.set_policy_for_type(
        ConflictType.RESOURCE_CONTENTION,
        "priority_based"
    )
    resolver.set_policy_for_type(
        ConflictType.GOAL_CONTRADICTION,
        "consensus"
    )

    # Crear conflicto
    conflict = Conflict(
        conflict_id="c001",
        conflict_type=ConflictType.RESOURCE_CONTENTION,
        parties=["worker_a", "worker_b"],
        resource_or_data="database_connection",
        description="Ambos agentes necesitan acceso exclusivo a la base de datos"
    )

    # Resolver
    resolution = resolver.resolve(conflict)
    print(f"Resolución: {resolution}")
```

## Mecanismos de Recuperación

```python
"""
Mecanismos de recuperación tras conflictos y deadlocks.
"""
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional, Callable
from datetime import datetime
from enum import Enum
import asyncio
import json


class RecoveryStrategy(Enum):
    """Estrategias de recuperación."""
    ROLLBACK = "rollback"
    RETRY = "retry"
    COMPENSATE = "compensate"
    ESCALATE = "escalate"
    ABORT = "abort"


@dataclass
class SystemCheckpoint:
    """Punto de control del sistema."""
    checkpoint_id: str
    timestamp: datetime
    agent_states: Dict[str, Any]
    resource_states: Dict[str, Any]
    pending_operations: List[Dict[str, Any]]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "checkpoint_id": self.checkpoint_id,
            "timestamp": self.timestamp.isoformat(),
            "agent_states": self.agent_states,
            "resource_states": self.resource_states,
            "pending_operations": self.pending_operations
        }


class CheckpointManager:
    """Gestor de checkpoints para recuperación."""

    def __init__(self, max_checkpoints: int = 10):
        self.checkpoints: List[SystemCheckpoint] = []
        self.max_checkpoints = max_checkpoints
        self._checkpoint_counter = 0

    def create_checkpoint(
        self,
        agent_states: Dict[str, Any],
        resource_states: Dict[str, Any],
        pending_ops: List[Dict[str, Any]] = None
    ) -> SystemCheckpoint:
        """Crea un nuevo checkpoint."""
        self._checkpoint_counter += 1
        checkpoint = SystemCheckpoint(
            checkpoint_id=f"cp_{self._checkpoint_counter}",
            timestamp=datetime.now(),
            agent_states=agent_states.copy(),
            resource_states=resource_states.copy(),
            pending_operations=pending_ops or []
        )

        self.checkpoints.append(checkpoint)

        # Mantener límite de checkpoints
        if len(self.checkpoints) > self.max_checkpoints:
            self.checkpoints.pop(0)

        return checkpoint

    def get_latest_checkpoint(self) -> Optional[SystemCheckpoint]:
        """Obtiene el checkpoint más reciente."""
        return self.checkpoints[-1] if self.checkpoints else None

    def get_checkpoint_before(self, timestamp: datetime) -> Optional[SystemCheckpoint]:
        """Obtiene checkpoint anterior a timestamp."""
        for cp in reversed(self.checkpoints):
            if cp.timestamp < timestamp:
                return cp
        return None

    def rollback_to(self, checkpoint_id: str) -> Optional[SystemCheckpoint]:
        """Retorna al checkpoint especificado."""
        for i, cp in enumerate(self.checkpoints):
            if cp.checkpoint_id == checkpoint_id:
                # Eliminar checkpoints posteriores
                self.checkpoints = self.checkpoints[:i + 1]
                return cp
        return None


class RecoveryAction:
    """Acción de recuperación."""

    def __init__(
        self,
        action_type: str,
        target: str,
        parameters: Dict[str, Any] = None,
        compensation: Callable = None
    ):
        self.action_type = action_type
        self.target = target
        self.parameters = parameters or {}
        self.compensation = compensation
        self.executed = False
        self.result = None

    async def execute(self) -> bool:
        """Ejecuta la acción de recuperación."""
        try:
            # Lógica específica según tipo
            if self.action_type == "release_resource":
                # Liberar recurso
                self.result = {"status": "released", "target": self.target}
            elif self.action_type == "restart_agent":
                # Reiniciar agente
                self.result = {"status": "restarted", "target": self.target}
            elif self.action_type == "cancel_operation":
                # Cancelar operación
                self.result = {"status": "cancelled", "target": self.target}

            self.executed = True
            return True
        except Exception as e:
            self.result = {"status": "failed", "error": str(e)}
            return False

    async def compensate(self):
        """Ejecuta compensación si la acción falla."""
        if self.compensation:
            await self.compensation()


class RecoveryOrchestrator:
    """Orquestador de recuperación del sistema."""

    def __init__(self, checkpoint_mgr: CheckpointManager):
        self.checkpoint_mgr = checkpoint_mgr
        self.recovery_actions: List[RecoveryAction] = []
        self.recovery_log: List[Dict[str, Any]] = []

    async def recover_from_deadlock(
        self,
        deadlock_cycle: List[str],
        resource_manager: ResourceManager
    ) -> bool:
        """Recupera de un deadlock."""
        self._log_recovery_start("deadlock", {"cycle": deadlock_cycle})

        # Estrategia: Liberar el recurso del agente con menor prioridad
        # o el que lleva más tiempo esperando

        victim = self._select_deadlock_victim(deadlock_cycle)

        # Obtener recursos del victim
        held_resources = resource_manager._get_held_resources(victim)

        # Liberar recursos
        for resource_id in held_resources:
            action = RecoveryAction(
                action_type="release_resource",
                target=resource_id,
                parameters={"holder": victim, "reason": "deadlock_recovery"}
            )
            self.recovery_actions.append(action)
            await action.execute()

            resource_manager.force_release(
                resource_id,
                f"Deadlock recovery - victim: {victim}"
            )

        self._log_recovery_complete("deadlock", {
            "victim": victim,
            "resources_released": held_resources
        })

        return True

    def _select_deadlock_victim(self, cycle: List[str]) -> str:
        """Selecciona víctima para romper deadlock."""
        # Estrategia simple: seleccionar el último en el ciclo
        # En producción, usar criterios como prioridad, tiempo, costo
        return cycle[-2] if len(cycle) > 1 else cycle[0]

    async def recover_from_conflict(
        self,
        conflict: Conflict,
        strategy: RecoveryStrategy
    ) -> bool:
        """Recupera de un conflicto según estrategia."""
        self._log_recovery_start("conflict", {
            "conflict_id": conflict.conflict_id,
            "strategy": strategy.value
        })

        if strategy == RecoveryStrategy.ROLLBACK:
            return await self._rollback_recovery(conflict)
        elif strategy == RecoveryStrategy.RETRY:
            return await self._retry_recovery(conflict)
        elif strategy == RecoveryStrategy.COMPENSATE:
            return await self._compensate_recovery(conflict)
        elif strategy == RecoveryStrategy.ESCALATE:
            return await self._escalate_recovery(conflict)
        else:
            return await self._abort_recovery(conflict)

    async def _rollback_recovery(self, conflict: Conflict) -> bool:
        """Recuperación por rollback a checkpoint."""
        checkpoint = self.checkpoint_mgr.get_checkpoint_before(
            conflict.detected_at
        )

        if checkpoint:
            self.checkpoint_mgr.rollback_to(checkpoint.checkpoint_id)
            self._log_recovery_complete("conflict", {
                "action": "rollback",
                "checkpoint": checkpoint.checkpoint_id
            })
            return True

        return False

    async def _retry_recovery(self, conflict: Conflict) -> bool:
        """Recuperación por reintento."""
        max_retries = 3
        for attempt in range(max_retries):
            await asyncio.sleep(0.5 * (attempt + 1))  # Backoff exponencial

            # Simular reintento
            # En producción, reintentar la operación original

            self._log_recovery_complete("conflict", {
                "action": "retry",
                "attempts": attempt + 1
            })
            return True

        return False

    async def _compensate_recovery(self, conflict: Conflict) -> bool:
        """Recuperación por compensación."""
        # Ejecutar acciones compensatorias
        for party in conflict.parties:
            action = RecoveryAction(
                action_type="compensate",
                target=party,
                parameters={"conflict": conflict.conflict_id}
            )
            self.recovery_actions.append(action)
            await action.execute()

        self._log_recovery_complete("conflict", {"action": "compensate"})
        return True

    async def _escalate_recovery(self, conflict: Conflict) -> bool:
        """Escala el conflicto a supervisor."""
        self._log_recovery_complete("conflict", {
            "action": "escalate",
            "to": "supervisor"
        })
        # En producción, notificar a supervisor humano o sistema
        return True

    async def _abort_recovery(self, conflict: Conflict) -> bool:
        """Aborta operaciones en conflicto."""
        for party in conflict.parties:
            action = RecoveryAction(
                action_type="cancel_operation",
                target=party
            )
            self.recovery_actions.append(action)
            await action.execute()

        self._log_recovery_complete("conflict", {"action": "abort"})
        return True

    def _log_recovery_start(self, recovery_type: str, details: Dict[str, Any]):
        """Registra inicio de recuperación."""
        self.recovery_log.append({
            "event": "recovery_start",
            "type": recovery_type,
            "details": details,
            "timestamp": datetime.now().isoformat()
        })

    def _log_recovery_complete(self, recovery_type: str, result: Dict[str, Any]):
        """Registra fin de recuperación."""
        self.recovery_log.append({
            "event": "recovery_complete",
            "type": recovery_type,
            "result": result,
            "timestamp": datetime.now().isoformat()
        })


class GeminiConflictAnalyzer:
    """Analiza conflictos usando Gemini para decisiones complejas."""

    def __init__(self, api_key: str):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel("gemini-1.5-flash")

    async def analyze_conflict(
        self,
        conflict: Conflict,
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Analiza conflicto y sugiere resolución."""
        prompt = f"""Analiza este conflicto entre agentes y sugiere la mejor resolución.

Conflicto:
- Tipo: {conflict.conflict_type.value}
- Partes involucradas: {conflict.parties}
- Recurso/Dato: {conflict.resource_or_data}
- Descripción: {conflict.description}
- Severidad: {conflict.severity}/5

Contexto adicional:
{json.dumps(context, indent=2)}

Responde SOLO con JSON:
{{
    "recommended_strategy": "rollback|retry|compensate|escalate|abort",
    "winner_suggestion": "agent_id o null",
    "reasoning": "explicación",
    "risk_level": "low|medium|high",
    "additional_actions": ["acción1", "acción2"]
}}"""

        response = self.model.generate_content(prompt)

        try:
            return json.loads(response.text)
        except json.JSONDecodeError:
            return {
                "recommended_strategy": "escalate",
                "reasoning": "No se pudo analizar automáticamente",
                "risk_level": "high"
            }

    async def predict_conflict(
        self,
        pending_operations: List[Dict[str, Any]],
        resource_states: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """Predice posibles conflictos futuros."""
        prompt = f"""Analiza las operaciones pendientes y estados de recursos para predecir conflictos.

Operaciones pendientes:
{json.dumps(pending_operations, indent=2)}

Estados de recursos:
{json.dumps(resource_states, indent=2)}

Identifica posibles conflictos y responde SOLO con JSON:
{{
    "potential_conflicts": [
        {{
            "description": "descripción del conflicto",
            "probability": 0.0-1.0,
            "involved_agents": ["agent1", "agent2"],
            "prevention_suggestion": "cómo evitarlo"
        }}
    ]
}}"""

        response = self.model.generate_content(prompt)

        try:
            result = json.loads(response.text)
            return result.get("potential_conflicts", [])
        except json.JSONDecodeError:
            return []
```

## Ejercicios Prácticos

### Ejercicio 1: Implementar Timeout con Recuperación
```python
"""
Ejercicio: Agregar timeouts con recuperación automática.
"""

class TimeoutRecoveryManager:
    def __init__(self, default_timeout: int = 30):
        self.default_timeout = default_timeout
        self.pending_operations: Dict[str, Dict] = {}

    async def execute_with_timeout(
        self,
        operation: Callable,
        timeout: int = None,
        recovery_fn: Callable = None
    ) -> Any:
        """
        Ejecuta operación con timeout y recuperación.
        TODO: Implementar:
        1. Ejecutar operación con asyncio.wait_for
        2. Si timeout, ejecutar recovery_fn
        3. Registrar en pending_operations
        4. Limpiar al completar
        """
        pass
```

### Ejercicio 2: Sistema de Arbitraje
```python
"""
Ejercicio: Sistema de arbitraje para conflictos complejos.
"""

class ConflictArbiter:
    def __init__(self):
        self.arbitration_rules: List[Callable] = []
        self.arbitration_history: List[Dict] = []

    def add_rule(self, rule: Callable):
        """Agrega regla de arbitraje."""
        # TODO: Implementar

    def arbitrate(
        self,
        conflict: Conflict,
        evidence: Dict[str, Any]
    ) -> Resolution:
        """
        Arbitra conflicto aplicando reglas.
        TODO: Implementar:
        1. Recopilar evidencia de cada parte
        2. Aplicar reglas en orden
        3. Determinar veredicto
        4. Generar compensaciones
        """
        pass
```

## Resumen

| Estrategia | Cuándo Usar | Costo | Garantías |
|------------|------------|-------|-----------|
| **Prevención** | Diseño inicial | Bajo en runtime | Elimina posibilidad |
| **Detección** | Runtime | Overhead de monitoreo | Detecta ciclos |
| **Resolución por prioridad** | Recursos críticos | Bajo | Determinista |
| **Negociación** | Agentes autónomos | Medio (tiempo) | Óptimo social |
| **Rollback** | Fallos recoverable | Alto (estado) | Consistencia |
| **Compensación** | Efectos secundarios | Medio | Eventual |

---

**Siguiente:** [7.3.1 LangGraph para Grafos de Agentes](./7.3.1-langgraph.md)
