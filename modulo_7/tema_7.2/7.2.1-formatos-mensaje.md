# 7.2.1 Formatos de Mensaje Estructurados

## Objetivo de Aprendizaje

Diseñar e implementar formatos de mensaje estandarizados para comunicación eficiente y confiable entre agentes, incluyendo esquemas de validación, serialización y versionado de protocolos.

## Introducción

La comunicación entre agentes requiere formatos de mensaje bien definidos que garanticen la interoperabilidad, faciliten el debugging y permitan la evolución del sistema. Un buen diseño de mensajes es fundamental para sistemas multi-agente robustos.

```
┌─────────────────────────────────────────────────────────────┐
│                    MENSAJE ESTRUCTURADO                     │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │   HEADER    │  │   PAYLOAD   │  │  METADATA   │         │
│  ├─────────────┤  ├─────────────┤  ├─────────────┤         │
│  │ • ID        │  │ • Content   │  │ • Timestamp │         │
│  │ • Type      │  │ • Data      │  │ • Priority  │         │
│  │ • Sender    │  │ • Attachm.  │  │ • TTL       │         │
│  │ • Receiver  │  │ • Context   │  │ • Trace     │         │
│  │ • Version   │  │             │  │ • Tags      │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
│                                                             │
│  ┌───────────────────────────────────────────────────────┐ │
│  │                    SCHEMA VALIDATION                   │ │
│  │   JSON Schema → Pydantic Model → Type Safety          │ │
│  └───────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

## Implementación Base de Mensajes

```python
"""
Sistema de mensajes estructurados para comunicación multi-agente.
"""
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Optional, Any, Dict, List, Union
from enum import Enum, auto
from datetime import datetime, timedelta
import uuid
import json
from abc import ABC, abstractmethod
import hashlib


class MessageType(Enum):
    """Tipos de mensaje soportados."""
    REQUEST = "request"
    RESPONSE = "response"
    NOTIFICATION = "notification"
    BROADCAST = "broadcast"
    HEARTBEAT = "heartbeat"
    ERROR = "error"
    ACK = "acknowledgment"
    COMMAND = "command"
    QUERY = "query"
    EVENT = "event"


class MessagePriority(Enum):
    """Prioridades de mensaje."""
    LOW = 1
    NORMAL = 2
    HIGH = 3
    URGENT = 4
    CRITICAL = 5


@dataclass
class MessageHeader:
    """Cabecera del mensaje con información de enrutamiento."""
    message_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    correlation_id: Optional[str] = None
    message_type: MessageType = MessageType.REQUEST
    sender_id: str = ""
    receiver_id: str = ""
    timestamp: datetime = field(default_factory=datetime.now)
    version: str = "1.0"
    reply_to: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "message_id": self.message_id,
            "correlation_id": self.correlation_id,
            "message_type": self.message_type.value,
            "sender_id": self.sender_id,
            "receiver_id": self.receiver_id,
            "timestamp": self.timestamp.isoformat(),
            "version": self.version,
            "reply_to": self.reply_to
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MessageHeader":
        return cls(
            message_id=data.get("message_id", str(uuid.uuid4())),
            correlation_id=data.get("correlation_id"),
            message_type=MessageType(data.get("message_type", "request")),
            sender_id=data.get("sender_id", ""),
            receiver_id=data.get("receiver_id", ""),
            timestamp=datetime.fromisoformat(data.get("timestamp", datetime.now().isoformat())),
            version=data.get("version", "1.0"),
            reply_to=data.get("reply_to")
        )


@dataclass
class MessageMetadata:
    """Metadatos adicionales del mensaje."""
    priority: MessagePriority = MessagePriority.NORMAL
    ttl_seconds: Optional[int] = None
    trace_id: Optional[str] = None
    tags: List[str] = field(default_factory=list)
    retry_count: int = 0
    max_retries: int = 3
    checksum: Optional[str] = None
    content_type: str = "application/json"
    encoding: str = "utf-8"

    def to_dict(self) -> Dict[str, Any]:
        return {
            "priority": self.priority.value,
            "ttl_seconds": self.ttl_seconds,
            "trace_id": self.trace_id,
            "tags": self.tags,
            "retry_count": self.retry_count,
            "max_retries": self.max_retries,
            "checksum": self.checksum,
            "content_type": self.content_type,
            "encoding": self.encoding
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MessageMetadata":
        return cls(
            priority=MessagePriority(data.get("priority", 2)),
            ttl_seconds=data.get("ttl_seconds"),
            trace_id=data.get("trace_id"),
            tags=data.get("tags", []),
            retry_count=data.get("retry_count", 0),
            max_retries=data.get("max_retries", 3),
            checksum=data.get("checksum"),
            content_type=data.get("content_type", "application/json"),
            encoding=data.get("encoding", "utf-8")
        )

    def is_expired(self, created_at: datetime) -> bool:
        """Verifica si el mensaje ha expirado."""
        if self.ttl_seconds is None:
            return False
        expiry = created_at + timedelta(seconds=self.ttl_seconds)
        return datetime.now() > expiry


@dataclass
class MessagePayload:
    """Contenido del mensaje."""
    action: str = ""
    content: Any = None
    data: Dict[str, Any] = field(default_factory=dict)
    attachments: List[Dict[str, Any]] = field(default_factory=list)
    context: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "action": self.action,
            "content": self.content,
            "data": self.data,
            "attachments": self.attachments,
            "context": self.context
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MessagePayload":
        return cls(
            action=data.get("action", ""),
            content=data.get("content"),
            data=data.get("data", {}),
            attachments=data.get("attachments", []),
            context=data.get("context", {})
        )


@dataclass
class AgentMessage:
    """Mensaje completo para comunicación entre agentes."""
    header: MessageHeader = field(default_factory=MessageHeader)
    payload: MessagePayload = field(default_factory=MessagePayload)
    metadata: MessageMetadata = field(default_factory=MessageMetadata)

    def __post_init__(self):
        # Calcular checksum si no existe
        if self.metadata.checksum is None:
            self.metadata.checksum = self._calculate_checksum()

    def _calculate_checksum(self) -> str:
        """Calcula checksum del payload."""
        content = json.dumps(self.payload.to_dict(), sort_keys=True)
        return hashlib.sha256(content.encode()).hexdigest()[:16]

    def verify_integrity(self) -> bool:
        """Verifica la integridad del mensaje."""
        expected = self._calculate_checksum()
        # Temporalmente guardar y restaurar el checksum
        stored = self.metadata.checksum
        self.metadata.checksum = None
        actual = self._calculate_checksum()
        self.metadata.checksum = stored
        return stored == actual

    def to_dict(self) -> Dict[str, Any]:
        return {
            "header": self.header.to_dict(),
            "payload": self.payload.to_dict(),
            "metadata": self.metadata.to_dict()
        }

    def to_json(self) -> str:
        return json.dumps(self.to_dict(), indent=2, default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AgentMessage":
        return cls(
            header=MessageHeader.from_dict(data.get("header", {})),
            payload=MessagePayload.from_dict(data.get("payload", {})),
            metadata=MessageMetadata.from_dict(data.get("metadata", {}))
        )

    @classmethod
    def from_json(cls, json_str: str) -> "AgentMessage":
        return cls.from_dict(json.loads(json_str))

    def create_response(
        self,
        sender_id: str,
        content: Any = None,
        data: Dict[str, Any] = None
    ) -> "AgentMessage":
        """Crea un mensaje de respuesta."""
        return AgentMessage(
            header=MessageHeader(
                message_type=MessageType.RESPONSE,
                sender_id=sender_id,
                receiver_id=self.header.sender_id,
                correlation_id=self.header.message_id,
                reply_to=self.header.reply_to
            ),
            payload=MessagePayload(
                action=f"{self.payload.action}_response",
                content=content,
                data=data or {},
                context=self.payload.context
            ),
            metadata=MessageMetadata(
                priority=self.metadata.priority,
                trace_id=self.metadata.trace_id,
                tags=self.metadata.tags
            )
        )

    def create_error(
        self,
        sender_id: str,
        error_code: str,
        error_message: str
    ) -> "AgentMessage":
        """Crea un mensaje de error."""
        return AgentMessage(
            header=MessageHeader(
                message_type=MessageType.ERROR,
                sender_id=sender_id,
                receiver_id=self.header.sender_id,
                correlation_id=self.header.message_id
            ),
            payload=MessagePayload(
                action="error",
                content=error_message,
                data={
                    "error_code": error_code,
                    "original_action": self.payload.action
                }
            ),
            metadata=MessageMetadata(
                priority=MessagePriority.HIGH,
                trace_id=self.metadata.trace_id
            )
        )


class MessageFactory:
    """Fábrica para crear mensajes específicos."""

    @staticmethod
    def create_request(
        sender_id: str,
        receiver_id: str,
        action: str,
        content: Any = None,
        data: Dict[str, Any] = None,
        priority: MessagePriority = MessagePriority.NORMAL
    ) -> AgentMessage:
        """Crea un mensaje de solicitud."""
        return AgentMessage(
            header=MessageHeader(
                message_type=MessageType.REQUEST,
                sender_id=sender_id,
                receiver_id=receiver_id
            ),
            payload=MessagePayload(
                action=action,
                content=content,
                data=data or {}
            ),
            metadata=MessageMetadata(priority=priority)
        )

    @staticmethod
    def create_broadcast(
        sender_id: str,
        action: str,
        content: Any = None,
        tags: List[str] = None
    ) -> AgentMessage:
        """Crea un mensaje broadcast."""
        return AgentMessage(
            header=MessageHeader(
                message_type=MessageType.BROADCAST,
                sender_id=sender_id,
                receiver_id="*"
            ),
            payload=MessagePayload(
                action=action,
                content=content
            ),
            metadata=MessageMetadata(tags=tags or [])
        )

    @staticmethod
    def create_command(
        sender_id: str,
        receiver_id: str,
        command: str,
        parameters: Dict[str, Any] = None
    ) -> AgentMessage:
        """Crea un mensaje de comando."""
        return AgentMessage(
            header=MessageHeader(
                message_type=MessageType.COMMAND,
                sender_id=sender_id,
                receiver_id=receiver_id
            ),
            payload=MessagePayload(
                action=command,
                data=parameters or {}
            ),
            metadata=MessageMetadata(priority=MessagePriority.HIGH)
        )

    @staticmethod
    def create_heartbeat(agent_id: str) -> AgentMessage:
        """Crea un mensaje de heartbeat."""
        return AgentMessage(
            header=MessageHeader(
                message_type=MessageType.HEARTBEAT,
                sender_id=agent_id,
                receiver_id="system"
            ),
            payload=MessagePayload(
                action="heartbeat",
                data={"status": "alive", "timestamp": datetime.now().isoformat()}
            ),
            metadata=MessageMetadata(
                priority=MessagePriority.LOW,
                ttl_seconds=30
            )
        )


# Ejemplo de uso
if __name__ == "__main__":
    # Crear mensaje de solicitud
    request = MessageFactory.create_request(
        sender_id="agent_coordinator",
        receiver_id="agent_researcher",
        action="research_topic",
        content="Investigar sobre inteligencia artificial generativa",
        data={"depth": "comprehensive", "max_sources": 10},
        priority=MessagePriority.HIGH
    )

    print("=== Mensaje de Solicitud ===")
    print(request.to_json())

    # Crear respuesta
    response = request.create_response(
        sender_id="agent_researcher",
        content="Investigación completada",
        data={
            "findings": ["hallazgo 1", "hallazgo 2"],
            "sources_used": 8
        }
    )

    print("\n=== Mensaje de Respuesta ===")
    print(response.to_json())

    # Verificar integridad
    print(f"\n¿Integridad verificada? {response.verify_integrity()}")
```

## Esquemas de Validación con Pydantic

```python
"""
Validación de mensajes usando Pydantic para type safety.
"""
from pydantic import BaseModel, Field, validator, root_validator
from typing import Optional, Any, Dict, List, Literal, Union
from datetime import datetime
from enum import Enum
import json


class MessageTypeEnum(str, Enum):
    REQUEST = "request"
    RESPONSE = "response"
    NOTIFICATION = "notification"
    BROADCAST = "broadcast"
    ERROR = "error"
    COMMAND = "command"


class PriorityEnum(int, Enum):
    LOW = 1
    NORMAL = 2
    HIGH = 3
    URGENT = 4
    CRITICAL = 5


class ValidatedHeader(BaseModel):
    """Header validado con Pydantic."""
    message_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    correlation_id: Optional[str] = None
    message_type: MessageTypeEnum = MessageTypeEnum.REQUEST
    sender_id: str = Field(..., min_length=1, max_length=64)
    receiver_id: str = Field(..., min_length=1, max_length=64)
    timestamp: datetime = Field(default_factory=datetime.now)
    version: str = Field(default="1.0", pattern=r"^\d+\.\d+$")

    @validator("message_id")
    def validate_message_id(cls, v):
        if len(v) < 8:
            raise ValueError("message_id debe tener al menos 8 caracteres")
        return v

    class Config:
        use_enum_values = True


class ValidatedMetadata(BaseModel):
    """Metadata validada."""
    priority: PriorityEnum = PriorityEnum.NORMAL
    ttl_seconds: Optional[int] = Field(None, ge=1, le=86400)
    trace_id: Optional[str] = None
    tags: List[str] = Field(default_factory=list, max_items=20)
    retry_count: int = Field(default=0, ge=0, le=10)
    max_retries: int = Field(default=3, ge=0, le=10)

    @validator("tags", each_item=True)
    def validate_tag(cls, v):
        if len(v) > 50:
            raise ValueError("Cada tag debe tener máximo 50 caracteres")
        return v.lower()

    class Config:
        use_enum_values = True


class TaskRequestPayload(BaseModel):
    """Payload específico para solicitudes de tarea."""
    action: Literal["execute_task", "analyze", "generate", "transform"]
    task_description: str = Field(..., min_length=10, max_length=2000)
    input_data: Dict[str, Any] = Field(default_factory=dict)
    parameters: Dict[str, Any] = Field(default_factory=dict)
    expected_output_format: Optional[str] = None

    @validator("task_description")
    def clean_task_description(cls, v):
        return v.strip()


class TaskResponsePayload(BaseModel):
    """Payload específico para respuestas de tarea."""
    action: str
    success: bool
    result: Any = None
    error: Optional[str] = None
    execution_time_ms: Optional[float] = None

    @root_validator
    def check_result_or_error(cls, values):
        success = values.get("success")
        result = values.get("result")
        error = values.get("error")

        if success and result is None:
            raise ValueError("Si success=True, debe incluir result")
        if not success and error is None:
            raise ValueError("Si success=False, debe incluir error")

        return values


class QueryPayload(BaseModel):
    """Payload para consultas."""
    action: Literal["query"]
    query_type: Literal["search", "lookup", "aggregate", "filter"]
    query_string: str = Field(..., min_length=1)
    filters: Dict[str, Any] = Field(default_factory=dict)
    limit: int = Field(default=10, ge=1, le=100)
    offset: int = Field(default=0, ge=0)


class ValidatedMessage(BaseModel):
    """Mensaje completamente validado."""
    header: ValidatedHeader
    payload: Union[TaskRequestPayload, TaskResponsePayload, QueryPayload, Dict[str, Any]]
    metadata: ValidatedMetadata = Field(default_factory=ValidatedMetadata)

    @root_validator
    def validate_message_consistency(cls, values):
        header = values.get("header")
        payload = values.get("payload")

        # Validar que REQUEST tiene payload de request
        if header and header.message_type == "request":
            if isinstance(payload, TaskResponsePayload):
                raise ValueError("REQUEST no puede tener TaskResponsePayload")

        return values

    def to_agent_message(self) -> AgentMessage:
        """Convierte a AgentMessage estándar."""
        return AgentMessage(
            header=MessageHeader(
                message_id=self.header.message_id,
                correlation_id=self.header.correlation_id,
                message_type=MessageType(self.header.message_type),
                sender_id=self.header.sender_id,
                receiver_id=self.header.receiver_id,
                timestamp=self.header.timestamp,
                version=self.header.version
            ),
            payload=MessagePayload(
                action=self.payload.action if hasattr(self.payload, "action") else "",
                content=self.payload.dict() if hasattr(self.payload, "dict") else self.payload,
                data={}
            ),
            metadata=MessageMetadata(
                priority=MessagePriority(self.metadata.priority),
                ttl_seconds=self.metadata.ttl_seconds,
                trace_id=self.metadata.trace_id,
                tags=self.metadata.tags,
                retry_count=self.metadata.retry_count,
                max_retries=self.metadata.max_retries
            )
        )


class MessageValidator:
    """Validador de mensajes con soporte para múltiples esquemas."""

    def __init__(self):
        self.schemas = {}
        self._register_default_schemas()

    def _register_default_schemas(self):
        """Registra esquemas por defecto."""
        self.schemas["task_request"] = TaskRequestPayload
        self.schemas["task_response"] = TaskResponsePayload
        self.schemas["query"] = QueryPayload

    def register_schema(self, name: str, schema: type):
        """Registra un nuevo esquema."""
        self.schemas[name] = schema

    def validate(
        self,
        message_data: Dict[str, Any],
        payload_schema: Optional[str] = None
    ) -> ValidatedMessage:
        """Valida un mensaje completo."""
        # Determinar esquema de payload
        if payload_schema and payload_schema in self.schemas:
            PayloadClass = self.schemas[payload_schema]
            payload_data = message_data.get("payload", {})
            validated_payload = PayloadClass(**payload_data)
            message_data["payload"] = validated_payload

        return ValidatedMessage(**message_data)

    def validate_header(self, header_data: Dict[str, Any]) -> ValidatedHeader:
        """Valida solo el header."""
        return ValidatedHeader(**header_data)

    def validate_metadata(self, metadata_data: Dict[str, Any]) -> ValidatedMetadata:
        """Valida solo metadata."""
        return ValidatedMetadata(**metadata_data)


# Ejemplo de uso
if __name__ == "__main__":
    validator = MessageValidator()

    # Mensaje válido
    valid_message = {
        "header": {
            "sender_id": "coordinator",
            "receiver_id": "worker_1",
            "message_type": "request"
        },
        "payload": {
            "action": "execute_task",
            "task_description": "Analizar el documento y extraer información clave",
            "input_data": {"document_id": "doc_123"},
            "parameters": {"detail_level": "high"}
        },
        "metadata": {
            "priority": 3,
            "tags": ["analysis", "extraction"]
        }
    }

    try:
        validated = validator.validate(valid_message, "task_request")
        print("Mensaje válido:")
        print(validated.json(indent=2))
    except Exception as e:
        print(f"Error de validación: {e}")

    # Mensaje inválido
    invalid_message = {
        "header": {
            "sender_id": "",  # Vacío - inválido
            "receiver_id": "worker_1"
        },
        "payload": {
            "action": "invalid_action",  # No está en literal
            "task_description": "corto"  # Muy corto
        }
    }

    try:
        validated = validator.validate(invalid_message, "task_request")
    except Exception as e:
        print(f"\nError esperado de validación: {e}")
```

## Protocolo de Mensajes con Versionado

```python
"""
Sistema de versionado de protocolos de mensajes.
"""
from abc import ABC, abstractmethod
from typing import Dict, Any, Type, Optional, Callable
from dataclasses import dataclass
import semver


@dataclass
class ProtocolVersion:
    """Versión de protocolo semántico."""
    major: int
    minor: int
    patch: int

    def __str__(self) -> str:
        return f"{self.major}.{self.minor}.{self.patch}"

    @classmethod
    def parse(cls, version_str: str) -> "ProtocolVersion":
        parts = version_str.split(".")
        return cls(
            major=int(parts[0]),
            minor=int(parts[1]) if len(parts) > 1 else 0,
            patch=int(parts[2]) if len(parts) > 2 else 0
        )

    def is_compatible_with(self, other: "ProtocolVersion") -> bool:
        """Verifica compatibilidad (mismo major version)."""
        return self.major == other.major

    def __lt__(self, other: "ProtocolVersion") -> bool:
        return (self.major, self.minor, self.patch) < (other.major, other.minor, other.patch)


class MessageTransformer(ABC):
    """Transformador de mensajes entre versiones."""

    @abstractmethod
    def upgrade(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """Actualiza mensaje a versión más nueva."""
        pass

    @abstractmethod
    def downgrade(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """Degrada mensaje a versión anterior."""
        pass


class V1ToV2Transformer(MessageTransformer):
    """Transforma mensajes de v1 a v2."""

    def upgrade(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """Actualiza de v1 a v2."""
        upgraded = message.copy()

        # En v2, separamos content en structured_content
        if "payload" in upgraded:
            payload = upgraded["payload"]
            if "content" in payload and isinstance(payload["content"], str):
                payload["structured_content"] = {
                    "text": payload["content"],
                    "format": "plain"
                }

            # Nuevo campo en v2
            if "context" not in payload:
                payload["context"] = {}

        # Actualizar versión
        if "header" in upgraded:
            upgraded["header"]["version"] = "2.0"

        return upgraded

    def downgrade(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """Degrada de v2 a v1."""
        downgraded = message.copy()

        # Convertir structured_content a content simple
        if "payload" in downgraded:
            payload = downgraded["payload"]
            if "structured_content" in payload:
                sc = payload["structured_content"]
                payload["content"] = sc.get("text", str(sc))
                del payload["structured_content"]

        # Actualizar versión
        if "header" in downgraded:
            downgraded["header"]["version"] = "1.0"

        return downgraded


class VersionedProtocolManager:
    """Gestor de protocolos versionados."""

    def __init__(self, current_version: str = "2.0.0"):
        self.current_version = ProtocolVersion.parse(current_version)
        self.transformers: Dict[str, MessageTransformer] = {}
        self.supported_versions: List[ProtocolVersion] = []

        # Registrar transformadores por defecto
        self._register_default_transformers()

    def _register_default_transformers(self):
        """Registra transformadores por defecto."""
        self.register_transformer("1.0->2.0", V1ToV2Transformer())
        self.supported_versions = [
            ProtocolVersion.parse("1.0.0"),
            ProtocolVersion.parse("2.0.0")
        ]

    def register_transformer(self, transition: str, transformer: MessageTransformer):
        """Registra un transformador de versiones."""
        self.transformers[transition] = transformer

    def get_message_version(self, message: Dict[str, Any]) -> ProtocolVersion:
        """Obtiene la versión de un mensaje."""
        version_str = message.get("header", {}).get("version", "1.0")
        return ProtocolVersion.parse(version_str)

    def ensure_compatibility(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """Asegura que el mensaje sea compatible con la versión actual."""
        msg_version = self.get_message_version(message)

        if msg_version.is_compatible_with(self.current_version):
            # Aplicar transformaciones incrementales si es necesario
            return self._upgrade_to_current(message, msg_version)
        else:
            raise ValueError(
                f"Versión {msg_version} incompatible con {self.current_version}"
            )

    def _upgrade_to_current(
        self,
        message: Dict[str, Any],
        from_version: ProtocolVersion
    ) -> Dict[str, Any]:
        """Actualiza mensaje a versión actual."""
        result = message.copy()

        # Encontrar camino de actualización
        upgrade_path = self._find_upgrade_path(from_version, self.current_version)

        for transition in upgrade_path:
            if transition in self.transformers:
                result = self.transformers[transition].upgrade(result)

        return result

    def _find_upgrade_path(
        self,
        from_version: ProtocolVersion,
        to_version: ProtocolVersion
    ) -> List[str]:
        """Encuentra camino de actualización entre versiones."""
        path = []

        # Simplificación: asumimos actualizaciones de major.0 a major.0
        current_major = from_version.major
        target_major = to_version.major

        while current_major < target_major:
            transition = f"{current_major}.0->{current_major + 1}.0"
            path.append(transition)
            current_major += 1

        return path

    def downgrade_for_agent(
        self,
        message: Dict[str, Any],
        agent_version: str
    ) -> Dict[str, Any]:
        """Degrada mensaje para agente con versión específica."""
        target_version = ProtocolVersion.parse(agent_version)
        msg_version = self.get_message_version(message)

        if msg_version <= target_version:
            return message

        result = message.copy()

        # Degradar paso a paso
        current_major = msg_version.major
        target_major = target_version.major

        while current_major > target_major:
            transition = f"{current_major - 1}.0->{current_major}.0"
            if transition in self.transformers:
                result = self.transformers[transition].downgrade(result)
            current_major -= 1

        return result


class MessageSerializer:
    """Serializador de mensajes con soporte multi-formato."""

    def __init__(self):
        self.serializers: Dict[str, Callable] = {
            "json": self._to_json,
            "msgpack": self._to_msgpack,
            "protobuf": self._to_protobuf
        }
        self.deserializers: Dict[str, Callable] = {
            "json": self._from_json,
            "msgpack": self._from_msgpack,
            "protobuf": self._from_protobuf
        }

    def serialize(self, message: AgentMessage, format: str = "json") -> bytes:
        """Serializa mensaje al formato especificado."""
        if format not in self.serializers:
            raise ValueError(f"Formato no soportado: {format}")
        return self.serializers[format](message)

    def deserialize(self, data: bytes, format: str = "json") -> AgentMessage:
        """Deserializa mensaje desde bytes."""
        if format not in self.deserializers:
            raise ValueError(f"Formato no soportado: {format}")
        return self.deserializers[format](data)

    def _to_json(self, message: AgentMessage) -> bytes:
        return message.to_json().encode("utf-8")

    def _from_json(self, data: bytes) -> AgentMessage:
        return AgentMessage.from_json(data.decode("utf-8"))

    def _to_msgpack(self, message: AgentMessage) -> bytes:
        try:
            import msgpack
            return msgpack.packb(message.to_dict(), default=str)
        except ImportError:
            raise ImportError("Instala msgpack: pip install msgpack")

    def _from_msgpack(self, data: bytes) -> AgentMessage:
        import msgpack
        return AgentMessage.from_dict(msgpack.unpackb(data, raw=False))

    def _to_protobuf(self, message: AgentMessage) -> bytes:
        # Placeholder - requiere definición de .proto
        raise NotImplementedError("Protobuf requiere definición de esquema")

    def _from_protobuf(self, data: bytes) -> AgentMessage:
        raise NotImplementedError("Protobuf requiere definición de esquema")


# Ejemplo de uso
if __name__ == "__main__":
    # Gestor de versiones
    protocol_mgr = VersionedProtocolManager("2.0.0")

    # Mensaje v1
    v1_message = {
        "header": {
            "message_id": "msg_001",
            "sender_id": "agent_a",
            "receiver_id": "agent_b",
            "version": "1.0"
        },
        "payload": {
            "action": "process",
            "content": "Datos a procesar"
        },
        "metadata": {}
    }

    print("=== Mensaje Original (v1) ===")
    print(json.dumps(v1_message, indent=2))

    # Actualizar a v2
    v2_message = protocol_mgr.ensure_compatibility(v1_message)
    print("\n=== Mensaje Actualizado (v2) ===")
    print(json.dumps(v2_message, indent=2))

    # Degradar para agente legacy
    downgraded = protocol_mgr.downgrade_for_agent(v2_message, "1.0.0")
    print("\n=== Mensaje Degradado (v1) ===")
    print(json.dumps(downgraded, indent=2))
```

## Integración con Gemini para Generación de Mensajes

```python
"""
Generación inteligente de mensajes usando Gemini.
"""
import google.generativeai as genai
from typing import List, Dict, Any, Optional
import json


class GeminiMessageGenerator:
    """Genera y procesa mensajes estructurados con Gemini."""

    def __init__(self, api_key: str):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel("gemini-1.5-flash")

    def generate_task_message(
        self,
        task_description: str,
        sender_id: str,
        receiver_id: str,
        context: Dict[str, Any] = None
    ) -> AgentMessage:
        """Genera un mensaje de tarea estructurado."""
        prompt = f"""Genera un mensaje estructurado para la siguiente tarea.

Descripción de tarea: {task_description}

Contexto adicional: {json.dumps(context or {}, indent=2)}

Responde SOLO con JSON válido en este formato exacto:
{{
    "action": "nombre_de_la_accion",
    "parameters": {{"param1": "valor1", "param2": "valor2"}},
    "expected_output": "descripción del output esperado",
    "priority_suggestion": "normal|high|urgent"
}}"""

        response = self.model.generate_content(prompt)

        try:
            parsed = json.loads(response.text)

            priority_map = {
                "low": MessagePriority.LOW,
                "normal": MessagePriority.NORMAL,
                "high": MessagePriority.HIGH,
                "urgent": MessagePriority.URGENT
            }

            return AgentMessage(
                header=MessageHeader(
                    message_type=MessageType.REQUEST,
                    sender_id=sender_id,
                    receiver_id=receiver_id
                ),
                payload=MessagePayload(
                    action=parsed.get("action", "execute"),
                    content=task_description,
                    data=parsed.get("parameters", {}),
                    context={"expected_output": parsed.get("expected_output")}
                ),
                metadata=MessageMetadata(
                    priority=priority_map.get(
                        parsed.get("priority_suggestion", "normal"),
                        MessagePriority.NORMAL
                    )
                )
            )
        except json.JSONDecodeError:
            # Fallback si la respuesta no es JSON válido
            return MessageFactory.create_request(
                sender_id=sender_id,
                receiver_id=receiver_id,
                action="execute_task",
                content=task_description
            )

    def interpret_natural_language_request(
        self,
        natural_request: str
    ) -> Dict[str, Any]:
        """Interpreta solicitud en lenguaje natural a estructura de mensaje."""
        prompt = f"""Analiza esta solicitud en lenguaje natural y extrae los componentes del mensaje.

Solicitud: "{natural_request}"

Extrae y responde SOLO con JSON:
{{
    "intended_action": "acción principal identificada",
    "target_agent_type": "tipo de agente más apropiado",
    "parameters": {{"parametros": "extraídos"}},
    "priority": "low|normal|high|urgent",
    "requires_response": true/false,
    "confidence": 0.0-1.0
}}"""

        response = self.model.generate_content(prompt)

        try:
            return json.loads(response.text)
        except json.JSONDecodeError:
            return {
                "intended_action": "process_request",
                "target_agent_type": "general",
                "parameters": {"raw_request": natural_request},
                "priority": "normal",
                "requires_response": True,
                "confidence": 0.5
            }

    def validate_message_content(
        self,
        message: AgentMessage
    ) -> Dict[str, Any]:
        """Valida el contenido semántico del mensaje."""
        prompt = f"""Analiza este mensaje de agente y verifica su calidad.

Mensaje:
{message.to_json()}

Evalúa y responde SOLO con JSON:
{{
    "is_well_formed": true/false,
    "action_is_clear": true/false,
    "has_sufficient_context": true/false,
    "potential_issues": ["issue1", "issue2"],
    "suggestions": ["mejora1", "mejora2"],
    "overall_quality_score": 0.0-1.0
}}"""

        response = self.model.generate_content(prompt)

        try:
            return json.loads(response.text)
        except json.JSONDecodeError:
            return {"is_well_formed": True, "overall_quality_score": 0.7}

    def generate_response_template(
        self,
        request_message: AgentMessage,
        available_capabilities: List[str]
    ) -> AgentMessage:
        """Genera template de respuesta basado en solicitud."""
        prompt = f"""Dado este mensaje de solicitud y las capacidades disponibles,
genera una estructura de respuesta apropiada.

Solicitud:
{request_message.to_json()}

Capacidades disponibles: {available_capabilities}

Responde SOLO con JSON de la respuesta estructurada:
{{
    "action": "nombre_accion_respuesta",
    "suggested_approach": "descripción del approach",
    "required_data_fields": ["campo1", "campo2"],
    "estimated_complexity": "low|medium|high"
}}"""

        response = self.model.generate_content(prompt)

        try:
            parsed = json.loads(response.text)

            return request_message.create_response(
                sender_id="responder",
                content=parsed.get("suggested_approach"),
                data={
                    "required_fields": parsed.get("required_data_fields", []),
                    "complexity": parsed.get("estimated_complexity", "medium")
                }
            )
        except json.JSONDecodeError:
            return request_message.create_response(
                sender_id="responder",
                content="Respuesta pendiente de procesamiento"
            )


# Ejemplo de uso
if __name__ == "__main__":
    import os

    generator = GeminiMessageGenerator(os.getenv("GEMINI_API_KEY"))

    # Generar mensaje desde descripción
    task_msg = generator.generate_task_message(
        task_description="Analizar el sentimiento de las últimas 100 reseñas de clientes y generar un informe ejecutivo",
        sender_id="manager_agent",
        receiver_id="analyst_agent",
        context={"urgency": "alta", "format": "pdf"}
    )

    print("=== Mensaje Generado ===")
    print(task_msg.to_json())

    # Interpretar solicitud natural
    interpretation = generator.interpret_natural_language_request(
        "Necesito que alguien investigue las últimas tendencias en IA y me prepare una presentación para mañana"
    )

    print("\n=== Interpretación ===")
    print(json.dumps(interpretation, indent=2))
```

## Ejercicios Prácticos

### Ejercicio 1: Mensaje de Workflow
Implementa un formato de mensaje específico para coordinar un workflow multi-paso:

```python
"""
Ejercicio: Implementar mensaje de workflow.
"""

@dataclass
class WorkflowStep:
    step_id: str
    action: str
    dependencies: List[str]
    status: str = "pending"
    result: Any = None


@dataclass
class WorkflowMessagePayload(MessagePayload):
    workflow_id: str = ""
    steps: List[WorkflowStep] = field(default_factory=list)
    current_step: int = 0

    # TODO: Implementar métodos para:
    # 1. Agregar pasos al workflow
    # 2. Marcar paso como completado
    # 3. Obtener siguiente paso ejecutable
    # 4. Verificar si workflow está completo
```

### Ejercicio 2: Validador Custom
Crea un validador de mensajes específico para tu dominio:

```python
"""
Ejercicio: Validador de dominio específico.
"""

class DomainMessageValidator:
    def __init__(self, domain: str):
        self.domain = domain
        self.rules = []

    def add_rule(self, rule_name: str, validator_fn: Callable):
        """Agrega regla de validación."""
        # TODO: Implementar
        pass

    def validate(self, message: AgentMessage) -> Dict[str, Any]:
        """Ejecuta todas las validaciones."""
        # TODO: Implementar
        # Retornar: {"valid": bool, "errors": [], "warnings": []}
        pass
```

## Resumen

| Componente | Propósito | Campos Clave |
|------------|-----------|--------------|
| **MessageHeader** | Enrutamiento y correlación | ID, tipo, sender, receiver, version |
| **MessagePayload** | Contenido del mensaje | action, content, data, context |
| **MessageMetadata** | Control y trazabilidad | priority, TTL, trace_id, checksum |
| **MessageFactory** | Creación estandarizada | request, broadcast, command, heartbeat |
| **MessageValidator** | Validación con Pydantic | Esquemas tipados, reglas custom |
| **VersionedProtocol** | Compatibilidad entre versiones | Transformers, upgrade/downgrade |

---

**Siguiente:** [7.2.2 Memoria Compartida vs Paso de Mensajes](./7.2.2-memoria-compartida-mensajes.md)
