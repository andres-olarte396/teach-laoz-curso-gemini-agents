# 7.2.2 Memoria Compartida vs Paso de Mensajes

## Objetivo de Aprendizaje

Implementar y comparar los dos paradigmas fundamentales de comunicación entre agentes: memoria compartida centralizada y paso de mensajes distribuido, seleccionando el enfoque óptimo según los requisitos del sistema.

## Introducción

Los sistemas multi-agente pueden comunicarse de dos formas principales: compartiendo un espacio de memoria común o enviándose mensajes directamente. Cada enfoque tiene ventajas y desventajas que determinan su idoneidad para diferentes escenarios.

```
┌─────────────────────────────────────────────────────────────────┐
│           PARADIGMAS DE COMUNICACIÓN INTER-AGENTE               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  MEMORIA COMPARTIDA                    PASO DE MENSAJES         │
│  ┌─────────────────┐                   ┌─────┐    ┌─────┐      │
│  │  SHARED MEMORY  │                   │ A1  │───>│ A2  │      │
│  │  ┌───┬───┬───┐  │                   └──┬──┘    └──┬──┘      │
│  │  │ A │ B │ C │  │                      │          │         │
│  │  └───┴───┴───┘  │                      v          v         │
│  │       ▲ ▲ ▲     │                   ┌─────┐    ┌─────┐      │
│  │       │ │ │     │                   │ A3  │<───│ A4  │      │
│  │    ┌──┘ │ └──┐  │                   └─────┘    └─────┘      │
│  │ ┌──┴─┐┌─┴─┐┌─┴──┐│                                          │
│  │ │ A1 ││A2 ││ A3 ││                   Punto a punto          │
│  │ └────┘└───┘└────┘│                   Asíncrono              │
│  └─────────────────┘                    Desacoplado            │
│   Centralizada                                                 │
│   Síncrona                                                     │
│   Acoplada                                                     │
└─────────────────────────────────────────────────────────────────┘
```

## Implementación de Memoria Compartida

```python
"""
Sistema de memoria compartida para agentes.
"""
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set, Callable
from datetime import datetime
import threading
import json
from abc import ABC, abstractmethod
from enum import Enum
import hashlib
import time


class MemoryAccessMode(Enum):
    """Modos de acceso a memoria."""
    READ = "read"
    WRITE = "write"
    READ_WRITE = "read_write"
    EXCLUSIVE = "exclusive"


@dataclass
class MemoryEntry:
    """Entrada en memoria compartida."""
    key: str
    value: Any
    owner: str
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    version: int = 1
    ttl_seconds: Optional[int] = None
    access_count: int = 0
    tags: List[str] = field(default_factory=list)

    def is_expired(self) -> bool:
        if self.ttl_seconds is None:
            return False
        elapsed = (datetime.now() - self.created_at).total_seconds()
        return elapsed > self.ttl_seconds

    def to_dict(self) -> Dict[str, Any]:
        return {
            "key": self.key,
            "value": self.value,
            "owner": self.owner,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "version": self.version,
            "access_count": self.access_count,
            "tags": self.tags
        }


class SharedMemory:
    """Memoria compartida thread-safe para agentes."""

    def __init__(self, name: str = "default"):
        self.name = name
        self._storage: Dict[str, MemoryEntry] = {}
        self._lock = threading.RLock()
        self._subscribers: Dict[str, List[Callable]] = {}
        self._access_log: List[Dict[str, Any]] = []

    def write(
        self,
        key: str,
        value: Any,
        owner: str,
        ttl_seconds: Optional[int] = None,
        tags: List[str] = None
    ) -> bool:
        """Escribe un valor en memoria compartida."""
        with self._lock:
            existing = self._storage.get(key)

            entry = MemoryEntry(
                key=key,
                value=value,
                owner=owner,
                ttl_seconds=ttl_seconds,
                tags=tags or [],
                version=existing.version + 1 if existing else 1
            )

            self._storage[key] = entry
            self._log_access("write", key, owner)
            self._notify_subscribers(key, "write", value)

            return True

    def read(self, key: str, reader: str) -> Optional[Any]:
        """Lee un valor de memoria compartida."""
        with self._lock:
            entry = self._storage.get(key)

            if entry is None:
                return None

            if entry.is_expired():
                del self._storage[key]
                return None

            entry.access_count += 1
            self._log_access("read", key, reader)

            return entry.value

    def read_with_metadata(self, key: str, reader: str) -> Optional[MemoryEntry]:
        """Lee valor con metadatos."""
        with self._lock:
            entry = self._storage.get(key)

            if entry is None or entry.is_expired():
                return None

            entry.access_count += 1
            self._log_access("read", key, reader)

            return entry

    def delete(self, key: str, requester: str) -> bool:
        """Elimina entrada de memoria."""
        with self._lock:
            if key in self._storage:
                del self._storage[key]
                self._log_access("delete", key, requester)
                self._notify_subscribers(key, "delete", None)
                return True
            return False

    def update(
        self,
        key: str,
        value: Any,
        updater: str,
        expected_version: Optional[int] = None
    ) -> bool:
        """Actualiza valor con control de versión optimista."""
        with self._lock:
            entry = self._storage.get(key)

            if entry is None:
                return False

            # Control de versión optimista
            if expected_version is not None and entry.version != expected_version:
                raise ValueError(
                    f"Version mismatch: expected {expected_version}, got {entry.version}"
                )

            entry.value = value
            entry.version += 1
            entry.updated_at = datetime.now()

            self._log_access("update", key, updater)
            self._notify_subscribers(key, "update", value)

            return True

    def compare_and_swap(
        self,
        key: str,
        expected_value: Any,
        new_value: Any,
        requester: str
    ) -> bool:
        """Operación atómica compare-and-swap."""
        with self._lock:
            entry = self._storage.get(key)

            if entry is None:
                return False

            if entry.value != expected_value:
                return False

            entry.value = new_value
            entry.version += 1
            entry.updated_at = datetime.now()

            self._log_access("cas", key, requester)
            self._notify_subscribers(key, "update", new_value)

            return True

    def list_keys(self, pattern: str = None, tags: List[str] = None) -> List[str]:
        """Lista claves que coinciden con patrón o tags."""
        with self._lock:
            keys = []
            for key, entry in self._storage.items():
                if entry.is_expired():
                    continue

                if pattern and pattern not in key:
                    continue

                if tags:
                    if not any(tag in entry.tags for tag in tags):
                        continue

                keys.append(key)

            return keys

    def subscribe(self, key_pattern: str, callback: Callable):
        """Suscribe a cambios en claves."""
        if key_pattern not in self._subscribers:
            self._subscribers[key_pattern] = []
        self._subscribers[key_pattern].append(callback)

    def unsubscribe(self, key_pattern: str, callback: Callable):
        """Cancela suscripción."""
        if key_pattern in self._subscribers:
            self._subscribers[key_pattern].remove(callback)

    def _notify_subscribers(self, key: str, event: str, value: Any):
        """Notifica a suscriptores."""
        for pattern, callbacks in self._subscribers.items():
            if pattern == "*" or pattern in key:
                for callback in callbacks:
                    try:
                        callback(key, event, value)
                    except Exception as e:
                        print(f"Error en subscriber: {e}")

    def _log_access(self, operation: str, key: str, agent: str):
        """Registra acceso a memoria."""
        self._access_log.append({
            "operation": operation,
            "key": key,
            "agent": agent,
            "timestamp": datetime.now().isoformat()
        })

        # Limitar tamaño del log
        if len(self._access_log) > 1000:
            self._access_log = self._access_log[-500:]

    def get_stats(self) -> Dict[str, Any]:
        """Obtiene estadísticas de la memoria."""
        with self._lock:
            return {
                "total_entries": len(self._storage),
                "access_log_size": len(self._access_log),
                "subscribers": len(self._subscribers),
                "entries_by_owner": self._count_by_owner()
            }

    def _count_by_owner(self) -> Dict[str, int]:
        counts = {}
        for entry in self._storage.values():
            counts[entry.owner] = counts.get(entry.owner, 0) + 1
        return counts

    def snapshot(self) -> Dict[str, Any]:
        """Crea snapshot de la memoria."""
        with self._lock:
            return {
                key: entry.to_dict()
                for key, entry in self._storage.items()
                if not entry.is_expired()
            }


class MemoryRegion:
    """Región de memoria con permisos por agente."""

    def __init__(self, name: str, shared_memory: SharedMemory):
        self.name = name
        self.memory = shared_memory
        self.permissions: Dict[str, MemoryAccessMode] = {}
        self._prefix = f"region:{name}:"

    def grant_access(self, agent_id: str, mode: MemoryAccessMode):
        """Otorga acceso a un agente."""
        self.permissions[agent_id] = mode

    def revoke_access(self, agent_id: str):
        """Revoca acceso de un agente."""
        if agent_id in self.permissions:
            del self.permissions[agent_id]

    def _check_permission(self, agent_id: str, required: MemoryAccessMode) -> bool:
        """Verifica permiso del agente."""
        if agent_id not in self.permissions:
            return False

        agent_mode = self.permissions[agent_id]

        if agent_mode == MemoryAccessMode.EXCLUSIVE:
            return True
        if agent_mode == MemoryAccessMode.READ_WRITE:
            return True
        if agent_mode == MemoryAccessMode.READ and required == MemoryAccessMode.READ:
            return True
        if agent_mode == MemoryAccessMode.WRITE and required == MemoryAccessMode.WRITE:
            return True

        return False

    def write(self, key: str, value: Any, agent_id: str, **kwargs) -> bool:
        """Escribe en la región (si tiene permiso)."""
        if not self._check_permission(agent_id, MemoryAccessMode.WRITE):
            raise PermissionError(f"Agent {agent_id} no tiene permiso de escritura")

        full_key = f"{self._prefix}{key}"
        return self.memory.write(full_key, value, agent_id, **kwargs)

    def read(self, key: str, agent_id: str) -> Optional[Any]:
        """Lee de la región (si tiene permiso)."""
        if not self._check_permission(agent_id, MemoryAccessMode.READ):
            raise PermissionError(f"Agent {agent_id} no tiene permiso de lectura")

        full_key = f"{self._prefix}{key}"
        return self.memory.read(full_key, agent_id)


# Ejemplo de uso con agentes
class MemoryAwareAgent:
    """Agente que usa memoria compartida."""

    def __init__(self, agent_id: str, memory: SharedMemory):
        self.agent_id = agent_id
        self.memory = memory
        self._workspace_key = f"agent:{agent_id}:workspace"

    def save_state(self, state: Dict[str, Any]):
        """Guarda estado en memoria compartida."""
        self.memory.write(
            key=self._workspace_key,
            value=state,
            owner=self.agent_id,
            tags=["agent_state"]
        )

    def load_state(self) -> Optional[Dict[str, Any]]:
        """Carga estado desde memoria compartida."""
        return self.memory.read(self._workspace_key, self.agent_id)

    def share_result(self, key: str, result: Any):
        """Comparte resultado para otros agentes."""
        self.memory.write(
            key=f"shared:{key}",
            value={
                "result": result,
                "producer": self.agent_id,
                "timestamp": datetime.now().isoformat()
            },
            owner=self.agent_id,
            tags=["shared_result"]
        )

    def get_shared_result(self, key: str) -> Optional[Any]:
        """Obtiene resultado compartido."""
        data = self.memory.read(f"shared:{key}", self.agent_id)
        return data.get("result") if data else None


# Ejemplo de uso
if __name__ == "__main__":
    # Crear memoria compartida
    memory = SharedMemory("main")

    # Crear agentes
    agent_a = MemoryAwareAgent("agent_a", memory)
    agent_b = MemoryAwareAgent("agent_b", memory)

    # Agente A comparte resultado
    agent_a.share_result("analysis_result", {
        "sentiment": "positive",
        "confidence": 0.92
    })

    # Agente B lee resultado
    result = agent_b.get_shared_result("analysis_result")
    print(f"Agent B obtuvo: {result}")

    # Estadísticas
    print(f"\nEstadísticas: {memory.get_stats()}")
```

## Implementación de Paso de Mensajes

```python
"""
Sistema de paso de mensajes para comunicación entre agentes.
"""
import asyncio
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Callable, Any, Awaitable
from datetime import datetime
from collections import defaultdict
from enum import Enum
import uuid
import json


class DeliveryMode(Enum):
    """Modos de entrega de mensajes."""
    AT_MOST_ONCE = "at_most_once"
    AT_LEAST_ONCE = "at_least_once"
    EXACTLY_ONCE = "exactly_once"


@dataclass
class Message:
    """Mensaje para paso entre agentes."""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    sender: str = ""
    receiver: str = ""
    content: Any = None
    timestamp: datetime = field(default_factory=datetime.now)
    reply_to: Optional[str] = None
    correlation_id: Optional[str] = None
    delivery_mode: DeliveryMode = DeliveryMode.AT_LEAST_ONCE

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "sender": self.sender,
            "receiver": self.receiver,
            "content": self.content,
            "timestamp": self.timestamp.isoformat(),
            "reply_to": self.reply_to,
            "correlation_id": self.correlation_id,
            "delivery_mode": self.delivery_mode.value
        }


class MessageQueue:
    """Cola de mensajes para un agente."""

    def __init__(self, agent_id: str, max_size: int = 1000):
        self.agent_id = agent_id
        self.max_size = max_size
        self._queue: asyncio.Queue = asyncio.Queue(maxsize=max_size)
        self._pending_acks: Dict[str, Message] = {}
        self._processed: set = set()

    async def enqueue(self, message: Message) -> bool:
        """Encola un mensaje."""
        if self._queue.full():
            return False

        # Para exactly_once, verificar si ya fue procesado
        if message.delivery_mode == DeliveryMode.EXACTLY_ONCE:
            if message.id in self._processed:
                return True  # Ya procesado, ignorar

        await self._queue.put(message)

        # Para at_least_once, guardar para posible reenvío
        if message.delivery_mode in [DeliveryMode.AT_LEAST_ONCE, DeliveryMode.EXACTLY_ONCE]:
            self._pending_acks[message.id] = message

        return True

    async def dequeue(self, timeout: float = None) -> Optional[Message]:
        """Desencola un mensaje."""
        try:
            if timeout:
                message = await asyncio.wait_for(
                    self._queue.get(),
                    timeout=timeout
                )
            else:
                message = await self._queue.get()
            return message
        except asyncio.TimeoutError:
            return None

    def acknowledge(self, message_id: str):
        """Confirma procesamiento de mensaje."""
        if message_id in self._pending_acks:
            del self._pending_acks[message_id]
        self._processed.add(message_id)

        # Limitar tamaño de procesados
        if len(self._processed) > 10000:
            self._processed = set(list(self._processed)[-5000:])

    def get_pending_count(self) -> int:
        """Retorna cantidad de mensajes pendientes de ACK."""
        return len(self._pending_acks)

    @property
    def size(self) -> int:
        return self._queue.qsize()


class MessageBroker:
    """Broker centralizado para paso de mensajes."""

    def __init__(self):
        self._queues: Dict[str, MessageQueue] = {}
        self._handlers: Dict[str, Callable] = {}
        self._topics: Dict[str, List[str]] = defaultdict(list)
        self._message_log: List[Dict] = []
        self._running = False

    def register_agent(self, agent_id: str, max_queue_size: int = 1000):
        """Registra un agente en el broker."""
        if agent_id not in self._queues:
            self._queues[agent_id] = MessageQueue(agent_id, max_queue_size)

    def unregister_agent(self, agent_id: str):
        """Des-registra un agente."""
        if agent_id in self._queues:
            del self._queues[agent_id]

        # Remover de suscripciones
        for subscribers in self._topics.values():
            if agent_id in subscribers:
                subscribers.remove(agent_id)

    def subscribe(self, agent_id: str, topic: str):
        """Suscribe agente a un topic."""
        if agent_id not in self._topics[topic]:
            self._topics[topic].append(agent_id)

    def unsubscribe(self, agent_id: str, topic: str):
        """Des-suscribe agente de topic."""
        if topic in self._topics and agent_id in self._topics[topic]:
            self._topics[topic].remove(agent_id)

    async def send(self, message: Message) -> bool:
        """Envía mensaje a un agente específico."""
        if message.receiver not in self._queues:
            self._log_message(message, "undeliverable")
            return False

        queue = self._queues[message.receiver]
        success = await queue.enqueue(message)

        self._log_message(message, "delivered" if success else "queue_full")
        return success

    async def publish(self, topic: str, message: Message) -> int:
        """Publica mensaje a un topic."""
        subscribers = self._topics.get(topic, [])
        delivered = 0

        for subscriber in subscribers:
            msg_copy = Message(
                sender=message.sender,
                receiver=subscriber,
                content=message.content,
                correlation_id=message.id,
                delivery_mode=message.delivery_mode
            )

            if await self.send(msg_copy):
                delivered += 1

        self._log_message(message, f"published_to_{delivered}")
        return delivered

    async def receive(
        self,
        agent_id: str,
        timeout: float = None
    ) -> Optional[Message]:
        """Recibe mensaje para un agente."""
        if agent_id not in self._queues:
            return None

        return await self._queues[agent_id].dequeue(timeout)

    def acknowledge(self, agent_id: str, message_id: str):
        """Confirma procesamiento de mensaje."""
        if agent_id in self._queues:
            self._queues[agent_id].acknowledge(message_id)

    async def request_response(
        self,
        message: Message,
        timeout: float = 30.0
    ) -> Optional[Message]:
        """Patrón request-response síncrono."""
        # Crear cola temporal para respuesta
        response_queue = f"_response_{message.id}"
        self.register_agent(response_queue)
        message.reply_to = response_queue

        try:
            # Enviar solicitud
            await self.send(message)

            # Esperar respuesta
            response = await self.receive(response_queue, timeout)
            return response

        finally:
            self.unregister_agent(response_queue)

    def _log_message(self, message: Message, status: str):
        """Registra mensaje."""
        self._message_log.append({
            "message_id": message.id,
            "sender": message.sender,
            "receiver": message.receiver,
            "status": status,
            "timestamp": datetime.now().isoformat()
        })

        if len(self._message_log) > 5000:
            self._message_log = self._message_log[-2500:]

    def get_stats(self) -> Dict[str, Any]:
        """Obtiene estadísticas del broker."""
        return {
            "registered_agents": len(self._queues),
            "topics": len(self._topics),
            "message_log_size": len(self._message_log),
            "queue_sizes": {
                agent_id: queue.size
                for agent_id, queue in self._queues.items()
            }
        }


class MessagePassingAgent:
    """Agente que usa paso de mensajes."""

    def __init__(self, agent_id: str, broker: MessageBroker):
        self.agent_id = agent_id
        self.broker = broker
        self._handlers: Dict[str, Callable] = {}
        self._running = False

        broker.register_agent(agent_id)

    def on_message(self, message_type: str):
        """Decorador para registrar handlers."""
        def decorator(func: Callable):
            self._handlers[message_type] = func
            return func
        return decorator

    async def send(
        self,
        receiver: str,
        content: Any,
        delivery_mode: DeliveryMode = DeliveryMode.AT_LEAST_ONCE
    ) -> bool:
        """Envía mensaje a otro agente."""
        message = Message(
            sender=self.agent_id,
            receiver=receiver,
            content=content,
            delivery_mode=delivery_mode
        )
        return await self.broker.send(message)

    async def request(
        self,
        receiver: str,
        content: Any,
        timeout: float = 30.0
    ) -> Optional[Any]:
        """Envía solicitud y espera respuesta."""
        message = Message(
            sender=self.agent_id,
            receiver=receiver,
            content=content
        )

        response = await self.broker.request_response(message, timeout)
        return response.content if response else None

    async def reply(self, original_message: Message, content: Any):
        """Responde a un mensaje."""
        if original_message.reply_to:
            reply = Message(
                sender=self.agent_id,
                receiver=original_message.reply_to,
                content=content,
                correlation_id=original_message.id
            )
            await self.broker.send(reply)

    async def start(self):
        """Inicia procesamiento de mensajes."""
        self._running = True

        while self._running:
            message = await self.broker.receive(self.agent_id, timeout=1.0)

            if message:
                await self._process_message(message)

    async def stop(self):
        """Detiene procesamiento."""
        self._running = False

    async def _process_message(self, message: Message):
        """Procesa un mensaje recibido."""
        try:
            content = message.content
            message_type = content.get("type", "default") if isinstance(content, dict) else "default"

            handler = self._handlers.get(message_type, self._handlers.get("default"))

            if handler:
                result = await handler(message)

                # Auto-responder si hay reply_to
                if result is not None and message.reply_to:
                    await self.reply(message, result)

            # Confirmar procesamiento
            self.broker.acknowledge(self.agent_id, message.id)

        except Exception as e:
            print(f"Error procesando mensaje: {e}")


# Ejemplo de uso
async def demo_message_passing():
    broker = MessageBroker()

    # Crear agentes
    worker = MessagePassingAgent("worker", broker)
    coordinator = MessagePassingAgent("coordinator", broker)

    @worker.on_message("task")
    async def handle_task(message: Message):
        print(f"Worker procesando: {message.content}")
        return {"status": "completed", "result": "tarea ejecutada"}

    @worker.on_message("default")
    async def handle_default(message: Message):
        print(f"Worker recibió mensaje genérico: {message.content}")

    # Iniciar worker en background
    worker_task = asyncio.create_task(worker.start())

    # Coordinator envía solicitud
    await asyncio.sleep(0.1)  # Dar tiempo al worker para iniciar

    response = await coordinator.request(
        "worker",
        {"type": "task", "data": "procesar datos"},
        timeout=5.0
    )

    print(f"Coordinator recibió respuesta: {response}")

    # Detener
    await worker.stop()
    worker_task.cancel()


if __name__ == "__main__":
    asyncio.run(demo_message_passing())
```

## Sistema Híbrido: Memoria + Mensajes

```python
"""
Sistema híbrido que combina memoria compartida y paso de mensajes.
"""
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional, Callable
from datetime import datetime
import asyncio
import json


class HybridCommunicationSystem:
    """Sistema que combina ambos paradigmas."""

    def __init__(self):
        self.shared_memory = SharedMemory("hybrid")
        self.message_broker = MessageBroker()
        self._sync_enabled = True

    def register_agent(self, agent_id: str):
        """Registra agente en ambos sistemas."""
        self.message_broker.register_agent(agent_id)

    async def write_and_notify(
        self,
        key: str,
        value: Any,
        writer: str,
        notify_agents: List[str] = None
    ):
        """Escribe en memoria y notifica a agentes."""
        # Escribir en memoria compartida
        self.shared_memory.write(key, value, writer)

        # Notificar a agentes específicos
        if notify_agents:
            notification = Message(
                sender=writer,
                receiver="",
                content={
                    "type": "memory_update",
                    "key": key,
                    "action": "write"
                }
            )

            for agent_id in notify_agents:
                notification.receiver = agent_id
                await self.message_broker.send(notification)

    async def request_with_cache(
        self,
        requester: str,
        target: str,
        request_data: Dict[str, Any],
        cache_key: Optional[str] = None,
        cache_ttl: int = 300
    ) -> Any:
        """Request con cache en memoria compartida."""
        # Verificar cache
        if cache_key:
            cached = self.shared_memory.read(f"cache:{cache_key}", requester)
            if cached:
                return cached

        # Hacer request
        message = Message(
            sender=requester,
            receiver=target,
            content=request_data
        )

        response = await self.message_broker.request_response(message)

        # Guardar en cache
        if cache_key and response:
            self.shared_memory.write(
                key=f"cache:{cache_key}",
                value=response.content,
                owner=requester,
                ttl_seconds=cache_ttl
            )

        return response.content if response else None

    def get_or_compute(
        self,
        key: str,
        compute_fn: Callable,
        agent_id: str
    ) -> Any:
        """Obtiene de memoria o computa y guarda."""
        cached = self.shared_memory.read(key, agent_id)
        if cached is not None:
            return cached

        result = compute_fn()
        self.shared_memory.write(key, result, agent_id)
        return result


@dataclass
class CollaborativeWorkspace:
    """Espacio de trabajo colaborativo para múltiples agentes."""
    workspace_id: str
    memory: SharedMemory
    broker: MessageBroker
    participants: List[str] = field(default_factory=list)

    def __post_init__(self):
        self._prefix = f"workspace:{self.workspace_id}:"

    def join(self, agent_id: str):
        """Agente se une al workspace."""
        if agent_id not in self.participants:
            self.participants.append(agent_id)
            self.broker.register_agent(agent_id)
            self.broker.subscribe(agent_id, f"workspace:{self.workspace_id}")

    def leave(self, agent_id: str):
        """Agente abandona el workspace."""
        if agent_id in self.participants:
            self.participants.remove(agent_id)
            self.broker.unsubscribe(agent_id, f"workspace:{self.workspace_id}")

    def set_shared_data(self, key: str, value: Any, setter: str):
        """Establece dato compartido en el workspace."""
        self.memory.write(
            key=f"{self._prefix}{key}",
            value=value,
            owner=setter,
            tags=[f"workspace:{self.workspace_id}"]
        )

    def get_shared_data(self, key: str, getter: str) -> Any:
        """Obtiene dato compartido del workspace."""
        return self.memory.read(f"{self._prefix}{key}", getter)

    async def broadcast(self, sender: str, content: Any):
        """Envía mensaje a todos los participantes."""
        message = Message(
            sender=sender,
            receiver="",
            content=content
        )

        await self.broker.publish(
            f"workspace:{self.workspace_id}",
            message
        )

    async def propose_change(
        self,
        proposer: str,
        key: str,
        new_value: Any,
        require_consensus: bool = True
    ) -> bool:
        """Propone cambio con posible consenso."""
        if not require_consensus:
            self.set_shared_data(key, new_value, proposer)
            return True

        # Solicitar votos
        proposal_id = f"proposal_{datetime.now().timestamp()}"

        self.memory.write(
            key=f"{self._prefix}proposals:{proposal_id}",
            value={
                "key": key,
                "new_value": new_value,
                "proposer": proposer,
                "votes": {},
                "status": "pending"
            },
            owner=proposer,
            ttl_seconds=60
        )

        # Notificar a participantes
        await self.broadcast(proposer, {
            "type": "vote_request",
            "proposal_id": proposal_id,
            "key": key,
            "new_value": new_value
        })

        # Esperar votos (simplificado - en producción sería async)
        await asyncio.sleep(5)

        # Contar votos
        proposal = self.memory.read(
            f"{self._prefix}proposals:{proposal_id}",
            proposer
        )

        if proposal:
            votes = proposal.get("votes", {})
            approvals = sum(1 for v in votes.values() if v)
            required = len(self.participants) // 2 + 1

            if approvals >= required:
                self.set_shared_data(key, new_value, proposer)
                return True

        return False


class HybridAgent:
    """Agente que utiliza sistema híbrido."""

    def __init__(
        self,
        agent_id: str,
        hybrid_system: HybridCommunicationSystem
    ):
        self.agent_id = agent_id
        self.system = hybrid_system
        self.system.register_agent(agent_id)
        self._local_cache: Dict[str, Any] = {}

    async def collaborate(
        self,
        task: str,
        collaborators: List[str],
        shared_context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Colabora con otros agentes en una tarea."""
        # Crear workspace temporal
        workspace = CollaborativeWorkspace(
            workspace_id=f"collab_{self.agent_id}_{datetime.now().timestamp()}",
            memory=self.system.shared_memory,
            broker=self.system.message_broker
        )

        # Unir participantes
        workspace.join(self.agent_id)
        for collab in collaborators:
            workspace.join(collab)

        # Compartir contexto
        workspace.set_shared_data("context", shared_context, self.agent_id)
        workspace.set_shared_data("task", task, self.agent_id)

        # Notificar inicio
        await workspace.broadcast(self.agent_id, {
            "type": "collaboration_start",
            "task": task
        })

        # Obtener resultados (simplificado)
        results = {
            "workspace_id": workspace.workspace_id,
            "participants": workspace.participants,
            "status": "initiated"
        }

        return results


# Ejemplo de uso
async def demo_hybrid():
    system = HybridCommunicationSystem()

    agent1 = HybridAgent("analyst", system)
    agent2 = HybridAgent("writer", system)

    # Colaboración
    result = await agent1.collaborate(
        task="Crear informe de análisis",
        collaborators=["writer"],
        shared_context={"topic": "ventas Q4", "deadline": "mañana"}
    )

    print(f"Colaboración iniciada: {result}")


if __name__ == "__main__":
    asyncio.run(demo_hybrid())
```

## Comparativa y Guía de Selección

```python
"""
Guía para seleccionar entre memoria compartida y paso de mensajes.
"""
from dataclasses import dataclass
from typing import List, Dict
from enum import Enum


class UseCase(Enum):
    """Casos de uso para comunicación."""
    STATE_SHARING = "state_sharing"
    REQUEST_RESPONSE = "request_response"
    EVENT_STREAMING = "event_streaming"
    BROADCAST = "broadcast"
    CACHING = "caching"
    COORDINATION = "coordination"


@dataclass
class CommunicationRequirement:
    """Requisitos de comunicación."""
    use_case: UseCase
    latency_sensitive: bool = False
    high_throughput: bool = False
    strong_consistency: bool = False
    fault_tolerant: bool = False
    scalable: bool = False


class CommunicationSelector:
    """Selector de paradigma de comunicación."""

    RECOMMENDATIONS = {
        UseCase.STATE_SHARING: {
            "preferred": "shared_memory",
            "reason": "Acceso directo y rápido al estado",
            "when_messages": "Si necesitas notificaciones de cambios"
        },
        UseCase.REQUEST_RESPONSE: {
            "preferred": "message_passing",
            "reason": "Modelo natural para RPC",
            "when_shared": "Si respuestas son cacheables"
        },
        UseCase.EVENT_STREAMING: {
            "preferred": "message_passing",
            "reason": "Manejo asíncrono de flujo de eventos",
            "when_shared": "Nunca - no es apropiado"
        },
        UseCase.BROADCAST: {
            "preferred": "message_passing",
            "reason": "Pub/sub nativo",
            "when_shared": "Si todos deben ver exactamente lo mismo"
        },
        UseCase.CACHING: {
            "preferred": "shared_memory",
            "reason": "Acceso rápido sin overhead de red",
            "when_messages": "Para invalidación distribuida"
        },
        UseCase.COORDINATION: {
            "preferred": "hybrid",
            "reason": "Combina estado compartido con señalización",
            "when_shared": "Solo para primitivas simples"
        }
    }

    def recommend(
        self,
        requirements: CommunicationRequirement
    ) -> Dict[str, str]:
        """Recomienda paradigma basado en requisitos."""
        base = self.RECOMMENDATIONS.get(requirements.use_case, {})
        recommendation = base.copy()

        # Ajustar por requisitos adicionales
        if requirements.high_throughput and requirements.latency_sensitive:
            recommendation["adjustment"] = "Considerar shared_memory para hot path"

        if requirements.strong_consistency:
            recommendation["adjustment"] = "Usar message_passing con ACKs"

        if requirements.fault_tolerant:
            recommendation["adjustment"] = "Preferir message_passing con persistencia"

        if requirements.scalable:
            recommendation["adjustment"] = "Message_passing escala mejor horizontalmente"

        return recommendation


# Tabla comparativa
COMPARISON_TABLE = """
┌─────────────────────┬──────────────────────┬──────────────────────┐
│     Aspecto         │   Memoria Compartida │   Paso de Mensajes   │
├─────────────────────┼──────────────────────┼──────────────────────┤
│ Latencia            │ Muy baja             │ Baja-Media           │
│ Throughput          │ Alto                 │ Medio-Alto           │
│ Escalabilidad       │ Limitada             │ Excelente            │
│ Consistencia        │ Fuerte (con locks)   │ Eventual             │
│ Acoplamiento        │ Alto                 │ Bajo                 │
│ Complejidad         │ Baja                 │ Media                │
│ Tolerancia a fallos │ Baja                 │ Alta                 │
│ Debugging           │ Difícil              │ Más fácil            │
│ Casos de uso        │ Estado, cache        │ RPC, eventos         │
└─────────────────────┴──────────────────────┴──────────────────────┘
"""

print(COMPARISON_TABLE)
```

## Ejercicios Prácticos

### Ejercicio 1: Blackboard Pattern
Implementa el patrón blackboard para resolución colaborativa:

```python
"""
Ejercicio: Implementar patrón Blackboard.
"""

class Blackboard:
    """Pizarra para resolución colaborativa de problemas."""

    def __init__(self):
        self.sections: Dict[str, Any] = {}
        self.contributors: List[str] = []

    # TODO: Implementar:
    # 1. post_hypothesis(agent, section, hypothesis)
    # 2. read_section(section)
    # 3. refine_hypothesis(agent, section, refinement)
    # 4. get_solution_candidates()
    # 5. vote_on_solution(agent, candidate_id)
```

### Ejercicio 2: Message Router Inteligente
Crea un router que decida entre memoria y mensajes:

```python
"""
Ejercicio: Router inteligente de comunicación.
"""

class IntelligentRouter:
    def __init__(self, memory: SharedMemory, broker: MessageBroker):
        self.memory = memory
        self.broker = broker

    async def route(
        self,
        sender: str,
        receiver: str,
        content: Any,
        hints: Dict[str, Any] = None
    ) -> Any:
        """
        Decide automáticamente el mejor canal.
        TODO: Implementar lógica de decisión basada en:
        - Tamaño del contenido
        - Frecuencia de acceso
        - Requisitos de respuesta
        - Historial de comunicación
        """
        pass
```

## Resumen

| Paradigma | Fortalezas | Debilidades | Mejor Para |
|-----------|-----------|-------------|------------|
| **Memoria Compartida** | Baja latencia, simple | No escala, race conditions | Estado compartido, cache |
| **Paso de Mensajes** | Desacoplado, escalable | Overhead, complejidad | RPC, eventos, workflows |
| **Híbrido** | Flexibilidad máxima | Más complejo de mantener | Sistemas complejos |

---

**Siguiente:** [7.2.3 Manejo de Conflictos y Deadlocks](./7.2.3-conflictos-deadlocks.md)
