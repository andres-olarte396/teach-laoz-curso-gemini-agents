# 8.1.2 AutoGPT Pattern: Goals ‚Üí Tasks ‚Üí Execution

## Objetivo de Aprendizaje

Implementar el patr√≥n AutoGPT completo que transforma objetivos de alto nivel en tareas ejecutables mediante un ciclo aut√≥nomo de planificaci√≥n, ejecuci√≥n y reflexi√≥n, usando Google Gemini.

## Introducci√≥n

El patr√≥n AutoGPT representa uno de los enfoques m√°s ambiciosos para agentes aut√≥nomos. A diferencia de BabyAGI que se enfoca en tareas, AutoGPT trabaja con objetivos de alto nivel, descomponi√©ndolos recursivamente y manteniendo un ciclo continuo de pensamiento-acci√≥n-observaci√≥n.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     AUTOGPT ARCHITECTURE                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                 ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                      GOALS (5)                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  1. Objetivo principal                                  ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  2-5. Sub-objetivos de soporte                          ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                          ‚îÇ                                      ‚îÇ
‚îÇ                          v                                      ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    THOUGHT                              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  "Debo primero analizar el mercado actual..."           ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                          ‚îÇ                                      ‚îÇ
‚îÇ                          v                                      ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                   REASONING                             ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  "Porque sin datos de mercado no puedo..."              ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                          ‚îÇ                                      ‚îÇ
‚îÇ                          v                                      ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                     PLAN                                ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  1. Usar herramienta de b√∫squeda                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  2. Analizar resultados                                 ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  3. Sintetizar informaci√≥n                              ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                          ‚îÇ                                      ‚îÇ
‚îÇ                          v                                      ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ   ‚îÇ  ACTION   ‚îÇ‚îÄ‚îÄ>‚îÇOBSERVATION‚îÇ‚îÄ‚îÄ>‚îÇ CRITICISM ‚îÇ                ‚îÇ
‚îÇ   ‚îÇ  (Tool)   ‚îÇ   ‚îÇ (Result)  ‚îÇ   ‚îÇ(Reflect)  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ       ‚îÇ
‚îÇ                                                         ‚îÇ       ‚îÇ
‚îÇ                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îÇ                          v                                      ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                 LONG-TERM MEMORY                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  Experiences, learnings, context                        ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n del Core de AutoGPT

```python
"""
Implementaci√≥n del patr√≥n AutoGPT con Google Gemini.
"""
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Callable
from datetime import datetime
from enum import Enum
import json
import os


class CommandType(Enum):
    """Tipos de comandos disponibles."""
    SEARCH = "search"
    WRITE_FILE = "write_file"
    READ_FILE = "read_file"
    EXECUTE_CODE = "execute_code"
    BROWSE_WEB = "browse_web"
    THINK = "think"
    PLAN = "plan"
    FINISH = "finish"


@dataclass
class Goal:
    """Representa un objetivo del agente."""
    goal_id: int
    description: str
    priority: int  # 1-5, 1 es m√°s importante
    is_primary: bool = False
    achieved: bool = False
    progress: float = 0.0  # 0-100


@dataclass
class ThoughtProcess:
    """Proceso de pensamiento del agente."""
    thought: str
    reasoning: str
    plan: List[str]
    criticism: str
    next_action: str
    action_input: Dict[str, Any]


@dataclass
class ActionResult:
    """Resultado de una acci√≥n."""
    action: str
    success: bool
    output: Any
    error: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)


class LongTermMemory:
    """Memoria a largo plazo del agente."""

    def __init__(self, max_entries: int = 100):
        self.entries: List[Dict[str, Any]] = []
        self.max_entries = max_entries
        self.summaries: List[str] = []

    def add(self, content: str, category: str, importance: int = 5):
        """Agrega entrada a la memoria."""
        entry = {
            "content": content,
            "category": category,
            "importance": importance,
            "timestamp": datetime.now().isoformat(),
            "access_count": 0
        }
        self.entries.append(entry)

        # Mantener l√≠mite
        if len(self.entries) > self.max_entries:
            self._compress_memory()

    def search(self, query: str, limit: int = 5) -> List[Dict[str, Any]]:
        """Busca en memoria (b√∫squeda simple por keywords)."""
        query_words = set(query.lower().split())
        scored_entries = []

        for entry in self.entries:
            content_words = set(entry["content"].lower().split())
            overlap = len(query_words & content_words)
            if overlap > 0:
                score = overlap * entry["importance"]
                scored_entries.append((score, entry))

        scored_entries.sort(key=lambda x: x[0], reverse=True)
        return [entry for _, entry in scored_entries[:limit]]

    def _compress_memory(self):
        """Comprime memoria eliminando entradas menos importantes."""
        # Ordenar por importancia y recencia
        self.entries.sort(
            key=lambda x: (x["importance"], x["timestamp"]),
            reverse=True
        )
        # Mantener solo las m√°s importantes
        self.entries = self.entries[:self.max_entries // 2]

    def get_summary(self) -> str:
        """Genera resumen de la memoria."""
        if not self.entries:
            return "Memoria vac√≠a."

        categories = {}
        for entry in self.entries:
            cat = entry["category"]
            if cat not in categories:
                categories[cat] = []
            categories[cat].append(entry["content"][:100])

        summary_parts = []
        for cat, contents in categories.items():
            summary_parts.append(f"{cat}: {len(contents)} entradas")

        return "; ".join(summary_parts)


class AutoGPT:
    """Implementaci√≥n del patr√≥n AutoGPT."""

    def __init__(
        self,
        name: str,
        role: str,
        goals: List[str],
        api_key: str = None,
        max_iterations: int = 25,
        model_name: str = "gemini-1.5-flash"
    ):
        genai.configure(api_key=api_key or os.getenv("GOOGLE_API_KEY"))
        self.model = genai.GenerativeModel(model_name)

        self.name = name
        self.role = role
        self.goals = self._create_goals(goals)
        self.max_iterations = max_iterations

        self.memory = LongTermMemory()
        self.action_history: List[ActionResult] = []
        self.commands: Dict[str, Callable] = {}
        self.iteration = 0
        self.running = False

        # Registrar comandos por defecto
        self._register_default_commands()

    def _create_goals(self, goal_descriptions: List[str]) -> List[Goal]:
        """Crea estructura de objetivos."""
        goals = []
        for i, desc in enumerate(goal_descriptions[:5]):  # M√°ximo 5 goals
            goals.append(Goal(
                goal_id=i + 1,
                description=desc,
                priority=i + 1,
                is_primary=(i == 0)
            ))
        return goals

    def _register_default_commands(self):
        """Registra comandos por defecto."""
        self.commands = {
            "search": self._cmd_search,
            "write_file": self._cmd_write_file,
            "read_file": self._cmd_read_file,
            "think": self._cmd_think,
            "plan": self._cmd_plan,
            "finish": self._cmd_finish,
            "analyze": self._cmd_analyze
        }

    def register_command(self, name: str, func: Callable, description: str):
        """Registra un comando personalizado."""
        self.commands[name] = func

    # === Comandos ===

    def _cmd_search(self, query: str) -> str:
        """Comando de b√∫squeda (simulado)."""
        # En producci√≥n, integrar con API de b√∫squeda real
        return f"Resultados de b√∫squeda para '{query}':\n1. Resultado relevante 1\n2. Resultado relevante 2\n3. Resultado relevante 3"

    def _cmd_write_file(self, filename: str, content: str) -> str:
        """Comando para escribir archivo (simulado)."""
        return f"Archivo '{filename}' escrito exitosamente ({len(content)} caracteres)"

    def _cmd_read_file(self, filename: str) -> str:
        """Comando para leer archivo (simulado)."""
        return f"Contenido de '{filename}': [contenido simulado del archivo]"

    def _cmd_think(self, thought: str) -> str:
        """Comando para pensar/reflexionar."""
        prompt = f"""Reflexiona profundamente sobre: {thought}

Considera:
1. Implicaciones
2. Conexiones con otros conceptos
3. Posibles acciones derivadas

Reflexi√≥n:"""

        response = self.model.generate_content(prompt)
        return response.text

    def _cmd_plan(self, objective: str) -> str:
        """Comando para crear un plan."""
        prompt = f"""Crea un plan detallado para: {objective}

El plan debe tener:
1. Pasos espec√≠ficos y accionables
2. Dependencias entre pasos
3. Criterios de √©xito

Plan:"""

        response = self.model.generate_content(prompt)
        return response.text

    def _cmd_finish(self, summary: str) -> str:
        """Comando para finalizar."""
        return f"FINALIZADO: {summary}"

    def _cmd_analyze(self, data: str) -> str:
        """Comando para analizar datos."""
        prompt = f"""Analiza los siguientes datos/informaci√≥n:

{data}

Proporciona:
1. Hallazgos principales
2. Patrones identificados
3. Recomendaciones

An√°lisis:"""

        response = self.model.generate_content(prompt)
        return response.text

    # === L√≥gica Principal ===

    def _get_system_prompt(self) -> str:
        """Genera el prompt del sistema."""
        goals_text = "\n".join([
            f"{g.goal_id}. {g.description} (Progreso: {g.progress}%)"
            for g in self.goals
        ])

        commands_text = "\n".join([
            f"- {name}: {func.__doc__ or 'Sin descripci√≥n'}"
            for name, func in self.commands.items()
        ])

        memory_summary = self.memory.get_summary()

        return f"""Eres {self.name}, {self.role}.

TUS OBJETIVOS:
{goals_text}

COMANDOS DISPONIBLES:
{commands_text}

MEMORIA: {memory_summary}

RESTRICCIONES:
1. Solo usa los comandos listados
2. Aseg√∫rate de que cada acci√≥n te acerque a tus objetivos
3. Reflexiona cr√≠ticamente sobre tus acciones
4. Usa 'finish' cuando hayas logrado tu objetivo principal

FORMATO DE RESPUESTA (JSON):
{{
    "thoughts": {{
        "text": "Tu pensamiento actual",
        "reasoning": "Por qu√© piensas esto",
        "plan": ["paso 1", "paso 2", "paso 3"],
        "criticism": "Cr√≠tica constructiva de tu enfoque",
        "speak": "Resumen para el usuario"
    }},
    "command": {{
        "name": "nombre_del_comando",
        "args": {{"arg1": "valor1"}}
    }}
}}"""

    def _think(self) -> Optional[ThoughtProcess]:
        """Genera el pr√≥ximo pensamiento y acci√≥n."""
        # Obtener contexto reciente
        recent_actions = self.action_history[-5:]
        actions_context = "\n".join([
            f"- {a.action}: {'‚úì' if a.success else '‚úó'} {str(a.output)[:100]}"
            for a in recent_actions
        ])

        # Buscar memoria relevante
        current_goal = self.goals[0].description
        relevant_memory = self.memory.search(current_goal, limit=3)
        memory_context = "\n".join([
            f"- {m['content'][:150]}"
            for m in relevant_memory
        ])

        prompt = f"""{self._get_system_prompt()}

ACCIONES RECIENTES:
{actions_context if actions_context else "Ninguna acci√≥n previa."}

MEMORIA RELEVANTE:
{memory_context if memory_context else "Sin memoria relevante."}

Determina tu pr√≥ximo pensamiento y acci√≥n. Responde SOLO con JSON v√°lido:"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            # Limpiar respuesta
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            elif "```" in text:
                text = text.split("```")[1].split("```")[0]

            result = json.loads(text.strip())

            thoughts = result.get("thoughts", {})
            command = result.get("command", {})

            return ThoughtProcess(
                thought=thoughts.get("text", ""),
                reasoning=thoughts.get("reasoning", ""),
                plan=thoughts.get("plan", []),
                criticism=thoughts.get("criticism", ""),
                next_action=command.get("name", "think"),
                action_input=command.get("args", {})
            )

        except (json.JSONDecodeError, KeyError) as e:
            # Fallback: acci√≥n de pensamiento
            return ThoughtProcess(
                thought="Error procesando respuesta, reflexionando...",
                reasoning="Necesito reformular mi enfoque",
                plan=["Analizar situaci√≥n", "Determinar siguiente paso"],
                criticism="Debo ser m√°s claro en mi razonamiento",
                next_action="think",
                action_input={"thought": "¬øCu√°l deber√≠a ser mi pr√≥ximo paso?"}
            )

    def _execute_action(self, thought_process: ThoughtProcess) -> ActionResult:
        """Ejecuta la acci√≥n determinada."""
        action_name = thought_process.next_action
        action_args = thought_process.action_input

        if action_name not in self.commands:
            return ActionResult(
                action=action_name,
                success=False,
                output=None,
                error=f"Comando desconocido: {action_name}"
            )

        try:
            # Ejecutar comando
            command_func = self.commands[action_name]

            # Manejar diferentes firmas de funciones
            if isinstance(action_args, dict):
                result = command_func(**action_args)
            else:
                result = command_func(action_args)

            return ActionResult(
                action=action_name,
                success=True,
                output=result
            )

        except Exception as e:
            return ActionResult(
                action=action_name,
                success=False,
                output=None,
                error=str(e)
            )

    def _update_goals(self, action_result: ActionResult):
        """Actualiza progreso de objetivos."""
        if not action_result.success:
            return

        # Usar Gemini para evaluar progreso
        goals_text = "\n".join([
            f"{g.goal_id}. {g.description} (actual: {g.progress}%)"
            for g in self.goals
        ])

        prompt = f"""Eval√∫a c√≥mo esta acci√≥n afecta el progreso hacia los objetivos.

OBJETIVOS:
{goals_text}

ACCI√ìN COMPLETADA: {action_result.action}
RESULTADO: {str(action_result.output)[:500]}

Responde SOLO con JSON:
{{
    "goal_updates": [
        {{"goal_id": 1, "progress_delta": 5, "reason": "raz√≥n"}}
    ]
}}"""

        try:
            response = self.model.generate_content(prompt)
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]

            result = json.loads(text.strip())

            for update in result.get("goal_updates", []):
                goal_id = update.get("goal_id")
                delta = update.get("progress_delta", 0)

                for goal in self.goals:
                    if goal.goal_id == goal_id:
                        goal.progress = min(100, goal.progress + delta)
                        if goal.progress >= 100:
                            goal.achieved = True

        except:
            pass

    def _should_continue(self) -> bool:
        """Determina si debe continuar ejecutando."""
        # Verificar si objetivo principal est√° logrado
        primary_goal = next((g for g in self.goals if g.is_primary), None)
        if primary_goal and primary_goal.achieved:
            return False

        # Verificar l√≠mite de iteraciones
        if self.iteration >= self.max_iterations:
            return False

        return self.running

    def run(self) -> Dict[str, Any]:
        """Ejecuta el bucle principal de AutoGPT."""
        self.running = True
        print(f"üöÄ Iniciando {self.name} - {self.role}")
        print(f"üìé Objetivos: {len(self.goals)}")

        while self._should_continue():
            self.iteration += 1
            print(f"\n{'='*60}")
            print(f"üîÑ Iteraci√≥n {self.iteration}/{self.max_iterations}")

            # Pensar
            thought = self._think()
            if thought is None:
                print("‚ùå Error en proceso de pensamiento")
                continue

            print(f"üí≠ Pensamiento: {thought.thought[:100]}...")
            print(f"üìã Plan: {thought.plan[:2]}...")
            print(f"üéØ Acci√≥n: {thought.next_action}")

            # Verificar si es finish
            if thought.next_action == "finish":
                print("\n‚úÖ Agente decidi√≥ finalizar")
                self.running = False
                break

            # Ejecutar acci√≥n
            result = self._execute_action(thought)
            self.action_history.append(result)

            if result.success:
                print(f"‚úÖ √âxito: {str(result.output)[:100]}...")

                # Guardar en memoria
                self.memory.add(
                    content=f"Acci√≥n {thought.next_action}: {result.output}",
                    category="action_result",
                    importance=7
                )

                # Actualizar progreso
                self._update_goals(result)

            else:
                print(f"‚ùå Error: {result.error}")

                # Guardar error en memoria
                self.memory.add(
                    content=f"Error en {thought.next_action}: {result.error}",
                    category="error",
                    importance=8
                )

        self.running = False
        return self._generate_final_report()

    def _generate_final_report(self) -> Dict[str, Any]:
        """Genera reporte final."""
        return {
            "name": self.name,
            "role": self.role,
            "iterations": self.iteration,
            "goals": [
                {
                    "description": g.description,
                    "progress": g.progress,
                    "achieved": g.achieved
                }
                for g in self.goals
            ],
            "actions_taken": len(self.action_history),
            "successful_actions": sum(1 for a in self.action_history if a.success),
            "memory_entries": len(self.memory.entries)
        }


# Ejemplo de uso
if __name__ == "__main__":
    agent = AutoGPT(
        name="MarketingGPT",
        role="Especialista en Marketing Digital",
        goals=[
            "Crear una estrategia de contenido para redes sociales",
            "Identificar las mejores plataformas para el p√∫blico objetivo",
            "Definir m√©tricas clave de √©xito",
            "Proponer calendario de publicaciones"
        ],
        max_iterations=10
    )

    report = agent.run()

    print("\n" + "="*60)
    print("üìä REPORTE FINAL")
    print("="*60)
    print(json.dumps(report, indent=2, default=str))
```

## AutoGPT con Plugins

```python
"""
Sistema de plugins para extender AutoGPT.
"""
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
import google.generativeai as genai


class AutoGPTPlugin(ABC):
    """Clase base para plugins de AutoGPT."""

    @property
    @abstractmethod
    def name(self) -> str:
        """Nombre del plugin."""
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        """Descripci√≥n del plugin."""
        pass

    @abstractmethod
    def get_commands(self) -> Dict[str, callable]:
        """Retorna comandos proporcionados por el plugin."""
        pass

    def on_iteration_start(self, agent: "AutoGPT", iteration: int):
        """Hook al inicio de cada iteraci√≥n."""
        pass

    def on_iteration_end(self, agent: "AutoGPT", iteration: int, result: ActionResult):
        """Hook al final de cada iteraci√≥n."""
        pass

    def on_agent_start(self, agent: "AutoGPT"):
        """Hook al iniciar el agente."""
        pass

    def on_agent_end(self, agent: "AutoGPT", report: Dict[str, Any]):
        """Hook al finalizar el agente."""
        pass


class WebBrowserPlugin(AutoGPTPlugin):
    """Plugin para navegaci√≥n web."""

    @property
    def name(self) -> str:
        return "WebBrowser"

    @property
    def description(self) -> str:
        return "Permite navegar y extraer informaci√≥n de p√°ginas web"

    def get_commands(self) -> Dict[str, callable]:
        return {
            "browse_website": self._browse_website,
            "extract_text": self._extract_text,
            "find_links": self._find_links
        }

    def _browse_website(self, url: str) -> str:
        """Navega a una URL y retorna contenido."""
        # Simulado - en producci√≥n usar requests/selenium
        return f"Contenido de {url}: [p√°gina web simulada con informaci√≥n relevante]"

    def _extract_text(self, url: str, selector: str = None) -> str:
        """Extrae texto de una p√°gina."""
        return f"Texto extra√≠do de {url}: [texto relevante de la p√°gina]"

    def _find_links(self, url: str) -> str:
        """Encuentra links en una p√°gina."""
        return f"Links encontrados en {url}:\n- link1.com\n- link2.com\n- link3.com"


class CodeExecutionPlugin(AutoGPTPlugin):
    """Plugin para ejecuci√≥n de c√≥digo."""

    @property
    def name(self) -> str:
        return "CodeExecution"

    @property
    def description(self) -> str:
        return "Permite ejecutar c√≥digo Python de forma segura"

    def get_commands(self) -> Dict[str, callable]:
        return {
            "execute_python": self._execute_python,
            "execute_shell": self._execute_shell
        }

    def _execute_python(self, code: str) -> str:
        """Ejecuta c√≥digo Python."""
        try:
            # ADVERTENCIA: En producci√≥n, usar sandbox
            exec_globals = {"__builtins__": {"print": print, "len": len, "range": range}}
            exec(code, exec_globals)
            return "C√≥digo ejecutado exitosamente"
        except Exception as e:
            return f"Error: {str(e)}"

    def _execute_shell(self, command: str) -> str:
        """Ejecuta comando shell (simulado por seguridad)."""
        return f"[Simulado] Comando ejecutado: {command}"


class DatabasePlugin(AutoGPTPlugin):
    """Plugin para operaciones de base de datos."""

    def __init__(self):
        self.data_store: Dict[str, Any] = {}

    @property
    def name(self) -> str:
        return "Database"

    @property
    def description(self) -> str:
        return "Almacenamiento persistente de datos"

    def get_commands(self) -> Dict[str, callable]:
        return {
            "db_store": self._store,
            "db_retrieve": self._retrieve,
            "db_list": self._list_keys,
            "db_delete": self._delete
        }

    def _store(self, key: str, value: Any) -> str:
        """Almacena un valor."""
        self.data_store[key] = value
        return f"Almacenado: {key}"

    def _retrieve(self, key: str) -> str:
        """Recupera un valor."""
        if key in self.data_store:
            return f"{key}: {self.data_store[key]}"
        return f"Clave '{key}' no encontrada"

    def _list_keys(self) -> str:
        """Lista todas las claves."""
        return f"Claves: {list(self.data_store.keys())}"

    def _delete(self, key: str) -> str:
        """Elimina una clave."""
        if key in self.data_store:
            del self.data_store[key]
            return f"Eliminado: {key}"
        return f"Clave '{key}' no encontrada"


class PluginManager:
    """Gestor de plugins para AutoGPT."""

    def __init__(self):
        self.plugins: Dict[str, AutoGPTPlugin] = {}

    def register(self, plugin: AutoGPTPlugin):
        """Registra un plugin."""
        self.plugins[plugin.name] = plugin
        print(f"üì¶ Plugin registrado: {plugin.name}")

    def unregister(self, plugin_name: str):
        """Des-registra un plugin."""
        if plugin_name in self.plugins:
            del self.plugins[plugin_name]

    def get_all_commands(self) -> Dict[str, callable]:
        """Obtiene todos los comandos de todos los plugins."""
        commands = {}
        for plugin in self.plugins.values():
            commands.update(plugin.get_commands())
        return commands

    def notify_iteration_start(self, agent: "AutoGPT", iteration: int):
        """Notifica a plugins del inicio de iteraci√≥n."""
        for plugin in self.plugins.values():
            plugin.on_iteration_start(agent, iteration)

    def notify_iteration_end(self, agent: "AutoGPT", iteration: int, result: ActionResult):
        """Notifica a plugins del fin de iteraci√≥n."""
        for plugin in self.plugins.values():
            plugin.on_iteration_end(agent, iteration, result)


class PluginEnabledAutoGPT(AutoGPT):
    """AutoGPT con soporte para plugins."""

    def __init__(self, *args, plugins: List[AutoGPTPlugin] = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.plugin_manager = PluginManager()

        # Registrar plugins
        if plugins:
            for plugin in plugins:
                self.plugin_manager.register(plugin)

        # Agregar comandos de plugins
        self.commands.update(self.plugin_manager.get_all_commands())


# Ejemplo de uso
if __name__ == "__main__":
    # Crear plugins
    web_plugin = WebBrowserPlugin()
    code_plugin = CodeExecutionPlugin()
    db_plugin = DatabasePlugin()

    # Crear agente con plugins
    agent = PluginEnabledAutoGPT(
        name="ResearchGPT",
        role="Investigador Aut√≥nomo",
        goals=[
            "Investigar las tendencias actuales en IA",
            "Compilar informaci√≥n relevante",
            "Generar un informe ejecutivo"
        ],
        plugins=[web_plugin, code_plugin, db_plugin],
        max_iterations=8
    )

    report = agent.run()
    print(f"\nüìä Reporte: {json.dumps(report, indent=2, default=str)}")
```

## AutoGPT con Workspaces

```python
"""
AutoGPT con sistema de workspaces para organizaci√≥n de trabajo.
"""
import os
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime
import json


class Workspace:
    """Espacio de trabajo para el agente."""

    def __init__(self, base_path: str, agent_name: str):
        self.base_path = Path(base_path)
        self.agent_name = agent_name
        self.workspace_path = self.base_path / agent_name
        self._setup_workspace()

    def _setup_workspace(self):
        """Configura estructura del workspace."""
        directories = [
            "outputs",
            "inputs",
            "logs",
            "cache",
            "artifacts"
        ]

        for dir_name in directories:
            (self.workspace_path / dir_name).mkdir(parents=True, exist_ok=True)

    def write_output(self, filename: str, content: str) -> str:
        """Escribe archivo en outputs."""
        filepath = self.workspace_path / "outputs" / filename
        filepath.write_text(content)
        return str(filepath)

    def read_input(self, filename: str) -> Optional[str]:
        """Lee archivo de inputs."""
        filepath = self.workspace_path / "inputs" / filename
        if filepath.exists():
            return filepath.read_text()
        return None

    def log(self, message: str, level: str = "INFO"):
        """Escribe en log."""
        log_file = self.workspace_path / "logs" / f"{datetime.now().strftime('%Y%m%d')}.log"
        timestamp = datetime.now().isoformat()
        log_entry = f"[{timestamp}] [{level}] {message}\n"

        with open(log_file, "a") as f:
            f.write(log_entry)

    def save_artifact(self, name: str, data: Any):
        """Guarda artefacto."""
        filepath = self.workspace_path / "artifacts" / f"{name}.json"
        with open(filepath, "w") as f:
            json.dump(data, f, indent=2, default=str)

    def load_artifact(self, name: str) -> Optional[Any]:
        """Carga artefacto."""
        filepath = self.workspace_path / "artifacts" / f"{name}.json"
        if filepath.exists():
            with open(filepath, "r") as f:
                return json.load(f)
        return None

    def list_files(self, directory: str = "outputs") -> List[str]:
        """Lista archivos en directorio."""
        dir_path = self.workspace_path / directory
        return [f.name for f in dir_path.iterdir() if f.is_file()]


class WorkspaceEnabledAutoGPT(PluginEnabledAutoGPT):
    """AutoGPT con workspace integrado."""

    def __init__(self, *args, workspace_path: str = "./workspaces", **kwargs):
        super().__init__(*args, **kwargs)
        self.workspace = Workspace(workspace_path, self.name)

        # Sobrescribir comandos de archivo
        self.commands["write_file"] = self._workspace_write
        self.commands["read_file"] = self._workspace_read
        self.commands["list_files"] = self._workspace_list

    def _workspace_write(self, filename: str, content: str) -> str:
        """Escribe archivo en workspace."""
        path = self.workspace.write_output(filename, content)
        self.workspace.log(f"Archivo escrito: {filename}")
        return f"Archivo guardado: {path}"

    def _workspace_read(self, filename: str) -> str:
        """Lee archivo del workspace."""
        content = self.workspace.read_input(filename)
        if content:
            return content
        return f"Archivo no encontrado: {filename}"

    def _workspace_list(self, directory: str = "outputs") -> str:
        """Lista archivos del workspace."""
        files = self.workspace.list_files(directory)
        return f"Archivos en {directory}: {files}"

    def run(self) -> Dict[str, Any]:
        """Ejecuta con logging al workspace."""
        self.workspace.log(f"Agente iniciado con objetivos: {[g.description for g in self.goals]}")

        try:
            report = super().run()

            # Guardar reporte como artefacto
            self.workspace.save_artifact("final_report", report)
            self.workspace.log("Ejecuci√≥n completada exitosamente")

            return report

        except Exception as e:
            self.workspace.log(f"Error en ejecuci√≥n: {str(e)}", "ERROR")
            raise
```

## Ejercicios Pr√°cticos

### Ejercicio 1: Plugin de APIs Externas
```python
"""
Ejercicio: Crear plugin para APIs externas.
"""

class ExternalAPIPlugin(AutoGPTPlugin):
    """
    TODO: Implementar plugin que:
    1. Se conecte a APIs como OpenWeather, NewsAPI, etc.
    2. Maneje autenticaci√≥n con API keys
    3. Cache resultados para evitar llamadas repetidas
    4. Maneje rate limiting
    """

    @property
    def name(self) -> str:
        return "ExternalAPIs"

    @property
    def description(self) -> str:
        return "Conecta con APIs externas"

    def get_commands(self) -> Dict[str, callable]:
        return {
            "get_weather": self._get_weather,
            "get_news": self._get_news,
            "translate": self._translate
        }

    def _get_weather(self, city: str) -> str:
        pass

    def _get_news(self, topic: str) -> str:
        pass

    def _translate(self, text: str, target_lang: str) -> str:
        pass
```

### Ejercicio 2: AutoGPT con Checkpoints
```python
"""
Ejercicio: Agregar sistema de checkpoints.
"""

class CheckpointableAutoGPT(AutoGPT):
    """
    TODO: Implementar:
    1. Guardar checkpoint cada N iteraciones
    2. Cargar desde checkpoint al iniciar
    3. Permitir rollback a checkpoint anterior
    4. Comprimir checkpoints antiguos
    """

    def create_checkpoint(self) -> str:
        """Crea checkpoint del estado actual."""
        pass

    def load_checkpoint(self, checkpoint_id: str) -> bool:
        """Carga estado desde checkpoint."""
        pass

    def list_checkpoints(self) -> List[str]:
        """Lista checkpoints disponibles."""
        pass
```

## Resumen

| Componente | Funci√≥n | Caracter√≠sticas |
|------------|---------|-----------------|
| **Goals** | Objetivos de alto nivel | Priorizaci√≥n, tracking de progreso |
| **ThoughtProcess** | Razonamiento | Thought, reasoning, plan, criticism |
| **Commands** | Acciones ejecutables | Extensibles via plugins |
| **LongTermMemory** | Contexto persistente | B√∫squeda, compresi√≥n |
| **Plugins** | Extensibilidad | Hooks, comandos adicionales |
| **Workspace** | Organizaci√≥n | Archivos, logs, artefactos |

---

**Siguiente:** [8.1.3 Agentes con Aprendizaje Continuo](./8.1.3-aprendizaje-continuo.md)
