# 8.1.1 BabyAGI y Task-Driven Agents

## Objetivo de Aprendizaje

Implementar agentes aut√≥nomos basados en el patr√≥n BabyAGI que generan, priorizan y ejecutan sus propias tareas de forma iterativa, usando Google Gemini como motor de razonamiento.

## Introducci√≥n

BabyAGI es un patr√≥n de agente aut√≥nomo que mantiene una lista de tareas, las prioriza continuamente, y ejecuta la m√°s importante en cada iteraci√≥n. Este enfoque "task-driven" permite a los agentes operar con m√≠nima supervisi√≥n hacia un objetivo de alto nivel.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    BABYAGI ARCHITECTURE                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                 ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                               ‚îÇ
‚îÇ   ‚îÇ   OBJETIVO  ‚îÇ  "Crear plan de marketing para startup"       ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                               ‚îÇ
‚îÇ          ‚îÇ                                                      ‚îÇ
‚îÇ          v                                                      ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    TASK QUEUE                            ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ 1. [HIGH] Investigar competencia                   ‚îÇ ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ 2. [MED]  Definir p√∫blico objetivo                 ‚îÇ ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ 3. [MED]  Crear propuesta de valor                 ‚îÇ ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ 4. [LOW]  Dise√±ar calendario de contenido          ‚îÇ ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                          ‚îÇ                                      ‚îÇ
‚îÇ          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                     ‚îÇ
‚îÇ          v               v               v                      ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ   ‚îÇ EXECUTION ‚îÇ   ‚îÇ CREATION  ‚îÇ   ‚îÇPRIORIZATION‚îÇ               ‚îÇ
‚îÇ   ‚îÇ   AGENT   ‚îÇ   ‚îÇ   AGENT   ‚îÇ   ‚îÇ   AGENT   ‚îÇ                ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ         ‚îÇ               ‚îÇ               ‚îÇ                       ‚îÇ
‚îÇ         v               v               v                       ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ   ‚îÇ                    MEMORY / CONTEXT                    ‚îÇ    ‚îÇ
‚îÇ   ‚îÇ  Resultados, aprendizajes, tareas completadas          ‚îÇ    ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n del Core de BabyAGI

```python
"""
Implementaci√≥n de BabyAGI con Google Gemini.
"""
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from datetime import datetime
from enum import Enum
import json
import os
from collections import deque


class TaskPriority(Enum):
    """Prioridades de tarea."""
    CRITICAL = 1
    HIGH = 2
    MEDIUM = 3
    LOW = 4


class TaskStatus(Enum):
    """Estados de tarea."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    BLOCKED = "blocked"


@dataclass
class Task:
    """Representa una tarea en el sistema."""
    task_id: int
    description: str
    priority: TaskPriority = TaskPriority.MEDIUM
    status: TaskStatus = TaskStatus.PENDING
    created_at: datetime = field(default_factory=datetime.now)
    completed_at: Optional[datetime] = None
    result: Optional[str] = None
    dependencies: List[int] = field(default_factory=list)
    parent_task_id: Optional[int] = None
    context: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "task_id": self.task_id,
            "description": self.description,
            "priority": self.priority.name,
            "status": self.status.value,
            "created_at": self.created_at.isoformat(),
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "result": self.result,
            "dependencies": self.dependencies,
            "parent_task_id": self.parent_task_id
        }


class TaskQueue:
    """Cola de tareas con priorizaci√≥n."""

    def __init__(self):
        self.tasks: Dict[int, Task] = {}
        self.next_id = 1

    def add_task(
        self,
        description: str,
        priority: TaskPriority = TaskPriority.MEDIUM,
        dependencies: List[int] = None,
        parent_task_id: int = None,
        context: Dict[str, Any] = None
    ) -> Task:
        """Agrega nueva tarea a la cola."""
        task = Task(
            task_id=self.next_id,
            description=description,
            priority=priority,
            dependencies=dependencies or [],
            parent_task_id=parent_task_id,
            context=context or {}
        )
        self.tasks[self.next_id] = task
        self.next_id += 1
        return task

    def get_next_task(self) -> Optional[Task]:
        """Obtiene la siguiente tarea ejecutable de mayor prioridad."""
        pending_tasks = [
            t for t in self.tasks.values()
            if t.status == TaskStatus.PENDING and self._dependencies_met(t)
        ]

        if not pending_tasks:
            return None

        # Ordenar por prioridad (menor n√∫mero = mayor prioridad)
        pending_tasks.sort(key=lambda t: (t.priority.value, t.created_at))
        return pending_tasks[0]

    def _dependencies_met(self, task: Task) -> bool:
        """Verifica si las dependencias est√°n completadas."""
        for dep_id in task.dependencies:
            dep_task = self.tasks.get(dep_id)
            if dep_task is None or dep_task.status != TaskStatus.COMPLETED:
                return False
        return True

    def complete_task(self, task_id: int, result: str):
        """Marca tarea como completada."""
        if task_id in self.tasks:
            task = self.tasks[task_id]
            task.status = TaskStatus.COMPLETED
            task.result = result
            task.completed_at = datetime.now()

    def fail_task(self, task_id: int, reason: str):
        """Marca tarea como fallida."""
        if task_id in self.tasks:
            task = self.tasks[task_id]
            task.status = TaskStatus.FAILED
            task.result = f"FAILED: {reason}"

    def get_pending_count(self) -> int:
        """Retorna cantidad de tareas pendientes."""
        return sum(1 for t in self.tasks.values() if t.status == TaskStatus.PENDING)

    def get_completed_tasks(self) -> List[Task]:
        """Retorna tareas completadas."""
        return [t for t in self.tasks.values() if t.status == TaskStatus.COMPLETED]

    def get_all_tasks_summary(self) -> str:
        """Genera resumen de todas las tareas."""
        lines = []
        for task in sorted(self.tasks.values(), key=lambda t: t.task_id):
            status_icon = {
                TaskStatus.PENDING: "‚è≥",
                TaskStatus.IN_PROGRESS: "üîÑ",
                TaskStatus.COMPLETED: "‚úÖ",
                TaskStatus.FAILED: "‚ùå",
                TaskStatus.BLOCKED: "üö´"
            }.get(task.status, "?")
            lines.append(f"{status_icon} [{task.priority.name}] {task.description}")
        return "\n".join(lines)


class BabyAGI:
    """Agente aut√≥nomo basado en el patr√≥n BabyAGI."""

    def __init__(
        self,
        objective: str,
        api_key: str = None,
        max_iterations: int = 10,
        model_name: str = "gemini-1.5-flash"
    ):
        genai.configure(api_key=api_key or os.getenv("GOOGLE_API_KEY"))
        self.model = genai.GenerativeModel(model_name)

        self.objective = objective
        self.max_iterations = max_iterations
        self.task_queue = TaskQueue()
        self.iteration = 0
        self.memory: List[Dict[str, Any]] = []
        self.running = False

    def _create_initial_tasks(self):
        """Crea tareas iniciales basadas en el objetivo."""
        prompt = f"""Eres un agente de planificaci√≥n. Dado el siguiente objetivo,
genera una lista de 3-5 tareas iniciales necesarias para lograrlo.

OBJETIVO: {self.objective}

Responde SOLO con JSON en este formato:
{{
    "tasks": [
        {{"description": "tarea 1", "priority": "HIGH|MEDIUM|LOW"}},
        {{"description": "tarea 2", "priority": "HIGH|MEDIUM|LOW"}},
        ...
    ]
}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            elif "```" in text:
                text = text.split("```")[1].split("```")[0]

            result = json.loads(text.strip())

            priority_map = {
                "HIGH": TaskPriority.HIGH,
                "MEDIUM": TaskPriority.MEDIUM,
                "LOW": TaskPriority.LOW,
                "CRITICAL": TaskPriority.CRITICAL
            }

            for task_data in result.get("tasks", []):
                priority = priority_map.get(
                    task_data.get("priority", "MEDIUM"),
                    TaskPriority.MEDIUM
                )
                self.task_queue.add_task(
                    description=task_data["description"],
                    priority=priority
                )

        except (json.JSONDecodeError, KeyError) as e:
            # Fallback: crear tarea gen√©rica
            self.task_queue.add_task(
                description=f"Analizar y descomponer: {self.objective}",
                priority=TaskPriority.HIGH
            )

    def _execute_task(self, task: Task) -> str:
        """Ejecuta una tarea usando Gemini."""
        # Obtener contexto de tareas previas
        completed_tasks = self.task_queue.get_completed_tasks()
        context = "\n".join([
            f"- {t.description}: {t.result[:200] if t.result else 'Sin resultado'}..."
            for t in completed_tasks[-5:]  # √öltimas 5 completadas
        ])

        prompt = f"""Eres un agente de ejecuci√≥n. Completa la siguiente tarea.

OBJETIVO GENERAL: {self.objective}

TAREA ACTUAL: {task.description}

CONTEXTO (tareas previas completadas):
{context if context else "Ninguna tarea previa completada."}

Ejecuta la tarea y proporciona un resultado detallado y accionable.
Si la tarea requiere informaci√≥n que no tienes, indica qu√© informaci√≥n adicional ser√≠a necesaria.

RESULTADO:"""

        response = self.model.generate_content(prompt)
        return response.text

    def _create_new_tasks(self, completed_task: Task):
        """Crea nuevas tareas basadas en el resultado de la tarea completada."""
        prompt = f"""Eres un agente de creaci√≥n de tareas. Bas√°ndote en el resultado
de la tarea completada, determina si se necesitan nuevas tareas.

OBJETIVO GENERAL: {self.objective}

TAREA COMPLETADA: {completed_task.description}

RESULTADO: {completed_task.result}

TAREAS PENDIENTES ACTUALES:
{self.task_queue.get_all_tasks_summary()}

Si se necesitan nuevas tareas para avanzar hacia el objetivo, genera 0-3 tareas nuevas.
No generes tareas duplicadas o muy similares a las existentes.

Responde SOLO con JSON:
{{
    "new_tasks": [
        {{"description": "nueva tarea", "priority": "HIGH|MEDIUM|LOW"}}
    ],
    "reasoning": "por qu√© se necesitan estas tareas"
}}

Si no se necesitan nuevas tareas, responde:
{{"new_tasks": [], "reasoning": "explicaci√≥n"}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            elif "```" in text:
                text = text.split("```")[1].split("```")[0]

            result = json.loads(text.strip())

            priority_map = {
                "HIGH": TaskPriority.HIGH,
                "MEDIUM": TaskPriority.MEDIUM,
                "LOW": TaskPriority.LOW
            }

            for task_data in result.get("new_tasks", []):
                priority = priority_map.get(
                    task_data.get("priority", "MEDIUM"),
                    TaskPriority.MEDIUM
                )
                self.task_queue.add_task(
                    description=task_data["description"],
                    priority=priority,
                    parent_task_id=completed_task.task_id
                )

        except (json.JSONDecodeError, KeyError):
            pass  # No crear tareas si hay error

    def _prioritize_tasks(self):
        """Re-prioriza tareas pendientes."""
        pending_tasks = [
            t for t in self.task_queue.tasks.values()
            if t.status == TaskStatus.PENDING
        ]

        if len(pending_tasks) <= 1:
            return

        task_list = "\n".join([
            f"ID {t.task_id}: {t.description} (actual: {t.priority.name})"
            for t in pending_tasks
        ])

        prompt = f"""Eres un agente de priorizaci√≥n. Re-eval√∫a las prioridades
de las siguientes tareas pendientes para lograr el objetivo de manera eficiente.

OBJETIVO: {self.objective}

TAREAS PENDIENTES:
{task_list}

Responde SOLO con JSON:
{{
    "priorities": [
        {{"task_id": 1, "priority": "HIGH|MEDIUM|LOW", "reason": "breve raz√≥n"}}
    ]
}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            elif "```" in text:
                text = text.split("```")[1].split("```")[0]

            result = json.loads(text.strip())

            priority_map = {
                "HIGH": TaskPriority.HIGH,
                "MEDIUM": TaskPriority.MEDIUM,
                "LOW": TaskPriority.LOW,
                "CRITICAL": TaskPriority.CRITICAL
            }

            for item in result.get("priorities", []):
                task_id = item.get("task_id")
                if task_id in self.task_queue.tasks:
                    new_priority = priority_map.get(
                        item.get("priority"),
                        self.task_queue.tasks[task_id].priority
                    )
                    self.task_queue.tasks[task_id].priority = new_priority

        except (json.JSONDecodeError, KeyError):
            pass

    def _check_objective_complete(self) -> bool:
        """Verifica si el objetivo se ha alcanzado."""
        completed_tasks = self.task_queue.get_completed_tasks()

        if not completed_tasks:
            return False

        completed_summary = "\n".join([
            f"- {t.description}: {t.result[:150] if t.result else 'N/A'}..."
            for t in completed_tasks
        ])

        prompt = f"""Eval√∫a si el siguiente objetivo ha sido alcanzado
bas√°ndote en las tareas completadas.

OBJETIVO: {self.objective}

TAREAS COMPLETADAS:
{completed_summary}

TAREAS PENDIENTES: {self.task_queue.get_pending_count()}

Responde SOLO con JSON:
{{
    "objective_complete": true/false,
    "completion_percentage": 0-100,
    "reasoning": "explicaci√≥n breve",
    "missing_elements": ["elemento1", "elemento2"] o []
}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            elif "```" in text:
                text = text.split("```")[1].split("```")[0]

            result = json.loads(text.strip())
            return result.get("objective_complete", False)

        except (json.JSONDecodeError, KeyError):
            return False

    def run(self) -> Dict[str, Any]:
        """Ejecuta el bucle principal de BabyAGI."""
        self.running = True
        print(f"üöÄ Iniciando BabyAGI con objetivo: {self.objective}")

        # Crear tareas iniciales
        self._create_initial_tasks()
        print(f"üìã Tareas iniciales creadas: {self.task_queue.get_pending_count()}")

        while self.running and self.iteration < self.max_iterations:
            self.iteration += 1
            print(f"\n{'='*50}")
            print(f"üîÑ Iteraci√≥n {self.iteration}/{self.max_iterations}")

            # Obtener siguiente tarea
            task = self.task_queue.get_next_task()

            if task is None:
                print("‚úÖ No hay m√°s tareas pendientes.")
                break

            print(f"üìå Ejecutando: {task.description}")
            task.status = TaskStatus.IN_PROGRESS

            try:
                # Ejecutar tarea
                result = self._execute_task(task)
                self.task_queue.complete_task(task.task_id, result)
                print(f"‚úÖ Tarea completada")

                # Guardar en memoria
                self.memory.append({
                    "iteration": self.iteration,
                    "task": task.description,
                    "result": result,
                    "timestamp": datetime.now().isoformat()
                })

                # Crear nuevas tareas si es necesario
                self._create_new_tasks(task)

                # Re-priorizar
                if self.task_queue.get_pending_count() > 1:
                    self._prioritize_tasks()

                # Verificar si objetivo est√° completo
                if self._check_objective_complete():
                    print("\nüéâ ¬°Objetivo alcanzado!")
                    break

            except Exception as e:
                self.task_queue.fail_task(task.task_id, str(e))
                print(f"‚ùå Error: {e}")

        self.running = False

        # Generar resumen final
        return self._generate_summary()

    def _generate_summary(self) -> Dict[str, Any]:
        """Genera resumen de la ejecuci√≥n."""
        completed = self.task_queue.get_completed_tasks()
        pending = self.task_queue.get_pending_count()

        return {
            "objective": self.objective,
            "iterations": self.iteration,
            "tasks_completed": len(completed),
            "tasks_pending": pending,
            "task_details": self.task_queue.get_all_tasks_summary(),
            "memory": self.memory
        }

    def stop(self):
        """Detiene la ejecuci√≥n."""
        self.running = False


# Ejemplo de uso
if __name__ == "__main__":
    agent = BabyAGI(
        objective="Crear un plan de contenido para un blog t√©cnico sobre IA",
        max_iterations=5
    )

    result = agent.run()

    print("\n" + "="*50)
    print("üìä RESUMEN DE EJECUCI√ìN")
    print("="*50)
    print(f"Iteraciones: {result['iterations']}")
    print(f"Tareas completadas: {result['tasks_completed']}")
    print(f"Tareas pendientes: {result['tasks_pending']}")
    print(f"\nüìã Estado de tareas:\n{result['task_details']}")
```

## BabyAGI con Memoria Vectorial

```python
"""
BabyAGI mejorado con memoria vectorial para contexto relevante.
"""
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
import numpy as np
import os


class VectorMemory:
    """Memoria vectorial para almacenar y recuperar contexto."""

    def __init__(self, api_key: str = None):
        genai.configure(api_key=api_key or os.getenv("GOOGLE_API_KEY"))
        self.entries: List[Dict[str, Any]] = []
        self.embeddings: List[List[float]] = []

    def _get_embedding(self, text: str) -> List[float]:
        """Obtiene embedding de texto."""
        result = genai.embed_content(
            model="models/text-embedding-004",
            content=text,
            task_type="retrieval_document"
        )
        return result['embedding']

    def add(self, content: str, metadata: Dict[str, Any] = None):
        """Agrega entrada a la memoria."""
        embedding = self._get_embedding(content)
        self.entries.append({
            "content": content,
            "metadata": metadata or {},
            "timestamp": datetime.now().isoformat()
        })
        self.embeddings.append(embedding)

    def search(self, query: str, top_k: int = 5) -> List[Dict[str, Any]]:
        """Busca entradas relevantes."""
        if not self.entries:
            return []

        query_embedding = self._get_embedding(query)

        # Calcular similaridades
        similarities = []
        for i, emb in enumerate(self.embeddings):
            sim = np.dot(query_embedding, emb) / (
                np.linalg.norm(query_embedding) * np.linalg.norm(emb)
            )
            similarities.append((i, sim))

        # Ordenar por similaridad
        similarities.sort(key=lambda x: x[1], reverse=True)

        # Retornar top_k
        results = []
        for idx, sim in similarities[:top_k]:
            entry = self.entries[idx].copy()
            entry["similarity"] = sim
            results.append(entry)

        return results


class EnhancedBabyAGI(BabyAGI):
    """BabyAGI con memoria vectorial mejorada."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.vector_memory = VectorMemory()

    def _execute_task(self, task: Task) -> str:
        """Ejecuta tarea con contexto de memoria vectorial."""
        # Buscar contexto relevante
        relevant_context = self.vector_memory.search(task.description, top_k=3)
        context_text = "\n".join([
            f"- {entry['content'][:300]}..."
            for entry in relevant_context
        ])

        prompt = f"""Eres un agente de ejecuci√≥n con memoria.

OBJETIVO GENERAL: {self.objective}

TAREA ACTUAL: {task.description}

CONTEXTO RELEVANTE DE MEMORIA:
{context_text if context_text else "Sin contexto previo relevante."}

Ejecuta la tarea considerando el contexto. Proporciona un resultado detallado.

RESULTADO:"""

        response = self.model.generate_content(prompt)
        result = response.text

        # Guardar en memoria vectorial
        self.vector_memory.add(
            content=f"Tarea: {task.description}\nResultado: {result}",
            metadata={"task_id": task.task_id, "type": "task_result"}
        )

        return result


class BabyAGIWithTools(EnhancedBabyAGI):
    """BabyAGI con capacidad de usar herramientas."""

    def __init__(self, *args, tools: Dict[str, callable] = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.tools = tools or {}

    def register_tool(self, name: str, func: callable, description: str):
        """Registra una herramienta."""
        self.tools[name] = {
            "function": func,
            "description": description
        }

    def _should_use_tool(self, task: Task) -> Optional[str]:
        """Determina si se debe usar una herramienta."""
        if not self.tools:
            return None

        tools_desc = "\n".join([
            f"- {name}: {info['description']}"
            for name, info in self.tools.items()
        ])

        prompt = f"""Determina si esta tarea requiere una herramienta.

TAREA: {task.description}

HERRAMIENTAS DISPONIBLES:
{tools_desc}

Responde SOLO con JSON:
{{"use_tool": true/false, "tool_name": "nombre" o null, "reason": "raz√≥n"}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            result = json.loads(text.strip())

            if result.get("use_tool") and result.get("tool_name") in self.tools:
                return result["tool_name"]
        except:
            pass

        return None

    def _execute_task(self, task: Task) -> str:
        """Ejecuta tarea, posiblemente usando herramientas."""
        tool_name = self._should_use_tool(task)

        if tool_name:
            try:
                tool_result = self.tools[tool_name]["function"](task.description)
                return f"[Herramienta: {tool_name}]\n{tool_result}"
            except Exception as e:
                return f"[Error en herramienta {tool_name}]: {e}\n" + super()._execute_task(task)

        return super()._execute_task(task)


# Ejemplo de herramientas
def web_search_tool(query: str) -> str:
    """Simula b√∫squeda web."""
    return f"Resultados de b√∫squeda para: {query}\n- Resultado 1\n- Resultado 2\n- Resultado 3"


def calculator_tool(expression: str) -> str:
    """Calculadora simple."""
    try:
        result = eval(expression)
        return f"Resultado: {result}"
    except:
        return "Error en c√°lculo"


# Uso con herramientas
if __name__ == "__main__":
    agent = BabyAGIWithTools(
        objective="Calcular el ROI de una campa√±a de marketing con presupuesto de $10,000",
        max_iterations=5
    )

    agent.register_tool(
        "web_search",
        web_search_tool,
        "Busca informaci√≥n en la web"
    )

    agent.register_tool(
        "calculator",
        calculator_tool,
        "Realiza c√°lculos matem√°ticos"
    )

    result = agent.run()
    print(f"\nüìä Resultado final: {result}")
```

## Variante: CAMEL - Task-Driven con Roles

```python
"""
Implementaci√≥n del patr√≥n CAMEL para tareas con roles.
"""
import google.generativeai as genai
from dataclasses import dataclass
from typing import List, Dict, Any, Optional
import os


@dataclass
class RoleAgent:
    """Agente con rol espec√≠fico."""
    name: str
    role: str
    goal: str
    constraints: List[str]


class CAMELTaskAgent:
    """Agente CAMEL para tareas colaborativas con roles."""

    def __init__(
        self,
        task: str,
        assistant_role: str = "AI Assistant",
        user_role: str = "Human User",
        api_key: str = None
    ):
        genai.configure(api_key=api_key or os.getenv("GOOGLE_API_KEY"))
        self.model = genai.GenerativeModel("gemini-1.5-flash")

        self.task = task
        self.assistant = RoleAgent(
            name="Assistant",
            role=assistant_role,
            goal=f"Ayudar a completar: {task}",
            constraints=["Ser espec√≠fico", "Proponer pasos concretos"]
        )
        self.user = RoleAgent(
            name="User",
            role=user_role,
            goal=f"Guiar hacia: {task}",
            constraints=["Hacer preguntas claras", "Dar feedback"]
        )
        self.conversation_history: List[Dict[str, str]] = []
        self.max_turns = 10

    def _generate_initial_prompt(self) -> str:
        """Genera el prompt inicial para el usuario."""
        return f"""Eres un {self.user.role} que necesita ayuda con: {self.task}

Tu rol es guiar al asistente haciendo preguntas y dando instrucciones claras.
Comienza la conversaci√≥n con tu primera solicitud."""

    def _get_assistant_response(self, user_message: str) -> str:
        """Obtiene respuesta del asistente."""
        history_text = "\n".join([
            f"{msg['role']}: {msg['content']}"
            for msg in self.conversation_history[-6:]
        ])

        prompt = f"""Eres un {self.assistant.role}.
Tu objetivo: {self.assistant.goal}

HISTORIAL DE CONVERSACI√ìN:
{history_text}

MENSAJE DEL USUARIO: {user_message}

Responde de manera √∫til y espec√≠fica:"""

        response = self.model.generate_content(prompt)
        return response.text

    def _get_user_response(self, assistant_message: str) -> str:
        """Simula respuesta del usuario."""
        history_text = "\n".join([
            f"{msg['role']}: {msg['content']}"
            for msg in self.conversation_history[-6:]
        ])

        prompt = f"""Eres un {self.user.role} trabajando en: {self.task}

HISTORIAL:
{history_text}

RESPUESTA DEL ASISTENTE: {assistant_message}

Como usuario, proporciona la siguiente instrucci√≥n o pregunta.
Si la tarea est√° completa, responde con "TAREA_COMPLETADA".

Tu respuesta:"""

        response = self.model.generate_content(prompt)
        return response.text

    def run(self) -> Dict[str, Any]:
        """Ejecuta la conversaci√≥n CAMEL."""
        print(f"üé≠ Iniciando CAMEL - Tarea: {self.task}")
        print(f"   üë§ Usuario: {self.user.role}")
        print(f"   ü§ñ Asistente: {self.assistant.role}")

        # Mensaje inicial del usuario
        initial = self._generate_initial_prompt()
        user_msg = self.model.generate_content(initial).text

        for turn in range(self.max_turns):
            print(f"\n--- Turno {turn + 1} ---")

            # Usuario habla
            self.conversation_history.append({
                "role": "User",
                "content": user_msg
            })
            print(f"üë§ Usuario: {user_msg[:200]}...")

            if "TAREA_COMPLETADA" in user_msg.upper():
                print("\n‚úÖ Tarea completada por el usuario")
                break

            # Asistente responde
            assistant_msg = self._get_assistant_response(user_msg)
            self.conversation_history.append({
                "role": "Assistant",
                "content": assistant_msg
            })
            print(f"ü§ñ Asistente: {assistant_msg[:200]}...")

            # Usuario responde
            user_msg = self._get_user_response(assistant_msg)

        return {
            "task": self.task,
            "turns": len(self.conversation_history) // 2,
            "conversation": self.conversation_history
        }


# Ejemplo de uso
if __name__ == "__main__":
    camel = CAMELTaskAgent(
        task="Dise√±ar una arquitectura de microservicios para e-commerce",
        assistant_role="Arquitecto de Software Senior",
        user_role="Product Manager"
    )

    result = camel.run()
    print(f"\nüìä Conversaci√≥n completada en {result['turns']} turnos")
```

## Ejercicios Pr√°cticos

### Ejercicio 1: BabyAGI con Persistencia
```python
"""
Ejercicio: Agregar persistencia a BabyAGI.
"""
import json

class PersistentBabyAGI(BabyAGI):
    """
    TODO: Implementar:
    1. Guardar estado en archivo JSON al terminar cada iteraci√≥n
    2. Cargar estado al inicializar si existe archivo previo
    3. Permitir reanudar ejecuci√≥n interrumpida
    4. Implementar checkpoints autom√°ticos
    """

    def save_state(self, filepath: str):
        """Guarda estado actual."""
        pass

    def load_state(self, filepath: str) -> bool:
        """Carga estado desde archivo."""
        pass
```

### Ejercicio 2: BabyAGI Multi-Objetivo
```python
"""
Ejercicio: BabyAGI que maneja m√∫ltiples objetivos.
"""

class MultiObjectiveBabyAGI:
    """
    TODO: Implementar:
    1. Lista de objetivos con prioridades
    2. Balanceo de tareas entre objetivos
    3. Detecci√≥n de conflictos entre objetivos
    4. Progreso paralelo en m√∫ltiples objetivos
    """
    pass
```

## Resumen

| Componente | Funci√≥n | Caracter√≠sticas |
|------------|---------|-----------------|
| **TaskQueue** | Gesti√≥n de tareas | Priorizaci√≥n, dependencias, estados |
| **ExecutionAgent** | Ejecutar tareas | Usa LLM para completar trabajo |
| **CreationAgent** | Crear nuevas tareas | Basado en resultados |
| **PrioritizationAgent** | Re-ordenar cola | Optimiza hacia objetivo |
| **VectorMemory** | Contexto relevante | B√∫squeda sem√°ntica de historial |
| **Tools** | Capacidades externas | B√∫squeda, c√°lculos, APIs |

---

**Siguiente:** [8.1.2 AutoGPT Pattern: Goals ‚Üí Tasks ‚Üí Execution](./8.1.2-autogpt-pattern.md)
