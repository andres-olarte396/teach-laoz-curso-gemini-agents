# 8.2.2 Meta-Cognici√≥n: Agentes que Razonan sobre su Razonamiento

## Objetivo de Aprendizaje

Implementar agentes con capacidades meta-cognitivas que pueden monitorear, evaluar y mejorar sus propios procesos de razonamiento, detectando errores y ajustando estrategias en tiempo real usando Google Gemini.

## Introducci√≥n

La meta-cognici√≥n es "pensar sobre el pensamiento". Un agente meta-cognitivo no solo ejecuta tareas, sino que observa c√≥mo las ejecuta, identifica debilidades en su razonamiento y adapta sus estrategias. Esto permite agentes m√°s robustos, auto-correctivos y conscientes de sus limitaciones.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 META-COGNITIVE ARCHITECTURE                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                 ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    META-LEVEL                            ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ MONITOR  ‚îÇ  ‚îÇ EVALUATE ‚îÇ  ‚îÇ REGULATE ‚îÇ               ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ ¬øC√≥mo    ‚îÇ  ‚îÇ ¬øEs bueno‚îÇ  ‚îÇ ¬øC√≥mo    ‚îÇ               ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ razono?  ‚îÇ  ‚îÇ mi       ‚îÇ  ‚îÇ mejoro?  ‚îÇ               ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ          ‚îÇ  ‚îÇ proceso? ‚îÇ  ‚îÇ          ‚îÇ               ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ       ‚îÇ             ‚îÇ             ‚îÇ                      ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                     ‚îÇ                                    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                     v                                    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ       ‚îÇ     META-KNOWLEDGE          ‚îÇ                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ       ‚îÇ  - Estrategias conocidas    ‚îÇ                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ       ‚îÇ  - Fortalezas/debilidades   ‚îÇ                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ       ‚îÇ  - Historial de errores     ‚îÇ                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                          ‚îÇ Control                             ‚îÇ
‚îÇ                          v                                     ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                   OBJECT-LEVEL                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ    ‚îÇ PERCIBE ‚îÇ‚îÄ‚îÄ>‚îÇ RAZONA  ‚îÇ‚îÄ‚îÄ>‚îÇ  ACT√öA  ‚îÇ              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                          ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n del Sistema Meta-Cognitivo

```python
"""
Sistema meta-cognitivo para agentes.
"""
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Callable
from datetime import datetime
from enum import Enum
import json
import os


class ReasoningQuality(Enum):
    """Calidad del razonamiento."""
    EXCELLENT = "excellent"
    GOOD = "good"
    ADEQUATE = "adequate"
    POOR = "poor"
    FLAWED = "flawed"


class CognitiveStrategy(Enum):
    """Estrategias cognitivas disponibles."""
    ANALYTICAL = "analytical"
    CREATIVE = "creative"
    SYSTEMATIC = "systematic"
    HEURISTIC = "heuristic"
    ANALOGICAL = "analogical"
    DECOMPOSITION = "decomposition"


@dataclass
class ReasoningTrace:
    """Traza de un proceso de razonamiento."""
    trace_id: str
    task: str
    steps: List[Dict[str, Any]]
    strategy_used: CognitiveStrategy
    outcome: str
    quality_assessment: Optional[ReasoningQuality] = None
    errors_detected: List[str] = field(default_factory=list)
    improvements_suggested: List[str] = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.now)
    duration_seconds: float = 0.0


@dataclass
class MetaKnowledge:
    """Conocimiento meta-cognitivo del agente."""
    strengths: List[str] = field(default_factory=list)
    weaknesses: List[str] = field(default_factory=list)
    effective_strategies: Dict[str, float] = field(default_factory=dict)
    common_errors: Dict[str, int] = field(default_factory=dict)
    task_type_performance: Dict[str, float] = field(default_factory=dict)


class MetaCognitiveMonitor:
    """Monitor de procesos cognitivos."""

    def __init__(self, api_key: str = None):
        genai.configure(api_key=api_key or os.getenv("GOOGLE_API_KEY"))
        self.model = genai.GenerativeModel("gemini-1.5-flash")

    def observe_reasoning(
        self,
        task: str,
        reasoning_steps: List[str]
    ) -> Dict[str, Any]:
        """Observa y analiza un proceso de razonamiento."""
        steps_text = "\n".join([f"{i+1}. {step}" for i, step in enumerate(reasoning_steps)])

        prompt = f"""Analiza meta-cognitivamente este proceso de razonamiento.

TAREA: {task}

PASOS DE RAZONAMIENTO:
{steps_text}

Eval√∫a como un experto en razonamiento:
1. ¬øEs l√≥gicamente coherente?
2. ¬øHay saltos l√≥gicos?
3. ¬øSe consideraron alternativas?
4. ¬øHay sesgos evidentes?
5. ¬øLa conclusi√≥n se sigue de las premisas?

Responde con JSON:
{{
    "coherence_score": 0.0-1.0,
    "logical_gaps": [
        {{"between_steps": [1, 2], "gap": "descripci√≥n del salto l√≥gico"}}
    ],
    "biases_detected": [
        {{"bias_type": "confirmation|anchoring|availability|etc", "evidence": "..."}}
    ],
    "alternative_paths_missed": ["alternativa no considerada"],
    "strengths": ["fortaleza del razonamiento"],
    "weaknesses": ["debilidad"],
    "overall_quality": "excellent|good|adequate|poor|flawed",
    "confidence_calibration": "overconfident|calibrated|underconfident"
}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            return json.loads(text.strip())
        except:
            return {"overall_quality": "adequate", "coherence_score": 0.5}

    def detect_reasoning_errors(
        self,
        reasoning: str,
        conclusion: str
    ) -> List[Dict[str, Any]]:
        """Detecta errores espec√≠ficos en el razonamiento."""
        prompt = f"""Identifica errores de razonamiento en este an√°lisis.

RAZONAMIENTO:
{reasoning}

CONCLUSI√ìN: {conclusion}

Busca estos tipos de errores:
1. Falacias l√≥gicas (ad hominem, falsa dicotom√≠a, etc.)
2. Errores de inferencia
3. Premisas no fundamentadas
4. Generalizaciones indebidas
5. Confusi√≥n causa-correlaci√≥n
6. Sesgo de confirmaci√≥n

Responde con JSON:
{{
    "errors_found": [
        {{
            "error_type": "tipo de error",
            "location": "d√≥nde en el razonamiento",
            "description": "descripci√≥n del error",
            "severity": "minor|moderate|major|critical",
            "correction": "c√≥mo corregirlo"
        }}
    ],
    "error_count": 0,
    "reasoning_validity": 0.0-1.0
}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            result = json.loads(text.strip())
            return result.get("errors_found", [])
        except:
            return []


class MetaCognitiveEvaluator:
    """Evaluador de calidad del razonamiento."""

    def __init__(self, api_key: str = None):
        genai.configure(api_key=api_key or os.getenv("GOOGLE_API_KEY"))
        self.model = genai.GenerativeModel("gemini-1.5-flash")

    def evaluate_strategy_fit(
        self,
        task: str,
        strategy_used: CognitiveStrategy,
        available_strategies: List[CognitiveStrategy]
    ) -> Dict[str, Any]:
        """Eval√∫a si la estrategia usada fue la mejor opci√≥n."""
        strategies_desc = {
            CognitiveStrategy.ANALYTICAL: "An√°lisis paso a paso, descomposici√≥n en partes",
            CognitiveStrategy.CREATIVE: "Pensamiento lateral, conexiones inesperadas",
            CognitiveStrategy.SYSTEMATIC: "Proceso estructurado, checklist",
            CognitiveStrategy.HEURISTIC: "Reglas de dedo, atajos mentales",
            CognitiveStrategy.ANALOGICAL: "Comparaci√≥n con casos similares",
            CognitiveStrategy.DECOMPOSITION: "Divide y vencer√°s"
        }

        available_text = "\n".join([
            f"- {s.value}: {strategies_desc.get(s, '')}"
            for s in available_strategies
        ])

        prompt = f"""Eval√∫a la elecci√≥n de estrategia cognitiva.

TAREA: {task}

ESTRATEGIA USADA: {strategy_used.value}
Descripci√≥n: {strategies_desc.get(strategy_used, '')}

ESTRATEGIAS DISPONIBLES:
{available_text}

Eval√∫a:
1. ¬øEra la estrategia usada la √≥ptima?
2. ¬øQu√© estrategia hubiera sido mejor?
3. ¬øPor qu√©?

Responde con JSON:
{{
    "strategy_fit_score": 0.0-1.0,
    "was_optimal": true/false,
    "better_strategy": "nombre o null",
    "reasoning": "explicaci√≥n",
    "hybrid_recommendation": ["estrategia1", "estrategia2"] o null
}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            return json.loads(text.strip())
        except:
            return {"strategy_fit_score": 0.5, "was_optimal": True}

    def assess_confidence_calibration(
        self,
        predictions: List[Dict[str, Any]],
        outcomes: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Eval√∫a calibraci√≥n de confianza."""
        pairs = list(zip(predictions, outcomes))
        pairs_text = json.dumps(pairs[:10], indent=2)

        prompt = f"""Analiza la calibraci√≥n de confianza del agente.

PREDICCIONES CON CONFIANZA Y RESULTADOS REALES:
{pairs_text}

Eval√∫a:
1. ¬øLas predicciones de alta confianza fueron correctas?
2. ¬øLas de baja confianza fueron incorrectas?
3. ¬øHay patr√≥n de sobre/sub-confianza?

Responde con JSON:
{{
    "calibration_score": 0.0-1.0,
    "tendency": "overconfident|calibrated|underconfident",
    "high_confidence_accuracy": 0.0-1.0,
    "low_confidence_accuracy": 0.0-1.0,
    "recommendations": ["c√≥mo mejorar calibraci√≥n"]
}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            return json.loads(text.strip())
        except:
            return {"calibration_score": 0.5, "tendency": "calibrated"}


class MetaCognitiveRegulator:
    """Regulador de estrategias cognitivas."""

    def __init__(self, api_key: str = None):
        genai.configure(api_key=api_key or os.getenv("GOOGLE_API_KEY"))
        self.model = genai.GenerativeModel("gemini-1.5-flash")
        self.meta_knowledge = MetaKnowledge()

    def select_strategy(
        self,
        task: str,
        context: Dict[str, Any]
    ) -> CognitiveStrategy:
        """Selecciona la mejor estrategia para una tarea."""
        # Usar meta-conocimiento
        task_type = context.get("task_type", "general")
        past_performance = self.meta_knowledge.task_type_performance.get(task_type, 0.5)
        effective = self.meta_knowledge.effective_strategies

        prompt = f"""Selecciona la mejor estrategia cognitiva para esta tarea.

TAREA: {task}

CONTEXTO:
{json.dumps(context, indent=2)}

META-CONOCIMIENTO:
- Fortalezas: {self.meta_knowledge.strengths}
- Debilidades: {self.meta_knowledge.weaknesses}
- Estrategias efectivas hist√≥ricamente: {effective}
- Performance en este tipo de tarea: {past_performance:.2f}

ESTRATEGIAS DISPONIBLES:
1. analytical - Para problemas estructurados
2. creative - Para problemas abiertos
3. systematic - Para procesos complejos
4. heuristic - Para decisiones r√°pidas
5. analogical - Para problemas similares a otros conocidos
6. decomposition - Para problemas grandes

Responde con JSON:
{{
    "selected_strategy": "nombre",
    "reasoning": "por qu√© esta estrategia",
    "fallback_strategy": "alternativa si falla",
    "confidence": 0.0-1.0
}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            result = json.loads(text.strip())

            strategy_name = result.get("selected_strategy", "analytical")
            return CognitiveStrategy(strategy_name)
        except:
            return CognitiveStrategy.ANALYTICAL

    def adapt_strategy(
        self,
        current_strategy: CognitiveStrategy,
        performance_signal: float,
        context: Dict[str, Any]
    ) -> Optional[CognitiveStrategy]:
        """Adapta estrategia bas√°ndose en se√±ales de rendimiento."""
        if performance_signal > 0.7:
            # Estrategia funcionando bien
            return None

        prompt = f"""La estrategia actual no est√° funcionando bien. Sugiere adaptaci√≥n.

ESTRATEGIA ACTUAL: {current_strategy.value}
SE√ëAL DE RENDIMIENTO: {performance_signal:.2f}

CONTEXTO:
{json.dumps(context, indent=2)}

¬øDeber√≠amos:
1. Cambiar a otra estrategia?
2. Modificar la estrategia actual?
3. Combinar estrategias?

Responde con JSON:
{{
    "recommendation": "switch|modify|combine|persist",
    "new_strategy": "nombre si switch",
    "modification": "descripci√≥n si modify",
    "combine_with": "estrategia si combine",
    "reasoning": "explicaci√≥n"
}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            result = json.loads(text.strip())

            if result.get("recommendation") == "switch":
                new_name = result.get("new_strategy")
                try:
                    return CognitiveStrategy(new_name)
                except:
                    pass

        except:
            pass

        return None

    def update_meta_knowledge(
        self,
        trace: ReasoningTrace,
        success: bool
    ):
        """Actualiza meta-conocimiento bas√°ndose en experiencia."""
        strategy = trace.strategy_used.value

        # Actualizar efectividad de estrategia
        current = self.meta_knowledge.effective_strategies.get(strategy, 0.5)
        update = 0.1 if success else -0.1
        self.meta_knowledge.effective_strategies[strategy] = max(0, min(1, current + update))

        # Registrar errores comunes
        for error in trace.errors_detected:
            count = self.meta_knowledge.common_errors.get(error, 0)
            self.meta_knowledge.common_errors[error] = count + 1


class MetaCognitiveAgent:
    """Agente con capacidades meta-cognitivas completas."""

    def __init__(self, name: str, api_key: str = None):
        self.api_key = api_key or os.getenv("GOOGLE_API_KEY")
        genai.configure(api_key=self.api_key)
        self.model = genai.GenerativeModel("gemini-1.5-flash")

        self.name = name
        self.monitor = MetaCognitiveMonitor(self.api_key)
        self.evaluator = MetaCognitiveEvaluator(self.api_key)
        self.regulator = MetaCognitiveRegulator(self.api_key)

        self.reasoning_history: List[ReasoningTrace] = []
        self.trace_counter = 0

    def think(
        self,
        task: str,
        context: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """Ejecuta razonamiento con monitoreo meta-cognitivo."""
        context = context or {}
        start_time = datetime.now()

        # 1. Seleccionar estrategia
        strategy = self.regulator.select_strategy(task, context)
        print(f"üìã Estrategia seleccionada: {strategy.value}")

        # 2. Ejecutar razonamiento
        reasoning_steps, conclusion = self._execute_reasoning(task, strategy, context)

        # 3. Monitorear razonamiento
        monitoring = self.monitor.observe_reasoning(task, reasoning_steps)
        errors = self.monitor.detect_reasoning_errors(
            "\n".join(reasoning_steps),
            conclusion
        )

        # 4. Evaluar calidad
        quality = ReasoningQuality(monitoring.get("overall_quality", "adequate"))

        # 5. Crear traza
        self.trace_counter += 1
        trace = ReasoningTrace(
            trace_id=f"trace_{self.trace_counter}",
            task=task,
            steps=[{"step": s} for s in reasoning_steps],
            strategy_used=strategy,
            outcome=conclusion,
            quality_assessment=quality,
            errors_detected=[e.get("error_type", "") for e in errors],
            improvements_suggested=monitoring.get("alternative_paths_missed", []),
            duration_seconds=(datetime.now() - start_time).total_seconds()
        )
        self.reasoning_history.append(trace)

        # 6. Si calidad baja, intentar auto-correcci√≥n
        if quality in [ReasoningQuality.POOR, ReasoningQuality.FLAWED]:
            print("‚ö†Ô∏è Razonamiento de baja calidad detectado. Intentando auto-correcci√≥n...")
            conclusion, reasoning_steps = self._self_correct(
                task, conclusion, reasoning_steps, errors, strategy
            )

        return {
            "conclusion": conclusion,
            "reasoning_steps": reasoning_steps,
            "strategy_used": strategy.value,
            "quality": quality.value,
            "errors_detected": len(errors),
            "trace_id": trace.trace_id
        }

    def _execute_reasoning(
        self,
        task: str,
        strategy: CognitiveStrategy,
        context: Dict[str, Any]
    ) -> tuple:
        """Ejecuta el razonamiento seg√∫n la estrategia."""
        strategy_prompts = {
            CognitiveStrategy.ANALYTICAL: "Analiza paso a paso, descomponiendo en partes.",
            CognitiveStrategy.CREATIVE: "Piensa lateralmente, busca conexiones inusuales.",
            CognitiveStrategy.SYSTEMATIC: "Sigue un proceso estructurado y met√≥dico.",
            CognitiveStrategy.HEURISTIC: "Usa reglas de dedo y atajos mentales.",
            CognitiveStrategy.ANALOGICAL: "Busca analog√≠as con situaciones conocidas.",
            CognitiveStrategy.DECOMPOSITION: "Divide el problema en subproblemas."
        }

        prompt = f"""Razona sobre esta tarea usando estrategia {strategy.value}.

TAREA: {task}

CONTEXTO:
{json.dumps(context, indent=2)}

INSTRUCCI√ìN DE ESTRATEGIA: {strategy_prompts.get(strategy, '')}

Proporciona tu razonamiento paso a paso, luego la conclusi√≥n.

FORMATO:
PASO 1: ...
PASO 2: ...
PASO 3: ...
...
CONCLUSI√ìN: ..."""

        response = self.model.generate_content(prompt)
        text = response.text

        # Parsear pasos y conclusi√≥n
        lines = text.split("\n")
        steps = []
        conclusion = ""

        for line in lines:
            line = line.strip()
            if line.startswith("PASO"):
                steps.append(line.split(":", 1)[-1].strip())
            elif line.startswith("CONCLUSI√ìN"):
                conclusion = line.split(":", 1)[-1].strip()

        if not conclusion:
            conclusion = lines[-1] if lines else "Sin conclusi√≥n"

        return steps, conclusion

    def _self_correct(
        self,
        task: str,
        original_conclusion: str,
        original_steps: List[str],
        errors: List[Dict[str, Any]],
        strategy: CognitiveStrategy
    ) -> tuple:
        """Intenta auto-corregir razonamiento defectuoso."""
        errors_text = "\n".join([
            f"- {e.get('error_type', '')}: {e.get('description', '')} ‚Üí Correcci√≥n: {e.get('correction', '')}"
            for e in errors
        ])

        prompt = f"""Tu razonamiento anterior ten√≠a errores. Corr√≠gelo.

TAREA ORIGINAL: {task}

RAZONAMIENTO ORIGINAL:
{chr(10).join(original_steps)}

CONCLUSI√ìN ORIGINAL: {original_conclusion}

ERRORES DETECTADOS:
{errors_text}

Proporciona un razonamiento corregido que evite estos errores.

FORMATO:
PASO CORREGIDO 1: ...
PASO CORREGIDO 2: ...
...
CONCLUSI√ìN CORREGIDA: ..."""

        response = self.model.generate_content(prompt)
        text = response.text

        # Parsear respuesta corregida
        lines = text.split("\n")
        new_steps = []
        new_conclusion = ""

        for line in lines:
            line = line.strip()
            if "PASO" in line:
                new_steps.append(line.split(":", 1)[-1].strip())
            elif "CONCLUSI√ìN" in line:
                new_conclusion = line.split(":", 1)[-1].strip()

        if not new_conclusion:
            new_conclusion = original_conclusion

        return new_conclusion, new_steps

    def reflect(self) -> Dict[str, Any]:
        """Reflexiona sobre el rendimiento cognitivo."""
        if not self.reasoning_history:
            return {"message": "Sin historial para reflexionar"}

        # Analizar historial
        qualities = [t.quality_assessment.value for t in self.reasoning_history if t.quality_assessment]
        strategies = [t.strategy_used.value for t in self.reasoning_history]
        all_errors = []
        for t in self.reasoning_history:
            all_errors.extend(t.errors_detected)

        # Contar
        from collections import Counter
        quality_counts = Counter(qualities)
        strategy_counts = Counter(strategies)
        error_counts = Counter(all_errors)

        prompt = f"""Reflexiona sobre tu rendimiento cognitivo.

HISTORIAL:
- Total de razonamientos: {len(self.reasoning_history)}
- Distribuci√≥n de calidad: {dict(quality_counts)}
- Estrategias usadas: {dict(strategy_counts)}
- Errores frecuentes: {dict(error_counts.most_common(5))}

Genera una reflexi√≥n meta-cognitiva:
1. ¬øCu√°les son mis patrones de razonamiento?
2. ¬øD√≥nde cometo errores recurrentes?
3. ¬øQu√© estrategias me funcionan mejor?
4. ¬øC√≥mo puedo mejorar?

REFLEXI√ìN:"""

        response = self.model.generate_content(prompt)

        return {
            "total_reasonings": len(self.reasoning_history),
            "quality_distribution": dict(quality_counts),
            "strategy_usage": dict(strategy_counts),
            "common_errors": dict(error_counts.most_common(5)),
            "reflection": response.text
        }


# Ejemplo de uso
if __name__ == "__main__":
    agent = MetaCognitiveAgent(name="MetaBot")

    # Ejecutar varios razonamientos
    tasks = [
        "¬øDeber√≠a una empresa invertir en IA generativa?",
        "¬øCu√°l es la mejor estrategia para reducir costos operativos?",
        "¬øC√≥mo mejorar la retenci√≥n de empleados?"
    ]

    for task in tasks:
        print(f"\n{'='*50}")
        print(f"üìù Tarea: {task}")
        print("="*50)

        result = agent.think(task, {"domain": "business"})

        print(f"\n‚úÖ Conclusi√≥n: {result['conclusion'][:200]}...")
        print(f"üìä Calidad: {result['quality']}")
        print(f"‚ö†Ô∏è Errores detectados: {result['errors_detected']}")

    # Reflexi√≥n final
    print("\n" + "="*50)
    print("üîç REFLEXI√ìN META-COGNITIVA")
    print("="*50)
    reflection = agent.reflect()
    print(reflection["reflection"])
```

## Ejercicios Pr√°cticos

### Ejercicio 1: Detector de Sesgos Cognitivos
```python
"""
Ejercicio: Sistema de detecci√≥n de sesgos.
"""

class CognitiveBiasDetector:
    """
    TODO: Implementar detector que identifique:
    1. Sesgo de confirmaci√≥n
    2. Efecto ancla
    3. Sesgo de disponibilidad
    4. Exceso de confianza
    5. Sesgo de retrospectiva
    """

    def detect_biases(
        self,
        reasoning: str,
        context: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        pass
```

### Ejercicio 2: Sistema de Confianza Calibrada
```python
"""
Ejercicio: Calibrar confianza del agente.
"""

class ConfidenceCalibrator:
    """
    TODO: Implementar sistema que:
    1. Rastree precisi√≥n hist√≥rica por nivel de confianza
    2. Ajuste confianza bas√°ndose en calibraci√≥n
    3. Proporcione intervalos de confianza
    4. Detecte sobre/sub-confianza sistem√°tica
    """

    def calibrate(self, raw_confidence: float) -> float:
        pass

    def get_confidence_interval(
        self,
        prediction: Any,
        raw_confidence: float
    ) -> Tuple[float, float]:
        pass
```

## Resumen

| Componente | Funci√≥n | Nivel Meta-Cognitivo |
|------------|---------|---------------------|
| **Monitor** | Observa procesos | Meta-atenci√≥n |
| **Evaluator** | Juzga calidad | Meta-evaluaci√≥n |
| **Regulator** | Ajusta estrategias | Meta-control |
| **Self-Correction** | Corrige errores | Meta-aprendizaje |
| **Reflection** | Analiza patrones | Meta-conciencia |

---

**Siguiente:** [8.2.3 Manejo de Incertidumbre](./8.2.3-manejo-incertidumbre.md)
