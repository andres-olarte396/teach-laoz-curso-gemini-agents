# 8.2.3 Manejo de Incertidumbre

## Objetivo de Aprendizaje

Implementar agentes que manejan la incertidumbre de forma explícita, cuantificando confianza, propagando incertidumbre a través de decisiones y tomando acciones robustas ante información incompleta usando Google Gemini.

## Introducción

Los agentes del mundo real operan con información incompleta, ruidosa y ambigua. Un agente robusto debe reconocer qué no sabe, cuantificar su incertidumbre, y tomar decisiones que sean robustas ante múltiples escenarios posibles.

```
┌─────────────────────────────────────────────────────────────────┐
│                UNCERTAINTY MANAGEMENT FRAMEWORK                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   TIPOS DE INCERTIDUMBRE:                                      │
│                                                                 │
│   ┌─────────────────┐  ┌─────────────────┐  ┌────────────────┐ │
│   │   EPISTÉMICA    │  │   ALEATORIA     │  │  LINGÜÍSTICA   │ │
│   │   (Ignorancia)  │  │   (Variabilidad)│  │  (Ambigüedad)  │ │
│   │                 │  │                 │  │                │ │
│   │   Reducible     │  │   Irreducible   │  │  Interpretable │ │
│   │   con más datos │  │   inherente     │  │  con contexto  │ │
│   └────────┬────────┘  └────────┬────────┘  └───────┬────────┘ │
│            │                    │                    │          │
│            └────────────────────┼────────────────────┘          │
│                                 │                               │
│                                 v                               │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │              UNCERTAINTY QUANTIFICATION                 │  │
│   │                                                          │  │
│   │   P(outcome) = 0.7 ± 0.15                               │  │
│   │   [──────────●───────]                                  │  │
│   │         0.55     0.85                                   │  │
│   │                                                          │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                 │                               │
│                                 v                               │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │              DECISION UNDER UNCERTAINTY                 │  │
│   │                                                          │  │
│   │   - Expected Value maximization                         │  │
│   │   - Minimax (minimize worst case)                       │  │
│   │   - Maximin (maximize minimum gain)                     │  │
│   │   - Satisficing (good enough)                           │  │
│   │                                                          │  │
│   └─────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

## Sistema de Cuantificación de Incertidumbre

```python
"""
Sistema de manejo de incertidumbre para agentes.
"""
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Tuple, Union
from datetime import datetime
from enum import Enum
import json
import os
import numpy as np
from scipy import stats


class UncertaintyType(Enum):
    """Tipos de incertidumbre."""
    EPISTEMIC = "epistemic"  # Falta de conocimiento
    ALEATORIC = "aleatoric"  # Variabilidad inherente
    LINGUISTIC = "linguistic"  # Ambigüedad del lenguaje
    MODEL = "model"  # Incertidumbre del modelo
    MEASUREMENT = "measurement"  # Error de medición


@dataclass
class UncertainValue:
    """Valor con incertidumbre asociada."""
    mean: float
    std: float
    confidence_level: float = 0.95
    distribution: str = "normal"
    uncertainty_type: UncertaintyType = UncertaintyType.EPISTEMIC

    @property
    def confidence_interval(self) -> Tuple[float, float]:
        """Calcula intervalo de confianza."""
        if self.distribution == "normal":
            z = stats.norm.ppf((1 + self.confidence_level) / 2)
            margin = z * self.std
            return (self.mean - margin, self.mean + margin)
        return (self.mean - 2*self.std, self.mean + 2*self.std)

    @property
    def coefficient_of_variation(self) -> float:
        """Coeficiente de variación (incertidumbre relativa)."""
        if self.mean == 0:
            return float('inf')
        return abs(self.std / self.mean)

    def is_high_uncertainty(self, threshold: float = 0.3) -> bool:
        """Determina si la incertidumbre es alta."""
        return self.coefficient_of_variation > threshold

    def sample(self, n: int = 1) -> np.ndarray:
        """Genera muestras de la distribución."""
        if self.distribution == "normal":
            return np.random.normal(self.mean, self.std, n)
        elif self.distribution == "uniform":
            low, high = self.confidence_interval
            return np.random.uniform(low, high, n)
        return np.array([self.mean] * n)


@dataclass
class BeliefState:
    """Estado de creencias con incertidumbre."""
    beliefs: Dict[str, UncertainValue]
    timestamp: datetime = field(default_factory=datetime.now)

    def get_belief(self, key: str) -> Optional[UncertainValue]:
        return self.beliefs.get(key)

    def update_belief(
        self,
        key: str,
        observation: float,
        observation_uncertainty: float = 0.1
    ):
        """Actualiza creencia con nueva observación (filtro Bayesiano simple)."""
        if key not in self.beliefs:
            self.beliefs[key] = UncertainValue(mean=observation, std=observation_uncertainty)
            return

        prior = self.beliefs[key]

        # Actualización Bayesiana (asumiendo normal)
        prior_precision = 1 / (prior.std ** 2)
        obs_precision = 1 / (observation_uncertainty ** 2)

        posterior_precision = prior_precision + obs_precision
        posterior_mean = (prior_precision * prior.mean + obs_precision * observation) / posterior_precision
        posterior_std = np.sqrt(1 / posterior_precision)

        self.beliefs[key] = UncertainValue(
            mean=posterior_mean,
            std=posterior_std,
            uncertainty_type=prior.uncertainty_type
        )

    def get_most_uncertain(self, n: int = 3) -> List[Tuple[str, float]]:
        """Obtiene las creencias más inciertas."""
        uncertainties = [
            (key, val.coefficient_of_variation)
            for key, val in self.beliefs.items()
        ]
        return sorted(uncertainties, key=lambda x: x[1], reverse=True)[:n]


class UncertaintyQuantifier:
    """Cuantificador de incertidumbre usando LLM."""

    def __init__(self, api_key: str = None):
        genai.configure(api_key=api_key or os.getenv("GOOGLE_API_KEY"))
        self.model = genai.GenerativeModel("gemini-1.5-flash")

    def estimate_uncertainty(
        self,
        statement: str,
        context: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """Estima incertidumbre de una afirmación."""
        prompt = f"""Evalúa la incertidumbre asociada con esta afirmación.

AFIRMACIÓN: {statement}

CONTEXTO:
{json.dumps(context or {}, indent=2)}

Considera:
1. ¿Cuánta evidencia soporta esta afirmación?
2. ¿Hay fuentes contradictorias?
3. ¿Es verificable?
4. ¿Qué tan precisa es la información disponible?

Responde con JSON:
{{
    "confidence": 0.0-1.0,
    "uncertainty_std": 0.0-0.5,
    "uncertainty_type": "epistemic|aleatoric|linguistic|model",
    "sources_of_uncertainty": ["fuente1", "fuente2"],
    "what_would_reduce_uncertainty": ["acción1", "acción2"],
    "worst_case_if_wrong": "descripción del peor caso",
    "best_case_if_right": "descripción del mejor caso"
}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            return json.loads(text.strip())
        except:
            return {"confidence": 0.5, "uncertainty_std": 0.25}

    def decompose_uncertainty(
        self,
        prediction: str,
        components: List[str]
    ) -> Dict[str, UncertainValue]:
        """Descompone incertidumbre en componentes."""
        prompt = f"""Descompón la incertidumbre de esta predicción en sus componentes.

PREDICCIÓN: {prediction}

COMPONENTES A EVALUAR:
{json.dumps(components, indent=2)}

Para cada componente, estima:
- Contribución a la incertidumbre total (0-1)
- Tipo de incertidumbre
- Potencial de reducción

Responde con JSON:
{{
    "components": [
        {{
            "name": "componente",
            "uncertainty_contribution": 0.0-1.0,
            "type": "epistemic|aleatoric",
            "reducible": true/false,
            "reduction_method": "cómo reducir"
        }}
    ],
    "total_uncertainty": 0.0-1.0,
    "dominant_source": "componente dominante"
}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            result = json.loads(text.strip())

            uncertainties = {}
            for comp in result.get("components", []):
                name = comp.get("name", "unknown")
                contribution = comp.get("uncertainty_contribution", 0.5)
                utype = UncertaintyType(comp.get("type", "epistemic"))

                uncertainties[name] = UncertainValue(
                    mean=0.5,  # Neutral
                    std=contribution * 0.5,
                    uncertainty_type=utype
                )

            return uncertainties

        except:
            return {}


class UncertaintyPropagator:
    """Propaga incertidumbre a través de cálculos."""

    @staticmethod
    def propagate_linear(
        coefficients: List[float],
        values: List[UncertainValue]
    ) -> UncertainValue:
        """Propaga incertidumbre en combinación lineal."""
        if len(coefficients) != len(values):
            raise ValueError("Dimensiones no coinciden")

        mean = sum(c * v.mean for c, v in zip(coefficients, values))
        variance = sum((c * v.std) ** 2 for c, v in zip(coefficients, values))

        return UncertainValue(mean=mean, std=np.sqrt(variance))

    @staticmethod
    def propagate_product(
        values: List[UncertainValue]
    ) -> UncertainValue:
        """Propaga incertidumbre en producto."""
        mean = np.prod([v.mean for v in values])

        # Aproximación para coeficiente de variación del producto
        cv_squared = sum(v.coefficient_of_variation ** 2 for v in values)
        std = abs(mean) * np.sqrt(cv_squared)

        return UncertainValue(mean=mean, std=std)

    @staticmethod
    def monte_carlo_propagate(
        function: callable,
        input_values: Dict[str, UncertainValue],
        n_samples: int = 10000
    ) -> UncertainValue:
        """Propaga incertidumbre usando Monte Carlo."""
        samples = {
            key: val.sample(n_samples)
            for key, val in input_values.items()
        }

        # Evaluar función para cada conjunto de muestras
        results = []
        for i in range(n_samples):
            input_sample = {key: samples[key][i] for key in samples}
            results.append(function(**input_sample))

        results = np.array(results)

        return UncertainValue(
            mean=np.mean(results),
            std=np.std(results)
        )


class DecisionUnderUncertainty:
    """Toma de decisiones bajo incertidumbre."""

    def __init__(self, api_key: str = None):
        genai.configure(api_key=api_key or os.getenv("GOOGLE_API_KEY"))
        self.model = genai.GenerativeModel("gemini-1.5-flash")

    def expected_value_decision(
        self,
        options: Dict[str, List[Tuple[float, float]]]  # {opción: [(prob, valor)]}
    ) -> Tuple[str, float]:
        """Decisión por valor esperado."""
        expected_values = {}

        for option, outcomes in options.items():
            ev = sum(prob * value for prob, value in outcomes)
            expected_values[option] = ev

        best_option = max(expected_values, key=expected_values.get)
        return best_option, expected_values[best_option]

    def minimax_decision(
        self,
        options: Dict[str, List[float]]  # {opción: [posibles valores]}
    ) -> Tuple[str, float]:
        """Decisión minimax (minimizar el peor caso)."""
        worst_cases = {}

        for option, values in options.items():
            worst_cases[option] = min(values)

        best_option = max(worst_cases, key=worst_cases.get)
        return best_option, worst_cases[best_option]

    def maximin_regret_decision(
        self,
        options: Dict[str, Dict[str, float]]  # {opción: {escenario: valor}}
    ) -> Tuple[str, float]:
        """Decisión minimizando arrepentimiento máximo."""
        scenarios = set()
        for outcomes in options.values():
            scenarios.update(outcomes.keys())

        # Calcular mejor resultado por escenario
        best_per_scenario = {}
        for scenario in scenarios:
            best_per_scenario[scenario] = max(
                opts.get(scenario, float('-inf'))
                for opts in options.values()
            )

        # Calcular arrepentimiento por opción
        max_regrets = {}
        for option, outcomes in options.items():
            regrets = []
            for scenario in scenarios:
                best = best_per_scenario[scenario]
                actual = outcomes.get(scenario, float('-inf'))
                regrets.append(best - actual)
            max_regrets[option] = max(regrets)

        best_option = min(max_regrets, key=max_regrets.get)
        return best_option, max_regrets[best_option]

    def robust_decision(
        self,
        options: List[str],
        scenarios: List[Dict[str, Any]],
        scenario_probabilities: List[float] = None
    ) -> Dict[str, Any]:
        """Toma decisión robusta considerando múltiples escenarios."""
        if scenario_probabilities is None:
            scenario_probabilities = [1/len(scenarios)] * len(scenarios)

        prompt = f"""Evalúa estas opciones bajo incertidumbre.

OPCIONES DISPONIBLES:
{json.dumps(options, indent=2)}

ESCENARIOS POSIBLES (con probabilidades):
{json.dumps(list(zip(scenarios, scenario_probabilities)), indent=2)}

Para cada combinación opción-escenario, evalúa el resultado esperado.
Luego recomienda la opción más robusta.

Responde con JSON:
{{
    "evaluation_matrix": {{
        "opcion1": {{
            "escenario1": {{"outcome": 0-10, "reasoning": "..."}},
            "escenario2": {{"outcome": 0-10, "reasoning": "..."}}
        }}
    }},
    "expected_values": {{"opcion1": valor, "opcion2": valor}},
    "worst_cases": {{"opcion1": valor, "opcion2": valor}},
    "recommended_option": "opción",
    "recommendation_reasoning": "por qué es robusta",
    "risk_level": "low|medium|high"
}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            return json.loads(text.strip())
        except:
            return {"recommended_option": options[0], "risk_level": "high"}


class UncertaintyAwareAgent:
    """Agente que maneja incertidumbre explícitamente."""

    def __init__(self, name: str, api_key: str = None):
        self.api_key = api_key or os.getenv("GOOGLE_API_KEY")
        genai.configure(api_key=self.api_key)
        self.model = genai.GenerativeModel("gemini-1.5-flash")

        self.name = name
        self.quantifier = UncertaintyQuantifier(self.api_key)
        self.decision_maker = DecisionUnderUncertainty(self.api_key)
        self.belief_state = BeliefState(beliefs={})
        self.uncertainty_history: List[Dict[str, Any]] = []

    def assess_situation(
        self,
        observations: Dict[str, Any]
    ) -> Dict[str, UncertainValue]:
        """Evalúa situación cuantificando incertidumbre."""
        assessments = {}

        for key, value in observations.items():
            if isinstance(value, (int, float)):
                # Valor numérico - estimar incertidumbre
                estimate = self.quantifier.estimate_uncertainty(
                    f"{key} = {value}",
                    {"observation_type": "numeric"}
                )
                assessments[key] = UncertainValue(
                    mean=value,
                    std=value * estimate.get("uncertainty_std", 0.1),
                    uncertainty_type=UncertaintyType(
                        estimate.get("uncertainty_type", "epistemic")
                    )
                )
            else:
                # Valor cualitativo
                estimate = self.quantifier.estimate_uncertainty(
                    f"{key}: {value}",
                    {"observation_type": "qualitative"}
                )
                assessments[key] = UncertainValue(
                    mean=estimate.get("confidence", 0.5),
                    std=estimate.get("uncertainty_std", 0.2)
                )

        return assessments

    def decide_with_uncertainty(
        self,
        goal: str,
        options: List[str],
        current_beliefs: Dict[str, UncertainValue]
    ) -> Dict[str, Any]:
        """Toma decisión considerando incertidumbre."""
        # Identificar creencias más inciertas
        belief_summary = {
            key: {"mean": v.mean, "std": v.std, "cv": v.coefficient_of_variation}
            for key, v in current_beliefs.items()
        }

        high_uncertainty = [
            key for key, v in current_beliefs.items()
            if v.is_high_uncertainty()
        ]

        prompt = f"""Toma una decisión considerando la incertidumbre explícitamente.

META: {goal}

OPCIONES:
{json.dumps(options, indent=2)}

ESTADO DE CREENCIAS (con incertidumbre):
{json.dumps(belief_summary, indent=2)}

CREENCIAS CON ALTA INCERTIDUMBRE:
{high_uncertainty}

Considera:
1. ¿Qué opción es más robusta ante la incertidumbre?
2. ¿Vale la pena reducir incertidumbre antes de decidir?
3. ¿Hay opciones que minimizan el riesgo de pérdida?

Responde con JSON:
{{
    "recommended_option": "opción",
    "confidence_in_decision": 0.0-1.0,
    "decision_strategy": "expected_value|minimax|maximin|satisficing",
    "key_uncertainties_affecting_decision": ["creencia1", "creencia2"],
    "value_of_information": {{
        "gathering_more_info": "worth_it|not_worth_it|depends",
        "what_info_would_help": ["info1", "info2"],
        "expected_improvement": 0.0-1.0
    }},
    "contingency_plan": "qué hacer si la opción falla",
    "reasoning": "explicación completa"
}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            result = json.loads(text.strip())

            # Registrar decisión
            self.uncertainty_history.append({
                "goal": goal,
                "decision": result,
                "belief_state": belief_summary,
                "timestamp": datetime.now().isoformat()
            })

            return result

        except:
            return {
                "recommended_option": options[0],
                "confidence_in_decision": 0.5,
                "reasoning": "Decisión por defecto ante error"
            }

    def reduce_uncertainty(
        self,
        target_belief: str,
        available_actions: List[str]
    ) -> Dict[str, Any]:
        """Planifica cómo reducir incertidumbre."""
        current = self.belief_state.get_belief(target_belief)

        prompt = f"""Planifica cómo reducir la incertidumbre sobre: {target_belief}

ESTADO ACTUAL:
- Media estimada: {current.mean if current else 'desconocido'}
- Desviación estándar: {current.std if current else 'alta'}
- Tipo de incertidumbre: {current.uncertainty_type.value if current else 'epistémica'}

ACCIONES DISPONIBLES:
{json.dumps(available_actions, indent=2)}

Responde con JSON:
{{
    "best_action": "acción",
    "expected_reduction": 0.0-1.0,
    "cost_of_action": "bajo|medio|alto",
    "alternative_actions": ["acción2", "acción3"],
    "irreducible_component": 0.0-1.0,
    "reasoning": "explicación"
}}"""

        response = self.model.generate_content(prompt)

        try:
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            return json.loads(text.strip())
        except:
            return {"best_action": available_actions[0] if available_actions else None}


# Ejemplo de uso
if __name__ == "__main__":
    agent = UncertaintyAwareAgent(name="UncertainBot")

    # Escenario de inversión
    observations = {
        "market_growth": 0.05,
        "competitor_threat": "medium",
        "technology_readiness": 0.7,
        "team_capability": 0.8
    }

    # Evaluar situación
    print("=== EVALUACIÓN CON INCERTIDUMBRE ===")
    assessments = agent.assess_situation(observations)

    for key, val in assessments.items():
        ci = val.confidence_interval
        print(f"{key}: {val.mean:.3f} ± {val.std:.3f} (CI: [{ci[0]:.3f}, {ci[1]:.3f}])")
        if val.is_high_uncertainty():
            print(f"   ⚠️ Alta incertidumbre!")

    # Actualizar belief state
    for key, val in assessments.items():
        agent.belief_state.beliefs[key] = val

    # Tomar decisión
    print("\n=== DECISIÓN BAJO INCERTIDUMBRE ===")
    decision = agent.decide_with_uncertainty(
        goal="Maximizar ROI de inversión en tecnología",
        options=[
            "Invertir ahora",
            "Esperar 6 meses",
            "Invertir parcialmente",
            "No invertir"
        ],
        current_beliefs=assessments
    )

    print(f"Opción recomendada: {decision.get('recommended_option')}")
    print(f"Confianza: {decision.get('confidence_in_decision', 0):.2f}")
    print(f"Estrategia: {decision.get('decision_strategy')}")
    print(f"\nRazonamiento: {decision.get('reasoning', '')[:300]}...")
```

## Ejercicios Prácticos

### Ejercicio 1: Sistema de Alerta de Incertidumbre
```python
"""
Ejercicio: Sistema que alerta sobre incertidumbre crítica.
"""

class UncertaintyAlertSystem:
    """
    TODO: Implementar sistema que:
    1. Monitoree incertidumbre en tiempo real
    2. Genere alertas cuando supere umbrales
    3. Priorice qué incertidumbres reducir
    4. Sugiera acciones de mitigación
    """

    def monitor(self, belief_state: BeliefState) -> List[Dict[str, Any]]:
        """Genera alertas de incertidumbre."""
        pass

    def prioritize_reduction(
        self,
        uncertainties: Dict[str, UncertainValue]
    ) -> List[str]:
        """Prioriza qué incertidumbres reducir."""
        pass
```

### Ejercicio 2: Ensemble de Predicciones
```python
"""
Ejercicio: Combinar múltiples predicciones con incertidumbre.
"""

class PredictionEnsemble:
    """
    TODO: Implementar ensemble que:
    1. Combine predicciones de múltiples fuentes
    2. Pondere por confianza histórica
    3. Cuantifique incertidumbre del ensemble
    4. Detecte desacuerdos significativos
    """

    def combine(
        self,
        predictions: List[Dict[str, UncertainValue]]
    ) -> Dict[str, UncertainValue]:
        """Combina predicciones."""
        pass
```

## Resumen

| Componente | Función | Métrica Clave |
|------------|---------|---------------|
| **UncertainValue** | Valor con incertidumbre | Media ± Std |
| **BeliefState** | Estado de creencias | Coeficiente de variación |
| **UncertaintyQuantifier** | Cuantifica incertidumbre | Intervalo de confianza |
| **DecisionUnderUncertainty** | Decisiones robustas | Valor esperado, Minimax |
| **UncertaintyPropagation** | Propaga incertidumbre | Monte Carlo |

---

**Siguiente Módulo:** [Módulo 9: Evaluación y Testing de Agentes](../modulo_9/README.md)
