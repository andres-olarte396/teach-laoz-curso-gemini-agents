# Herramientas de Ejecución de Código

**Tiempo estimado**: 50 minutos
**Nivel**: Avanzado
**Prerrequisitos**: Herramientas de Búsqueda y Retrieval (3.2.2)

## ¿Por qué importa este concepto?

La capacidad de ejecutar código transforma a los agentes de asistentes pasivos a actores que pueden:

- Realizar cálculos complejos y precisos
- Procesar y transformar datos
- Interactuar con sistemas y APIs
- Automatizar tareas repetitivas
- Validar hipótesis mediante experimentación

Esta capacidad es fundamental para agentes de análisis de datos, desarrollo de software y automatización.

---

## Consideraciones de seguridad

```
┌─────────────────────────────────────────────────────────────────┐
│ ⚠️ RIESGOS DE EJECUCIÓN DE CÓDIGO                               │
│ ─────────────────────────────────                               │
│                                                                 │
│ 1. EJECUCIÓN MALICIOSA                                          │
│    - Código que daña el sistema                                 │
│    - Acceso no autorizado a recursos                            │
│    - Exfiltración de datos                                      │
│                                                                 │
│ 2. CONSUMO DE RECURSOS                                          │
│    - Bucles infinitos                                           │
│    - Uso excesivo de memoria/CPU                                │
│    - Operaciones de I/O costosas                                │
│                                                                 │
│ 3. EFECTOS SECUNDARIOS                                          │
│    - Modificación de archivos                                   │
│    - Conexiones de red no deseadas                              │
│    - Instalación de paquetes                                    │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│ ✓ MITIGACIONES                                                  │
│ ──────────────                                                  │
│                                                                 │
│ • Sandboxing (contenedores, VMs)                                │
│ • Timeouts estrictos                                            │
│ • Límites de recursos                                           │
│ • Whitelist de operaciones permitidas                           │
│ • Revisión de código antes de ejecución                         │
│ • Logging exhaustivo                                            │
└─────────────────────────────────────────────────────────────────┘
```

---

## Implementación práctica

### Sandbox básico con restricciones

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, Set
import sys
import io
import traceback
import ast
import time
import signal
from contextlib import contextmanager
from functools import wraps


@dataclass
class ExecutionResult:
    """Resultado de ejecución de código."""
    success: bool
    output: str = ""
    error: str = ""
    return_value: Any = None
    execution_time: float = 0.0
    memory_used: int = 0


@dataclass
class SandboxConfig:
    """Configuración del sandbox."""
    timeout_seconds: float = 5.0
    max_output_length: int = 10000
    allowed_imports: Set[str] = field(default_factory=lambda: {
        'math', 'random', 'datetime', 'json', 're', 'collections',
        'itertools', 'functools', 'statistics', 'decimal', 'fractions'
    })
    blocked_builtins: Set[str] = field(default_factory=lambda: {
        'eval', 'exec', 'compile', 'open', 'input', '__import__',
        'globals', 'locals', 'vars', 'dir', 'getattr', 'setattr',
        'delattr', 'hasattr'
    })
    allowed_builtins: Set[str] = field(default_factory=lambda: {
        'abs', 'all', 'any', 'bin', 'bool', 'chr', 'dict', 'divmod',
        'enumerate', 'filter', 'float', 'format', 'frozenset', 'hex',
        'int', 'isinstance', 'issubclass', 'iter', 'len', 'list',
        'map', 'max', 'min', 'next', 'oct', 'ord', 'pow', 'print',
        'range', 'repr', 'reversed', 'round', 'set', 'slice', 'sorted',
        'str', 'sum', 'tuple', 'type', 'zip'
    })


class CodeValidator:
    """Valida código antes de ejecución."""

    def __init__(self, config: SandboxConfig):
        self.config = config
        self.violations: List[str] = []

    def validate(self, code: str) -> bool:
        """Valida que el código sea seguro."""
        self.violations = []

        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            self.violations.append(f"Syntax error: {e}")
            return False

        # Verificar imports
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    if alias.name not in self.config.allowed_imports:
                        self.violations.append(f"Blocked import: {alias.name}")

            elif isinstance(node, ast.ImportFrom):
                if node.module and node.module.split('.')[0] not in self.config.allowed_imports:
                    self.violations.append(f"Blocked import: {node.module}")

            # Verificar llamadas a funciones peligrosas
            elif isinstance(node, ast.Call):
                if isinstance(node.func, ast.Name):
                    if node.func.id in self.config.blocked_builtins:
                        self.violations.append(f"Blocked function: {node.func.id}")

            # Verificar acceso a atributos peligrosos
            elif isinstance(node, ast.Attribute):
                dangerous_attrs = {'__class__', '__bases__', '__subclasses__', '__mro__'}
                if node.attr in dangerous_attrs:
                    self.violations.append(f"Blocked attribute access: {node.attr}")

        return len(self.violations) == 0


class TimeoutError(Exception):
    """Error de timeout."""
    pass


@contextmanager
def timeout(seconds: float):
    """Context manager para timeout (solo Unix)."""
    def handler(signum, frame):
        raise TimeoutError(f"Execution timed out after {seconds}s")

    # En Windows, usar threading en lugar de signal
    if sys.platform == 'win32':
        yield
        return

    old_handler = signal.signal(signal.SIGALRM, handler)
    signal.setitimer(signal.ITIMER_REAL, seconds)
    try:
        yield
    finally:
        signal.setitimer(signal.ITIMER_REAL, 0)
        signal.signal(signal.SIGALRM, old_handler)


class PythonSandbox:
    """Sandbox seguro para ejecución de Python."""

    def __init__(self, config: SandboxConfig = None):
        self.config = config or SandboxConfig()
        self.validator = CodeValidator(self.config)

    def _create_safe_globals(self) -> Dict:
        """Crea un entorno global seguro."""
        safe_builtins = {
            name: getattr(__builtins__, name) if hasattr(__builtins__, name)
            else __builtins__[name] if isinstance(__builtins__, dict) else None
            for name in self.config.allowed_builtins
        }

        # Agregar imports permitidos
        safe_globals = {'__builtins__': safe_builtins}

        for module_name in self.config.allowed_imports:
            try:
                safe_globals[module_name] = __import__(module_name)
            except ImportError:
                pass

        return safe_globals

    def execute(self, code: str, context: Dict = None) -> ExecutionResult:
        """
        Ejecuta código Python en el sandbox.

        Args:
            code: Código Python a ejecutar
            context: Variables de contexto disponibles

        Returns:
            Resultado de la ejecución
        """
        # Validar código
        if not self.validator.validate(code):
            return ExecutionResult(
                success=False,
                error=f"Validation failed: {'; '.join(self.validator.violations)}"
            )

        # Preparar entorno
        safe_globals = self._create_safe_globals()
        if context:
            safe_globals.update(context)

        # Capturar stdout
        captured_output = io.StringIO()
        old_stdout = sys.stdout

        start_time = time.time()

        try:
            sys.stdout = captured_output

            with timeout(self.config.timeout_seconds):
                # Ejecutar código
                exec_result = exec(code, safe_globals)

                # Buscar variable 'result' si existe
                return_value = safe_globals.get('result', None)

            output = captured_output.getvalue()
            if len(output) > self.config.max_output_length:
                output = output[:self.config.max_output_length] + "\n[Output truncated]"

            return ExecutionResult(
                success=True,
                output=output,
                return_value=return_value,
                execution_time=time.time() - start_time
            )

        except TimeoutError as e:
            return ExecutionResult(
                success=False,
                error=str(e),
                execution_time=self.config.timeout_seconds
            )

        except Exception as e:
            return ExecutionResult(
                success=False,
                error=f"{type(e).__name__}: {str(e)}",
                execution_time=time.time() - start_time
            )

        finally:
            sys.stdout = old_stdout
```

### Tool de ejecución de código

```python
class CodeExecutionTool:
    """Tool para que agentes ejecuten código."""

    def __init__(self, sandbox: PythonSandbox = None):
        self.sandbox = sandbox or PythonSandbox()
        self.execution_history: List[Dict] = []

    def get_tool_definition(self) -> Dict:
        """Retorna definición de tool para Gemini."""
        return {
            "name": "execute_python",
            "description": """
Ejecuta código Python para cálculos, transformaciones de datos, o análisis.

CAPACIDADES:
- Cálculos matemáticos y estadísticos
- Procesamiento de strings y listas
- Manipulación de JSON/diccionarios
- Algoritmos básicos

LIMITACIONES (por seguridad):
- No puede acceder a archivos o red
- No puede instalar paquetes
- Timeout de 5 segundos
- Imports limitados a: math, random, datetime, json, re, collections, itertools, statistics

INSTRUCCIONES:
- El código debe ser autosuficiente
- Usa 'result = ...' para retornar valores
- Usa print() para mostrar output intermedio
""",
            "parameters": {
                "type": "object",
                "properties": {
                    "code": {
                        "type": "string",
                        "description": "Código Python a ejecutar"
                    },
                    "context": {
                        "type": "object",
                        "description": "Variables de contexto disponibles para el código"
                    }
                },
                "required": ["code"]
            }
        }

    def execute(self, code: str, context: Dict = None) -> Dict:
        """Ejecuta código y retorna resultado formateado."""
        result = self.sandbox.execute(code, context)

        # Registrar ejecución
        self.execution_history.append({
            "code": code,
            "success": result.success,
            "time": result.execution_time
        })

        if result.success:
            response = {
                "status": "success",
                "output": result.output,
                "execution_time": f"{result.execution_time:.3f}s"
            }
            if result.return_value is not None:
                response["result"] = result.return_value
            return response
        else:
            return {
                "status": "error",
                "error": result.error,
                "execution_time": f"{result.execution_time:.3f}s"
            }


# Uso
code_tool = CodeExecutionTool()

# Ejemplo: Cálculo matemático
result = code_tool.execute("""
import math

# Calcular área de un círculo
radius = 5
area = math.pi * radius ** 2
print(f"Área del círculo: {area:.2f}")

result = {"radius": radius, "area": round(area, 2)}
""")

print(result)
```

### Integración con agente

```python
class CodeAssistantAgent:
    """Agente que puede ejecutar código para resolver problemas."""

    def __init__(self):
        genai.configure(api_key="TU_API_KEY")
        self.code_tool = CodeExecutionTool()
        self.model = genai.GenerativeModel(
            "gemini-1.5-flash",
            tools=[self.code_tool.get_tool_definition()]
        )
        self.chat = self.model.start_chat()

    def solve(self, problem: str) -> Dict:
        """
        Resuelve un problema, usando código si es necesario.

        Args:
            problem: Descripción del problema

        Returns:
            Solución con código ejecutado si aplica
        """
        # Enviar problema al modelo
        response = self.chat.send_message(problem)

        # Verificar si hay function calls
        if not response.candidates[0].content.parts:
            return {"answer": response.text, "code_executed": False}

        for part in response.candidates[0].content.parts:
            if hasattr(part, 'function_call'):
                fc = part.function_call

                if fc.name == "execute_python":
                    # Ejecutar código
                    code = dict(fc.args).get("code", "")
                    context = dict(fc.args).get("context", {})

                    execution_result = self.code_tool.execute(code, context)

                    # Enviar resultado al modelo
                    function_response = genai.protos.Part(
                        function_response=genai.protos.FunctionResponse(
                            name="execute_python",
                            response={"result": execution_result}
                        )
                    )

                    # Obtener respuesta final
                    final_response = self.chat.send_message(
                        genai.protos.Content(parts=[function_response])
                    )

                    return {
                        "answer": final_response.text,
                        "code_executed": True,
                        "code": code,
                        "execution_result": execution_result
                    }

        return {"answer": response.text, "code_executed": False}


# Uso
agent = CodeAssistantAgent()

# Problemas que requieren cálculos
problems = [
    "¿Cuál es el factorial de 20?",
    "Calcula la desviación estándar de [23, 45, 67, 89, 12, 34, 56]",
    "¿Cuántos días hay entre el 1 de enero de 2024 y el 15 de marzo de 2024?",
    "Ordena esta lista de diccionarios por edad: [{'name': 'Ana', 'age': 25}, {'name': 'Juan', 'age': 30}, {'name': 'Pedro', 'age': 20}]"
]

for problem in problems:
    print(f"\nProblema: {problem}")
    result = agent.solve(problem)
    print(f"Respuesta: {result['answer']}")
    if result['code_executed']:
        print(f"Código ejecutado: {result['code'][:100]}...")
```

---

## Patrones avanzados

### 1. Ejecución en contenedor Docker

```python
import subprocess
import tempfile
import os


class DockerSandbox:
    """Sandbox usando Docker para máximo aislamiento."""

    def __init__(
        self,
        image: str = "python:3.11-slim",
        timeout: int = 10,
        memory_limit: str = "128m",
        cpu_limit: float = 0.5
    ):
        self.image = image
        self.timeout = timeout
        self.memory_limit = memory_limit
        self.cpu_limit = cpu_limit

    def execute(self, code: str) -> ExecutionResult:
        """Ejecuta código en contenedor Docker."""
        # Crear archivo temporal con el código
        with tempfile.NamedTemporaryFile(
            mode='w',
            suffix='.py',
            delete=False
        ) as f:
            f.write(code)
            code_file = f.name

        try:
            # Ejecutar en Docker
            cmd = [
                'docker', 'run',
                '--rm',  # Eliminar contenedor al terminar
                '--network', 'none',  # Sin red
                '--memory', self.memory_limit,
                '--cpus', str(self.cpu_limit),
                '-v', f'{code_file}:/code.py:ro',  # Montar código
                self.image,
                'timeout', str(self.timeout),
                'python', '/code.py'
            ]

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.timeout + 5
            )

            return ExecutionResult(
                success=result.returncode == 0,
                output=result.stdout,
                error=result.stderr if result.returncode != 0 else ""
            )

        except subprocess.TimeoutExpired:
            return ExecutionResult(
                success=False,
                error=f"Execution timed out after {self.timeout}s"
            )

        except Exception as e:
            return ExecutionResult(
                success=False,
                error=str(e)
            )

        finally:
            # Limpiar archivo temporal
            os.unlink(code_file)
```

### 2. REPL interactivo con estado

```python
class InteractiveREPL:
    """REPL que mantiene estado entre ejecuciones."""

    def __init__(self, config: SandboxConfig = None):
        self.config = config or SandboxConfig()
        self.validator = CodeValidator(self.config)
        self.state: Dict = {}
        self.history: List[Dict] = []

    def _create_globals(self) -> Dict:
        """Crea globals con estado persistente."""
        safe_builtins = {
            name: getattr(__builtins__, name) if hasattr(__builtins__, name)
            else __builtins__[name] if isinstance(__builtins__, dict) else None
            for name in self.config.allowed_builtins
        }

        globals_dict = {'__builtins__': safe_builtins}
        globals_dict.update(self.state)  # Incluir estado previo

        for module_name in self.config.allowed_imports:
            try:
                globals_dict[module_name] = __import__(module_name)
            except ImportError:
                pass

        return globals_dict

    def execute(self, code: str) -> ExecutionResult:
        """Ejecuta código manteniendo estado."""
        if not self.validator.validate(code):
            return ExecutionResult(
                success=False,
                error=f"Validation failed: {'; '.join(self.validator.violations)}"
            )

        globals_dict = self._create_globals()
        captured_output = io.StringIO()
        old_stdout = sys.stdout

        try:
            sys.stdout = captured_output
            exec(code, globals_dict)

            # Actualizar estado con nuevas variables
            for key, value in globals_dict.items():
                if not key.startswith('_') and key not in self.config.allowed_imports:
                    if key != '__builtins__':
                        self.state[key] = value

            output = captured_output.getvalue()

            self.history.append({
                "code": code,
                "success": True,
                "variables_created": list(self.state.keys())
            })

            return ExecutionResult(
                success=True,
                output=output
            )

        except Exception as e:
            self.history.append({
                "code": code,
                "success": False,
                "error": str(e)
            })

            return ExecutionResult(
                success=False,
                error=str(e)
            )

        finally:
            sys.stdout = old_stdout

    def get_state(self) -> Dict:
        """Retorna el estado actual."""
        return {k: repr(v) for k, v in self.state.items()}

    def reset(self):
        """Reinicia el estado."""
        self.state = {}
        self.history = []


# Uso
repl = InteractiveREPL()

# Sesión interactiva
repl.execute("x = 10")
repl.execute("y = 20")
repl.execute("z = x + y")
result = repl.execute("print(f'x={x}, y={y}, z={z}')")

print(result.output)  # x=10, y=20, z=30
print(repl.get_state())  # {'x': '10', 'y': '20', 'z': '30'}
```

---

## Errores frecuentes

### Error 1: No validar código

```python
# ❌ Ejecutar código sin validación
def bad_execute(code):
    exec(code)  # ¡Peligroso!

# ✓ Siempre validar primero
def good_execute(code):
    validator = CodeValidator(SandboxConfig())
    if not validator.validate(code):
        raise ValueError(f"Unsafe code: {validator.violations}")
    # Ejecutar en sandbox...
```

### Error 2: Sin límites de recursos

```python
# ❌ Sin timeout ni límites
def bad_sandbox(code):
    exec(code)  # Puede ejecutar indefinidamente

# ✓ Con límites estrictos
def good_sandbox(code):
    with timeout(5):  # Máximo 5 segundos
        # Ejecutar con límites de memoria también
        exec(code, restricted_globals)
```

---

## Resumen del concepto

**En una frase**: Las herramientas de ejecución de código permiten a los agentes realizar cálculos y transformaciones precisas mediante código Python sandboxeado.

**Medidas de seguridad esenciales**:
1. Validación de AST antes de ejecución
2. Whitelist de imports y builtins
3. Timeouts estrictos
4. Aislamiento (sandbox, Docker)
5. Límites de recursos

**Casos de uso ideales**:
- Cálculos matemáticos complejos
- Análisis y transformación de datos
- Algoritmos y lógica compleja
- Validación y verificación

**Siguiente paso**: Tema 3.3.1 - APIs REST y Autenticación.
