# Herramientas de Búsqueda y Retrieval

**Tiempo estimado**: 50 minutos
**Nivel**: Intermedio-Avanzado
**Prerrequisitos**: Patrones de Diseño de Tools (3.2.1)

## ¿Por qué importa este concepto?

Las herramientas de búsqueda y retrieval son el puente entre los agentes y el conocimiento externo. Permiten:

- Acceder a información actualizada (más allá del entrenamiento)
- Consultar bases de datos y documentos específicos
- Implementar RAG (Retrieval-Augmented Generation)
- Buscar en la web, APIs y sistemas internos

Un agente sin capacidad de búsqueda está limitado a su conocimiento estático.

---

## Taxonomía de herramientas de retrieval

```
┌─────────────────────────────────────────────────────────────────┐
│ BÚSQUEDA WEB                                                    │
│ ────────────                                                    │
│ • Search engines (Google, Bing, DuckDuckGo)                     │
│ • News APIs                                                     │
│ • Wikipedia, WikiData                                           │
├─────────────────────────────────────────────────────────────────┤
│ BÚSQUEDA SEMÁNTICA                                              │
│ ─────────────────                                               │
│ • Vector databases (Pinecone, Chroma, Weaviate)                 │
│ • Embeddings + similarity search                                │
│ • Dense retrieval                                               │
├─────────────────────────────────────────────────────────────────┤
│ BÚSQUEDA ESTRUCTURADA                                           │
│ ──────────────────────                                          │
│ • SQL databases                                                 │
│ • GraphQL APIs                                                  │
│ • Knowledge graphs                                              │
├─────────────────────────────────────────────────────────────────┤
│ BÚSQUEDA EN DOCUMENTOS                                          │
│ ───────────────────────                                         │
│ • Full-text search (Elasticsearch)                              │
│ • PDF/Document parsing                                          │
│ • Code search                                                   │
└─────────────────────────────────────────────────────────────────┘
```

---

## Implementación práctica

### Framework de búsqueda unificado

```python
import google.generativeai as genai
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from enum import Enum
import json
import hashlib


class SearchResultType(Enum):
    WEB_PAGE = "web_page"
    DOCUMENT = "document"
    DATABASE_ROW = "database_row"
    VECTOR_MATCH = "vector_match"
    API_RESPONSE = "api_response"


@dataclass
class SearchResult:
    """Resultado de búsqueda unificado."""
    id: str
    title: str
    content: str
    source: str
    result_type: SearchResultType
    score: float = 0.0
    metadata: Dict = field(default_factory=dict)
    url: Optional[str] = None

    def to_context(self, max_length: int = 500) -> str:
        """Convierte a contexto para el modelo."""
        content = self.content[:max_length]
        if len(self.content) > max_length:
            content += "..."

        return f"""
[{self.result_type.value}] {self.title}
Source: {self.source}
{content}
"""


@dataclass
class SearchQuery:
    """Query de búsqueda estructurada."""
    text: str
    filters: Dict = field(default_factory=dict)
    limit: int = 10
    min_score: float = 0.0
    include_metadata: bool = True


class SearchProvider(ABC):
    """Interfaz base para proveedores de búsqueda."""

    @abstractmethod
    def search(self, query: SearchQuery) -> List[SearchResult]:
        """Ejecuta una búsqueda."""
        pass

    @abstractmethod
    def get_name(self) -> str:
        """Nombre del proveedor."""
        pass


class UnifiedSearchEngine:
    """Motor de búsqueda que unifica múltiples proveedores."""

    def __init__(self):
        self.providers: Dict[str, SearchProvider] = {}
        self.cache: Dict[str, List[SearchResult]] = {}
        self.cache_ttl = 300  # 5 minutos

    def register_provider(self, provider: SearchProvider):
        """Registra un proveedor de búsqueda."""
        self.providers[provider.get_name()] = provider

    def _cache_key(self, query: SearchQuery, provider: str) -> str:
        """Genera clave de caché."""
        data = f"{provider}:{query.text}:{json.dumps(query.filters)}"
        return hashlib.md5(data.encode()).hexdigest()

    def search(
        self,
        query: SearchQuery,
        providers: List[str] = None,
        merge_results: bool = True
    ) -> Dict[str, List[SearchResult]]:
        """
        Ejecuta búsqueda en múltiples proveedores.

        Args:
            query: Query de búsqueda
            providers: Proveedores específicos (None = todos)
            merge_results: Si combinar y ordenar resultados

        Returns:
            Resultados por proveedor o combinados
        """
        target_providers = providers or list(self.providers.keys())
        results = {}

        for provider_name in target_providers:
            provider = self.providers.get(provider_name)
            if not provider:
                continue

            # Verificar caché
            cache_key = self._cache_key(query, provider_name)
            if cache_key in self.cache:
                results[provider_name] = self.cache[cache_key]
                continue

            # Ejecutar búsqueda
            provider_results = provider.search(query)
            results[provider_name] = provider_results

            # Guardar en caché
            self.cache[cache_key] = provider_results

        if merge_results:
            return self._merge_results(results, query.limit)

        return results

    def _merge_results(
        self,
        results: Dict[str, List[SearchResult]],
        limit: int
    ) -> List[SearchResult]:
        """Combina y ordena resultados de múltiples proveedores."""
        all_results = []
        for provider_results in results.values():
            all_results.extend(provider_results)

        # Ordenar por score descendente
        all_results.sort(key=lambda r: r.score, reverse=True)

        # Deduplicar por contenido similar
        seen_hashes = set()
        unique_results = []
        for result in all_results:
            content_hash = hashlib.md5(result.content[:200].encode()).hexdigest()
            if content_hash not in seen_hashes:
                seen_hashes.add(content_hash)
                unique_results.append(result)

        return unique_results[:limit]
```

### Implementación de proveedores específicos

```python
# Proveedor 1: Búsqueda Web (simulada)
class WebSearchProvider(SearchProvider):
    """Proveedor de búsqueda web."""

    def __init__(self, api_key: str = None):
        self.api_key = api_key

    def get_name(self) -> str:
        return "web"

    def search(self, query: SearchQuery) -> List[SearchResult]:
        # En producción, usar Google Custom Search API, Bing API, etc.
        # Aquí simulamos resultados
        simulated_results = [
            SearchResult(
                id=f"web_{i}",
                title=f"Result {i} for: {query.text}",
                content=f"This is simulated web content for '{query.text}'. "
                        f"It contains relevant information about the topic.",
                source="web_search",
                result_type=SearchResultType.WEB_PAGE,
                score=1.0 - (i * 0.1),
                url=f"https://example.com/result{i}"
            )
            for i in range(min(query.limit, 5))
        ]
        return simulated_results


# Proveedor 2: Búsqueda Semántica con Embeddings
class SemanticSearchProvider(SearchProvider):
    """Proveedor de búsqueda semántica usando embeddings."""

    def __init__(self, documents: List[Dict] = None):
        self.documents = documents or []
        self.embeddings = []
        self._index_documents()

    def get_name(self) -> str:
        return "semantic"

    def _index_documents(self):
        """Indexa documentos generando embeddings."""
        if not self.documents:
            return

        genai.configure(api_key="TU_API_KEY")

        for doc in self.documents:
            content = doc.get("content", "")
            # Generar embedding
            result = genai.embed_content(
                model="models/embedding-001",
                content=content,
                task_type="retrieval_document"
            )
            self.embeddings.append({
                "document": doc,
                "embedding": result["embedding"]
            })

    def _cosine_similarity(self, a: List[float], b: List[float]) -> float:
        """Calcula similitud coseno."""
        import math
        dot_product = sum(x * y for x, y in zip(a, b))
        norm_a = math.sqrt(sum(x * x for x in a))
        norm_b = math.sqrt(sum(x * x for x in b))
        return dot_product / (norm_a * norm_b) if norm_a and norm_b else 0

    def search(self, query: SearchQuery) -> List[SearchResult]:
        if not self.embeddings:
            return []

        # Generar embedding del query
        genai.configure(api_key="TU_API_KEY")
        query_result = genai.embed_content(
            model="models/embedding-001",
            content=query.text,
            task_type="retrieval_query"
        )
        query_embedding = query_result["embedding"]

        # Calcular similitudes
        scored_docs = []
        for item in self.embeddings:
            score = self._cosine_similarity(query_embedding, item["embedding"])
            if score >= query.min_score:
                scored_docs.append((score, item["document"]))

        # Ordenar por score
        scored_docs.sort(reverse=True, key=lambda x: x[0])

        # Convertir a SearchResult
        results = []
        for score, doc in scored_docs[:query.limit]:
            results.append(SearchResult(
                id=doc.get("id", "unknown"),
                title=doc.get("title", "Untitled"),
                content=doc.get("content", ""),
                source="semantic_search",
                result_type=SearchResultType.VECTOR_MATCH,
                score=score,
                metadata=doc.get("metadata", {})
            ))

        return results


# Proveedor 3: Búsqueda SQL
class SQLSearchProvider(SearchProvider):
    """Proveedor de búsqueda en base de datos SQL."""

    def __init__(self, connection_string: str = None):
        self.connection_string = connection_string
        # En producción, crear conexión real
        self.mock_data = [
            {"id": 1, "name": "Product A", "description": "High quality widget", "price": 29.99},
            {"id": 2, "name": "Product B", "description": "Premium gadget", "price": 49.99},
            {"id": 3, "name": "Product C", "description": "Budget friendly item", "price": 9.99},
        ]

    def get_name(self) -> str:
        return "sql"

    def search(self, query: SearchQuery) -> List[SearchResult]:
        # En producción, ejecutar query SQL real
        # Aquí simulamos búsqueda LIKE
        search_term = query.text.lower()
        results = []

        for row in self.mock_data:
            # Buscar en campos de texto
            if (search_term in row["name"].lower() or
                search_term in row["description"].lower()):

                # Aplicar filtros
                if "max_price" in query.filters:
                    if row["price"] > query.filters["max_price"]:
                        continue

                results.append(SearchResult(
                    id=str(row["id"]),
                    title=row["name"],
                    content=f"{row['description']} - Price: ${row['price']}",
                    source="database",
                    result_type=SearchResultType.DATABASE_ROW,
                    score=1.0,
                    metadata={"price": row["price"]}
                ))

        return results[:query.limit]
```

### Tools de búsqueda para agentes

```python
from typing import List, Dict


class SearchTools:
    """Tools de búsqueda para integrar con agentes."""

    def __init__(self, search_engine: UnifiedSearchEngine):
        self.engine = search_engine

    def get_tool_definitions(self) -> List[Dict]:
        """Retorna definiciones de tools para Gemini."""
        return [
            {
                "name": "search_web",
                "description": "Busca información en la web. Usar para preguntas sobre eventos actuales, noticias, o información general.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "Términos de búsqueda"
                        },
                        "num_results": {
                            "type": "integer",
                            "description": "Número de resultados (default: 5)"
                        }
                    },
                    "required": ["query"]
                }
            },
            {
                "name": "search_documents",
                "description": "Busca en la base de documentos interna. Usar para información específica de la empresa o documentación técnica.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "Búsqueda semántica o por palabras clave"
                        },
                        "document_type": {
                            "type": "string",
                            "enum": ["all", "technical", "policy", "faq"],
                            "description": "Tipo de documento a buscar"
                        },
                        "min_relevance": {
                            "type": "number",
                            "description": "Score mínimo de relevancia (0-1)"
                        }
                    },
                    "required": ["query"]
                }
            },
            {
                "name": "search_database",
                "description": "Consulta datos estructurados. Usar para buscar productos, usuarios, pedidos, etc.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "enum": ["products", "users", "orders"],
                            "description": "Tipo de entidad a buscar"
                        },
                        "search_term": {
                            "type": "string",
                            "description": "Término de búsqueda"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Filtros adicionales (ej: {\"max_price\": 100})"
                        }
                    },
                    "required": ["entity_type", "search_term"]
                }
            },
            {
                "name": "get_document",
                "description": "Obtiene el contenido completo de un documento por su ID.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "document_id": {
                            "type": "string",
                            "description": "ID del documento"
                        }
                    },
                    "required": ["document_id"]
                }
            }
        ]

    def execute_tool(self, tool_name: str, **kwargs) -> Dict:
        """Ejecuta una tool de búsqueda."""
        handlers = {
            "search_web": self._search_web,
            "search_documents": self._search_documents,
            "search_database": self._search_database,
            "get_document": self._get_document
        }

        handler = handlers.get(tool_name)
        if not handler:
            return {"error": f"Unknown tool: {tool_name}"}

        return handler(**kwargs)

    def _search_web(self, query: str, num_results: int = 5) -> Dict:
        search_query = SearchQuery(text=query, limit=num_results)
        results = self.engine.search(search_query, providers=["web"])

        return {
            "results": [
                {
                    "title": r.title,
                    "snippet": r.content[:200],
                    "url": r.url,
                    "score": r.score
                }
                for r in results
            ],
            "total": len(results)
        }

    def _search_documents(
        self,
        query: str,
        document_type: str = "all",
        min_relevance: float = 0.5
    ) -> Dict:
        filters = {}
        if document_type != "all":
            filters["type"] = document_type

        search_query = SearchQuery(
            text=query,
            filters=filters,
            min_score=min_relevance,
            limit=10
        )

        results = self.engine.search(search_query, providers=["semantic"])

        return {
            "documents": [
                {
                    "id": r.id,
                    "title": r.title,
                    "excerpt": r.content[:300],
                    "relevance": r.score,
                    "metadata": r.metadata
                }
                for r in results
            ],
            "query": query,
            "total": len(results)
        }

    def _search_database(
        self,
        entity_type: str,
        search_term: str,
        filters: Dict = None
    ) -> Dict:
        search_query = SearchQuery(
            text=search_term,
            filters=filters or {},
            limit=20
        )

        results = self.engine.search(search_query, providers=["sql"])

        return {
            "entity_type": entity_type,
            "results": [
                {
                    "id": r.id,
                    "name": r.title,
                    "details": r.content,
                    "data": r.metadata
                }
                for r in results
            ],
            "total": len(results)
        }

    def _get_document(self, document_id: str) -> Dict:
        # En producción, recuperar documento real
        return {
            "id": document_id,
            "content": f"Full content of document {document_id}...",
            "metadata": {"retrieved_at": "2024-01-15"}
        }
```

---

## Patrón RAG completo

```python
class RAGPipeline:
    """Pipeline completo de Retrieval-Augmented Generation."""

    def __init__(
        self,
        search_engine: UnifiedSearchEngine,
        model_name: str = "gemini-1.5-flash"
    ):
        self.search_engine = search_engine
        genai.configure(api_key="TU_API_KEY")
        self.model = genai.GenerativeModel(model_name)

    def generate_with_context(
        self,
        question: str,
        max_context_docs: int = 5,
        max_context_length: int = 2000
    ) -> Dict:
        """
        Genera respuesta aumentada con retrieval.

        Args:
            question: Pregunta del usuario
            max_context_docs: Máximo de documentos a incluir
            max_context_length: Longitud máxima del contexto

        Returns:
            Respuesta con fuentes
        """
        # Paso 1: Retrieval
        search_query = SearchQuery(text=question, limit=max_context_docs)
        results = self.search_engine.search(search_query)

        # Paso 2: Construir contexto
        context_parts = []
        total_length = 0
        used_sources = []

        for result in results:
            context = result.to_context()
            if total_length + len(context) > max_context_length:
                break

            context_parts.append(context)
            total_length += len(context)
            used_sources.append({
                "title": result.title,
                "source": result.source,
                "url": result.url
            })

        full_context = "\n---\n".join(context_parts)

        # Paso 3: Generar respuesta
        prompt = f"""
Basándote en la siguiente información, responde la pregunta del usuario.
Si la información no es suficiente, indícalo claramente.

INFORMACIÓN RELEVANTE:
{full_context}

PREGUNTA: {question}

INSTRUCCIONES:
- Responde de forma precisa y concisa
- Cita las fuentes cuando sea relevante
- Si no hay información suficiente, di "No encontré información sobre..."

RESPUESTA:
"""
        response = self.model.generate_content(prompt)

        return {
            "answer": response.text,
            "sources": used_sources,
            "context_used": len(context_parts),
            "query": question
        }


# Uso del RAG Pipeline
engine = UnifiedSearchEngine()
engine.register_provider(WebSearchProvider())
engine.register_provider(SemanticSearchProvider(documents=[
    {"id": "1", "title": "Policy Doc", "content": "Company return policy states..."},
    {"id": "2", "title": "FAQ", "content": "Frequently asked questions..."},
]))
engine.register_provider(SQLSearchProvider())

rag = RAGPipeline(engine)

result = rag.generate_with_context(
    "¿Cuál es la política de devoluciones?"
)

print(f"Respuesta: {result['answer']}")
print(f"Fuentes: {result['sources']}")
```

---

## Errores frecuentes

### Error 1: No manejar resultados vacíos

```python
# ❌ Asumir siempre hay resultados
def bad_search(query):
    results = search_engine.search(query)
    return results[0].content  # IndexError si vacío

# ✓ Manejar caso vacío
def good_search(query):
    results = search_engine.search(query)
    if not results:
        return {"message": "No se encontraron resultados", "results": []}
    return {"results": results}
```

### Error 2: Contexto demasiado largo

```python
# ❌ Incluir todo sin límite
def bad_rag(question):
    results = search_all_documents(question)  # 100 documentos
    context = "\n".join(r.content for r in results)  # 50,000 tokens
    return model.generate_content(f"Context: {context}\nQuestion: {question}")
    # Error: excede límite de tokens

# ✓ Limitar y priorizar
def good_rag(question, max_tokens=4000):
    results = search_documents(question, limit=10)
    context = ""
    for r in results:
        if len(context) + len(r.content) > max_tokens:
            break
        context += r.content + "\n"
    return model.generate_content(f"Context: {context}\nQuestion: {question}")
```

---

## Resumen del concepto

**En una frase**: Las herramientas de búsqueda permiten a los agentes acceder a información externa mediante búsqueda web, semántica y estructurada.

**Tipos de búsqueda**:
- **Web**: Información actual y general
- **Semántica**: Documentos por similitud de significado
- **SQL**: Datos estructurados con filtros
- **Full-text**: Búsqueda por palabras clave

**Componentes del patrón RAG**:
1. Retrieval: Encontrar documentos relevantes
2. Ranking: Ordenar por relevancia
3. Context building: Construir contexto para el modelo
4. Generation: Generar respuesta con contexto

**Siguiente paso**: Tema 3.2.3 - Herramientas de Ejecución de Código.
