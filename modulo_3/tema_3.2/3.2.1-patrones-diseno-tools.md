# Patrones de Diseño de Tools

**Tiempo estimado**: 50 minutos
**Nivel**: Intermedio-Avanzado
**Prerrequisitos**: Parallel Function Calling (3.1.3)

## ¿Por qué importa este concepto?

El diseño de tools determina qué tan efectivo será tu agente. Tools bien diseñadas:

- Facilitan que el modelo entienda cuándo y cómo usarlas
- Reducen errores de invocación
- Mejoran la composabilidad (tools que trabajan juntas)
- Simplifican el debugging y mantenimiento
- Permiten reutilización entre diferentes agentes

Un mal diseño de tools puede hacer que incluso el mejor modelo falle consistentemente.

---

## Principios de diseño

```
┌─────────────────────────────────────────────────────────────────┐
│ PRINCIPIOS FUNDAMENTALES                                        │
│ ────────────────────────                                        │
│                                                                 │
│ 1. CLARIDAD                                                     │
│    - Nombre descriptivo que indica la acción                    │
│    - Descripción que explica el "qué" y el "cuándo"            │
│    - Parámetros con nombres auto-explicativos                   │
│                                                                 │
│ 2. ATOMICIDAD                                                   │
│    - Una tool = una responsabilidad                             │
│    - Evitar tools que hacen demasiado                          │
│    - Preferir composición sobre tools monolíticas              │
│                                                                 │
│ 3. CONSISTENCIA                                                 │
│    - Mismo patrón de respuesta en todas las tools              │
│    - Convenciones de nombres uniformes                          │
│    - Manejo de errores estandarizado                           │
│                                                                 │
│ 4. ROBUSTEZ                                                     │
│    - Validación de inputs                                       │
│    - Valores por defecto sensatos                              │
│    - Mensajes de error informativos                            │
└─────────────────────────────────────────────────────────────────┘
```

---

## Implementación práctica

### Framework de definición de tools

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Callable, Union
from enum import Enum
import json
from functools import wraps


class ParameterType(Enum):
    STRING = "string"
    NUMBER = "number"
    INTEGER = "integer"
    BOOLEAN = "boolean"
    ARRAY = "array"
    OBJECT = "object"


@dataclass
class Parameter:
    """Define un parámetro de una tool."""
    name: str
    type: ParameterType
    description: str
    required: bool = True
    default: Any = None
    enum: Optional[List[Any]] = None
    items_type: Optional[ParameterType] = None  # Para arrays
    properties: Optional[Dict] = None  # Para objects

    def to_schema(self) -> Dict:
        """Convierte a JSON Schema."""
        schema = {
            "type": self.type.value,
            "description": self.description
        }

        if self.enum:
            schema["enum"] = self.enum

        if self.type == ParameterType.ARRAY and self.items_type:
            schema["items"] = {"type": self.items_type.value}

        if self.type == ParameterType.OBJECT and self.properties:
            schema["properties"] = self.properties

        return schema


@dataclass
class ToolDefinition:
    """Define una tool completa."""
    name: str
    description: str
    parameters: List[Parameter]
    handler: Callable
    examples: List[Dict] = field(default_factory=list)
    category: str = "general"

    def to_gemini_tool(self) -> Dict:
        """Convierte a formato de tool de Gemini."""
        properties = {}
        required = []

        for param in self.parameters:
            properties[param.name] = param.to_schema()
            if param.required:
                required.append(param.name)

        return {
            "name": self.name,
            "description": self._build_description(),
            "parameters": {
                "type": "object",
                "properties": properties,
                "required": required
            }
        }

    def _build_description(self) -> str:
        """Construye descripción enriquecida con ejemplos."""
        desc = self.description

        if self.examples:
            desc += "\n\nEjemplos de uso:"
            for ex in self.examples[:2]:  # Limitar ejemplos
                desc += f"\n- {ex.get('scenario', '')}: {ex.get('call', '')}"

        return desc

    def execute(self, **kwargs) -> Dict:
        """Ejecuta la tool con validación."""
        # Aplicar defaults
        for param in self.parameters:
            if param.name not in kwargs and param.default is not None:
                kwargs[param.name] = param.default

        # Validar requeridos
        for param in self.parameters:
            if param.required and param.name not in kwargs:
                return {
                    "error": f"Missing required parameter: {param.name}",
                    "parameter": param.name
                }

        try:
            result = self.handler(**kwargs)
            return {"success": True, "result": result}
        except Exception as e:
            return {"success": False, "error": str(e)}


class ToolRegistry:
    """Registro centralizado de tools."""

    def __init__(self):
        self.tools: Dict[str, ToolDefinition] = {}
        self.categories: Dict[str, List[str]] = {}

    def register(self, tool: ToolDefinition):
        """Registra una tool."""
        self.tools[tool.name] = tool

        if tool.category not in self.categories:
            self.categories[tool.category] = []
        self.categories[tool.category].append(tool.name)

    def get(self, name: str) -> Optional[ToolDefinition]:
        """Obtiene una tool por nombre."""
        return self.tools.get(name)

    def get_by_category(self, category: str) -> List[ToolDefinition]:
        """Obtiene tools de una categoría."""
        names = self.categories.get(category, [])
        return [self.tools[n] for n in names]

    def to_gemini_tools(self) -> List[Dict]:
        """Convierte todas las tools a formato Gemini."""
        return [tool.to_gemini_tool() for tool in self.tools.values()]

    def execute(self, name: str, **kwargs) -> Dict:
        """Ejecuta una tool por nombre."""
        tool = self.get(name)
        if not tool:
            return {"error": f"Tool not found: {name}"}
        return tool.execute(**kwargs)


# Decorador para crear tools fácilmente
def tool(
    name: str,
    description: str,
    category: str = "general",
    examples: List[Dict] = None
):
    """
    Decorador para convertir una función en una tool.

    Uso:
        @tool("search_web", "Busca información en la web")
        def search_web(query: str, num_results: int = 5) -> Dict:
            ...
    """
    def decorator(func: Callable):
        # Extraer parámetros de la firma
        import inspect
        sig = inspect.signature(func)
        params = []

        type_mapping = {
            str: ParameterType.STRING,
            int: ParameterType.INTEGER,
            float: ParameterType.NUMBER,
            bool: ParameterType.BOOLEAN,
            list: ParameterType.ARRAY,
            dict: ParameterType.OBJECT
        }

        for param_name, param in sig.parameters.items():
            annotation = param.annotation
            param_type = type_mapping.get(annotation, ParameterType.STRING)
            has_default = param.default != inspect.Parameter.empty

            params.append(Parameter(
                name=param_name,
                type=param_type,
                description=f"Parameter: {param_name}",
                required=not has_default,
                default=param.default if has_default else None
            ))

        tool_def = ToolDefinition(
            name=name,
            description=description,
            parameters=params,
            handler=func,
            examples=examples or [],
            category=category
        )

        # Adjuntar definición a la función
        func._tool_definition = tool_def

        @wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)

        wrapper._tool_definition = tool_def
        return wrapper

    return decorator
```

### Patrones de diseño comunes

```python
# Patrón 1: CRUD Tool
class CRUDToolBuilder:
    """Genera tools CRUD para un recurso."""

    def __init__(self, resource_name: str, resource_schema: Dict):
        self.resource = resource_name
        self.schema = resource_schema

    def build_all(self) -> List[ToolDefinition]:
        """Genera todas las tools CRUD."""
        return [
            self._build_create(),
            self._build_read(),
            self._build_update(),
            self._build_delete(),
            self._build_list()
        ]

    def _build_create(self) -> ToolDefinition:
        params = [
            Parameter(
                name=field,
                type=ParameterType.STRING,
                description=f"{field} del {self.resource}",
                required=props.get("required", False)
            )
            for field, props in self.schema.items()
        ]

        return ToolDefinition(
            name=f"create_{self.resource}",
            description=f"Crea un nuevo {self.resource}",
            parameters=params,
            handler=lambda **kwargs: {"created": kwargs, "id": "new_id"},
            category="crud"
        )

    def _build_read(self) -> ToolDefinition:
        return ToolDefinition(
            name=f"get_{self.resource}",
            description=f"Obtiene un {self.resource} por ID",
            parameters=[
                Parameter("id", ParameterType.STRING, f"ID del {self.resource}")
            ],
            handler=lambda id: {"id": id, "data": "..."},
            category="crud"
        )

    def _build_update(self) -> ToolDefinition:
        params = [
            Parameter("id", ParameterType.STRING, f"ID del {self.resource}")
        ]
        params.extend([
            Parameter(
                name=field,
                type=ParameterType.STRING,
                description=f"Nuevo valor para {field}",
                required=False
            )
            for field in self.schema.keys()
        ])

        return ToolDefinition(
            name=f"update_{self.resource}",
            description=f"Actualiza un {self.resource}",
            parameters=params,
            handler=lambda **kwargs: {"updated": kwargs},
            category="crud"
        )

    def _build_delete(self) -> ToolDefinition:
        return ToolDefinition(
            name=f"delete_{self.resource}",
            description=f"Elimina un {self.resource}",
            parameters=[
                Parameter("id", ParameterType.STRING, f"ID del {self.resource}")
            ],
            handler=lambda id: {"deleted": id},
            category="crud"
        )

    def _build_list(self) -> ToolDefinition:
        return ToolDefinition(
            name=f"list_{self.resource}s",
            description=f"Lista todos los {self.resource}s con filtros opcionales",
            parameters=[
                Parameter("limit", ParameterType.INTEGER, "Límite de resultados", required=False, default=10),
                Parameter("offset", ParameterType.INTEGER, "Offset para paginación", required=False, default=0),
                Parameter("filter", ParameterType.STRING, "Filtro de búsqueda", required=False)
            ],
            handler=lambda **kwargs: {"items": [], "total": 0},
            category="crud"
        )


# Uso
user_crud = CRUDToolBuilder("user", {
    "name": {"required": True},
    "email": {"required": True},
    "role": {"required": False}
})
user_tools = user_crud.build_all()
```

```python
# Patrón 2: Composite Tool (Tool que orquesta otras)
class CompositeToolBuilder:
    """Crea tools que combinan múltiples operaciones."""

    def __init__(self, registry: ToolRegistry):
        self.registry = registry

    def create_workflow_tool(
        self,
        name: str,
        description: str,
        steps: List[Dict]
    ) -> ToolDefinition:
        """
        Crea una tool que ejecuta un workflow de múltiples steps.

        Args:
            name: Nombre de la tool
            description: Descripción
            steps: Lista de {"tool": "name", "params_map": {...}}
        """
        def workflow_handler(**initial_params):
            context = initial_params.copy()
            results = []

            for step in steps:
                tool_name = step["tool"]
                params_map = step.get("params_map", {})

                # Mapear parámetros del contexto
                call_params = {}
                for target_param, source in params_map.items():
                    if source.startswith("$"):
                        # Referencia a resultado previo
                        key = source[1:]
                        call_params[target_param] = context.get(key)
                    else:
                        call_params[target_param] = source

                # Ejecutar step
                result = self.registry.execute(tool_name, **call_params)
                results.append({
                    "step": tool_name,
                    "result": result
                })

                # Actualizar contexto con resultado
                if result.get("success"):
                    context[f"result_{len(results)}"] = result["result"]

            return {"workflow_results": results}

        # Extraer parámetros iniciales del primer step
        first_step_tool = self.registry.get(steps[0]["tool"])
        initial_params = first_step_tool.parameters if first_step_tool else []

        return ToolDefinition(
            name=name,
            description=description,
            parameters=initial_params,
            handler=workflow_handler,
            category="workflow"
        )


# Patrón 3: Validated Tool (con validación estricta)
def create_validated_tool(
    name: str,
    description: str,
    parameters: List[Parameter],
    handler: Callable,
    validators: Dict[str, Callable] = None
) -> ToolDefinition:
    """
    Crea una tool con validadores personalizados.

    Args:
        validators: {param_name: validator_func}
                   validator_func(value) -> (is_valid, error_msg)
    """
    validators = validators or {}

    def validated_handler(**kwargs):
        # Ejecutar validadores
        for param_name, validator in validators.items():
            if param_name in kwargs:
                is_valid, error_msg = validator(kwargs[param_name])
                if not is_valid:
                    return {
                        "error": f"Validation failed for {param_name}: {error_msg}",
                        "parameter": param_name
                    }

        return handler(**kwargs)

    return ToolDefinition(
        name=name,
        description=description,
        parameters=parameters,
        handler=validated_handler,
        category="validated"
    )


# Ejemplo: Tool de email con validación
def validate_email(email: str) -> tuple:
    import re
    pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'
    if re.match(pattern, email):
        return True, ""
    return False, "Invalid email format"


send_email_tool = create_validated_tool(
    name="send_email",
    description="Envía un email",
    parameters=[
        Parameter("to", ParameterType.STRING, "Dirección de email del destinatario"),
        Parameter("subject", ParameterType.STRING, "Asunto del email"),
        Parameter("body", ParameterType.STRING, "Cuerpo del email")
    ],
    handler=lambda to, subject, body: {"sent": True, "to": to},
    validators={"to": validate_email}
)
```

### Tools con respuestas estructuradas

```python
# Patrón 4: Tool con Response Schema
@dataclass
class ToolResponse:
    """Respuesta estandarizada de tool."""
    success: bool
    data: Optional[Any] = None
    error: Optional[str] = None
    metadata: Dict = field(default_factory=dict)

    def to_dict(self) -> Dict:
        return {
            "success": self.success,
            "data": self.data,
            "error": self.error,
            "metadata": self.metadata
        }


def structured_tool(
    name: str,
    description: str,
    response_schema: Dict = None
):
    """
    Decorador para tools con respuesta estructurada.

    El response_schema documenta la estructura esperada
    para ayudar al modelo a interpretar resultados.
    """
    def decorator(func: Callable):
        @wraps(func)
        def wrapper(*args, **kwargs) -> Dict:
            try:
                result = func(*args, **kwargs)
                return ToolResponse(
                    success=True,
                    data=result,
                    metadata={"response_schema": response_schema}
                ).to_dict()
            except Exception as e:
                return ToolResponse(
                    success=False,
                    error=str(e)
                ).to_dict()

        # Enriquecer descripción con schema
        enriched_desc = description
        if response_schema:
            enriched_desc += f"\n\nEstructura de respuesta:\n{json.dumps(response_schema, indent=2)}"

        wrapper._enriched_description = enriched_desc
        return wrapper

    return decorator


# Uso
@structured_tool(
    name="search_products",
    description="Busca productos en el catálogo",
    response_schema={
        "products": [
            {
                "id": "string",
                "name": "string",
                "price": "number",
                "in_stock": "boolean"
            }
        ],
        "total_count": "integer",
        "page": "integer"
    }
)
def search_products(query: str, category: str = None, max_price: float = None):
    # Implementación...
    return {
        "products": [
            {"id": "1", "name": "Product A", "price": 29.99, "in_stock": True}
        ],
        "total_count": 1,
        "page": 1
    }
```

---

## Anti-patrones a evitar

### Anti-patrón 1: Tool que hace demasiado

```python
# ❌ MAL: Tool monolítica
bad_tool = ToolDefinition(
    name="manage_user",
    description="Crea, actualiza, elimina, busca usuarios y envía notificaciones",
    parameters=[
        Parameter("action", ParameterType.STRING, "create|update|delete|search|notify"),
        Parameter("user_id", ParameterType.STRING, "ID del usuario", required=False),
        Parameter("user_data", ParameterType.OBJECT, "Datos del usuario", required=False),
        Parameter("search_query", ParameterType.STRING, "Búsqueda", required=False),
        Parameter("notification_type", ParameterType.STRING, "Tipo de notificación", required=False),
    ],
    handler=lambda **kwargs: "...",  # Lógica compleja
    category="user"
)

# ✓ BIEN: Tools atómicas
good_tools = [
    ToolDefinition(name="create_user", description="Crea un usuario", ...),
    ToolDefinition(name="update_user", description="Actualiza un usuario", ...),
    ToolDefinition(name="delete_user", description="Elimina un usuario", ...),
    ToolDefinition(name="search_users", description="Busca usuarios", ...),
    ToolDefinition(name="notify_user", description="Envía notificación", ...),
]
```

### Anti-patrón 2: Nombres ambiguos

```python
# ❌ MAL: Nombres vagos
bad_names = ["process", "handle", "do_thing", "execute", "run"]

# ✓ BIEN: Nombres descriptivos con verbo + sustantivo
good_names = [
    "search_products",      # Verbo + sustantivo
    "create_order",         # Acción clara
    "calculate_shipping",   # Especifica qué calcula
    "validate_address",     # Indica validación
    "send_notification"     # Acción específica
]
```

### Anti-patrón 3: Parámetros sin contexto

```python
# ❌ MAL: Parámetros sin información
bad_params = [
    Parameter("id", ParameterType.STRING, "el id"),
    Parameter("data", ParameterType.OBJECT, "los datos"),
    Parameter("flag", ParameterType.BOOLEAN, "un flag"),
]

# ✓ BIEN: Parámetros auto-documentados
good_params = [
    Parameter(
        "user_id",
        ParameterType.STRING,
        "ID único del usuario (formato UUID v4, ej: 550e8400-e29b-41d4-a716-446655440000)"
    ),
    Parameter(
        "shipping_address",
        ParameterType.OBJECT,
        "Dirección de envío con campos: street, city, postal_code, country"
    ),
    Parameter(
        "include_inactive",
        ParameterType.BOOLEAN,
        "Si es true, incluye usuarios inactivos en la búsqueda (default: false)"
    ),
]
```

---

## Aplicación: Sistema de tools para e-commerce

```python
class ECommerceToolkit:
    """Toolkit completo para un agente de e-commerce."""

    def __init__(self):
        self.registry = ToolRegistry()
        self._register_all_tools()

    def _register_all_tools(self):
        """Registra todas las tools del e-commerce."""

        # Catálogo
        self.registry.register(ToolDefinition(
            name="search_products",
            description="Busca productos por nombre, categoría o características",
            parameters=[
                Parameter("query", ParameterType.STRING, "Término de búsqueda"),
                Parameter("category", ParameterType.STRING, "Categoría del producto", required=False),
                Parameter("min_price", ParameterType.NUMBER, "Precio mínimo", required=False),
                Parameter("max_price", ParameterType.NUMBER, "Precio máximo", required=False),
                Parameter("in_stock_only", ParameterType.BOOLEAN, "Solo productos en stock", required=False, default=True)
            ],
            handler=self._search_products,
            examples=[
                {"scenario": "Buscar laptops baratas", "call": "search_products(query='laptop', max_price=500)"}
            ],
            category="catalog"
        ))

        self.registry.register(ToolDefinition(
            name="get_product_details",
            description="Obtiene información detallada de un producto específico",
            parameters=[
                Parameter("product_id", ParameterType.STRING, "ID del producto")
            ],
            handler=self._get_product_details,
            category="catalog"
        ))

        # Carrito
        self.registry.register(ToolDefinition(
            name="add_to_cart",
            description="Agrega un producto al carrito del usuario",
            parameters=[
                Parameter("product_id", ParameterType.STRING, "ID del producto a agregar"),
                Parameter("quantity", ParameterType.INTEGER, "Cantidad", required=False, default=1)
            ],
            handler=self._add_to_cart,
            category="cart"
        ))

        self.registry.register(ToolDefinition(
            name="view_cart",
            description="Muestra el contenido actual del carrito",
            parameters=[],
            handler=self._view_cart,
            category="cart"
        ))

        self.registry.register(ToolDefinition(
            name="remove_from_cart",
            description="Elimina un producto del carrito",
            parameters=[
                Parameter("product_id", ParameterType.STRING, "ID del producto a eliminar")
            ],
            handler=self._remove_from_cart,
            category="cart"
        ))

        # Pedidos
        self.registry.register(ToolDefinition(
            name="create_order",
            description="Crea un pedido con los productos del carrito",
            parameters=[
                Parameter("shipping_address", ParameterType.STRING, "Dirección de envío completa"),
                Parameter("payment_method", ParameterType.STRING, "Método de pago", enum=["credit_card", "paypal", "bank_transfer"])
            ],
            handler=self._create_order,
            category="orders"
        ))

        self.registry.register(ToolDefinition(
            name="track_order",
            description="Consulta el estado de un pedido",
            parameters=[
                Parameter("order_id", ParameterType.STRING, "ID del pedido")
            ],
            handler=self._track_order,
            category="orders"
        ))

        # Soporte
        self.registry.register(ToolDefinition(
            name="check_return_eligibility",
            description="Verifica si un producto es elegible para devolución",
            parameters=[
                Parameter("order_id", ParameterType.STRING, "ID del pedido"),
                Parameter("product_id", ParameterType.STRING, "ID del producto")
            ],
            handler=self._check_return,
            category="support"
        ))

    # Implementaciones (simplificadas)
    def _search_products(self, query, category=None, min_price=None, max_price=None, in_stock_only=True):
        return {"products": [{"id": "1", "name": f"Result for: {query}", "price": 99.99}], "total": 1}

    def _get_product_details(self, product_id):
        return {"id": product_id, "name": "Product", "price": 99.99, "description": "...", "specs": {}}

    def _add_to_cart(self, product_id, quantity=1):
        return {"added": True, "product_id": product_id, "quantity": quantity, "cart_total": 99.99}

    def _view_cart(self):
        return {"items": [], "subtotal": 0, "tax": 0, "total": 0}

    def _remove_from_cart(self, product_id):
        return {"removed": True, "product_id": product_id}

    def _create_order(self, shipping_address, payment_method):
        return {"order_id": "ORD-123", "status": "pending", "estimated_delivery": "2024-02-10"}

    def _track_order(self, order_id):
        return {"order_id": order_id, "status": "shipped", "tracking_number": "TRK123", "eta": "2024-02-08"}

    def _check_return(self, order_id, product_id):
        return {"eligible": True, "deadline": "2024-02-15", "refund_amount": 99.99}

    def get_model(self) -> genai.GenerativeModel:
        """Crea modelo con todas las tools registradas."""
        genai.configure(api_key="TU_API_KEY")
        return genai.GenerativeModel(
            "gemini-1.5-flash",
            tools=self.registry.to_gemini_tools()
        )


# Uso
toolkit = ECommerceToolkit()
model = toolkit.get_model()

# El agente puede usar cualquier combinación de tools
response = model.generate_content(
    "Busca laptops gaming bajo $1000, agrega la mejor al carrito y muéstrame el total"
)
```

---

## Resumen del concepto

**En una frase**: Tools bien diseñadas son atómicas, claramente nombradas, con parámetros auto-documentados y respuestas consistentes.

**Principios clave**:
1. **Una tool, una responsabilidad**
2. **Nombres = verbo + sustantivo**
3. **Descripciones que incluyen "cuándo usar"**
4. **Parámetros con ejemplos y restricciones**
5. **Respuestas estructuradas y predecibles**

**Patrones útiles**:
- CRUD Builder para recursos
- Composite Tools para workflows
- Validated Tools para inputs críticos
- Structured Response para salidas complejas

**Siguiente paso**: Tema 3.2.2 - Herramientas de Búsqueda y Retrieval.
