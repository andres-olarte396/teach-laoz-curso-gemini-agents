# Declaración de Funciones con JSON Schema

**Tiempo estimado**: 50 minutos
**Nivel**: Intermedio
**Prerrequisitos**: API de Gemini (Módulo 1), JSON básico

## ¿Por qué importa este concepto?

Function Calling es lo que convierte a un LLM de un "generador de texto" en un **agente** capaz de actuar en el mundo real. Permite que Gemini decida cuándo llamar a funciones externas (APIs, bases de datos, herramientas) y qué argumentos pasarles.

Sin Function Calling, un modelo solo puede responder con texto. Con Function Calling, puede:
- Buscar información en tiempo real
- Ejecutar código
- Enviar emails
- Consultar bases de datos
- Controlar dispositivos IoT
- Cualquier acción que puedas programar

---

## Comprensión intuitiva

Imagina que le dices a un asistente humano: "¿Qué tiempo hace en Madrid?"

Un asistente sin herramientas diría: "No lo sé exactamente, pero típicamente en febrero hace frío."

Un asistente **con herramientas** pensaría:
1. "Necesito consultar el clima actual"
2. "Tengo acceso a una API de clima"
3. "Voy a llamar `get_weather(location="Madrid")`"
4. Recibe: `{"temp": 12, "condition": "soleado"}`
5. "En Madrid hace 12°C y está soleado."

Function Calling automatiza los pasos 2-4.

---

## Anatomía de una declaración de función

### Estructura JSON Schema

```python
# Una función se declara con este formato:
function_declaration = {
    "name": "get_weather",           # Nombre único de la función
    "description": "Obtiene el clima actual de una ubicación",  # Para que el modelo sepa cuándo usarla
    "parameters": {                  # JSON Schema de los parámetros
        "type": "object",
        "properties": {
            "location": {
                "type": "string",
                "description": "Ciudad y país, ej: 'Madrid, España'"
            },
            "unit": {
                "type": "string",
                "enum": ["celsius", "fahrenheit"],
                "description": "Unidad de temperatura"
            }
        },
        "required": ["location"]     # Parámetros obligatorios
    }
}
```

### Componentes clave

| Campo | Propósito | Importancia |
|-------|-----------|-------------|
| `name` | Identificador único | El modelo lo usa para llamar la función |
| `description` | Cuándo usar la función | **CRÍTICO**: El modelo decide basándose en esto |
| `parameters` | Qué datos necesita | Define la estructura de entrada |
| `required` | Parámetros obligatorios | Evita llamadas incompletas |

---

## Implementación práctica

### Declaración básica con el SDK

```python
import google.generativeai as genai
from google.generativeai.types import FunctionDeclaration, Tool
import os

genai.configure(api_key=os.environ["GOOGLE_API_KEY"])


# Método 1: Usando diccionarios
get_weather_dict = {
    "name": "get_weather",
    "description": "Obtiene el clima actual para una ubicación dada. Usar cuando el usuario pregunte sobre el tiempo o clima.",
    "parameters": {
        "type": "object",
        "properties": {
            "location": {
                "type": "string",
                "description": "La ciudad y país, ej: 'Buenos Aires, Argentina'"
            },
            "unit": {
                "type": "string",
                "enum": ["celsius", "fahrenheit"],
                "default": "celsius",
                "description": "Unidad de temperatura preferida"
            }
        },
        "required": ["location"]
    }
}


# Método 2: Usando FunctionDeclaration (más tipado)
get_weather_func = FunctionDeclaration(
    name="get_weather",
    description="Obtiene el clima actual para una ubicación dada.",
    parameters={
        "type": "object",
        "properties": {
            "location": {
                "type": "string",
                "description": "Ciudad y país"
            }
        },
        "required": ["location"]
    }
)


# Crear herramienta con la función
weather_tool = Tool(function_declarations=[get_weather_func])


# Crear modelo con la herramienta
model = genai.GenerativeModel(
    "gemini-1.5-flash",
    tools=[weather_tool]
)
```

### Múltiples funciones

```python
# Declarar varias funciones relacionadas
search_function = FunctionDeclaration(
    name="web_search",
    description="Busca información en internet. Usar para preguntas sobre eventos actuales, datos que cambien, o información que el modelo pueda no tener.",
    parameters={
        "type": "object",
        "properties": {
            "query": {
                "type": "string",
                "description": "Consulta de búsqueda"
            },
            "num_results": {
                "type": "integer",
                "description": "Número de resultados a retornar",
                "default": 5
            }
        },
        "required": ["query"]
    }
)

calculator_function = FunctionDeclaration(
    name="calculate",
    description="Realiza cálculos matemáticos. Usar para operaciones aritméticas, conversiones, o cálculos complejos.",
    parameters={
        "type": "object",
        "properties": {
            "expression": {
                "type": "string",
                "description": "Expresión matemática a evaluar, ej: '2 * (3 + 4)'"
            }
        },
        "required": ["expression"]
    }
)

send_email_function = FunctionDeclaration(
    name="send_email",
    description="Envía un email. Solo usar cuando el usuario explícitamente pida enviar un correo.",
    parameters={
        "type": "object",
        "properties": {
            "to": {
                "type": "string",
                "description": "Dirección de email del destinatario"
            },
            "subject": {
                "type": "string",
                "description": "Asunto del email"
            },
            "body": {
                "type": "string",
                "description": "Contenido del email"
            }
        },
        "required": ["to", "subject", "body"]
    }
)

# Agrupar en una herramienta
multi_tool = Tool(
    function_declarations=[
        search_function,
        calculator_function,
        send_email_function
    ]
)

# Modelo con múltiples funciones
model_with_tools = genai.GenerativeModel(
    "gemini-1.5-flash",
    tools=[multi_tool]
)
```

### Decorador automático desde funciones Python

```python
from typing import Annotated
import inspect


def function_to_declaration(func) -> FunctionDeclaration:
    """
    Convierte una función Python a FunctionDeclaration.

    Usa docstrings y type hints para generar el schema.
    """
    # Obtener información de la función
    sig = inspect.signature(func)
    doc = inspect.getdoc(func) or ""

    # Parsear docstring para descripción de parámetros
    # (simplificado - en producción usar docstring_parser)
    param_docs = {}
    for line in doc.split('\n'):
        if ':param' in line:
            parts = line.split(':param')[1].split(':')
            if len(parts) >= 2:
                param_name = parts[0].strip()
                param_doc = ':'.join(parts[1:]).strip()
                param_docs[param_name] = param_doc

    # Construir propiedades desde type hints
    properties = {}
    required = []

    for name, param in sig.parameters.items():
        if name == 'self':
            continue

        # Inferir tipo
        type_hint = param.annotation
        json_type = "string"  # default

        if type_hint == int:
            json_type = "integer"
        elif type_hint == float:
            json_type = "number"
        elif type_hint == bool:
            json_type = "boolean"
        elif type_hint == list:
            json_type = "array"

        properties[name] = {
            "type": json_type,
            "description": param_docs.get(name, f"Parámetro {name}")
        }

        # Verificar si es requerido (no tiene default)
        if param.default == inspect.Parameter.empty:
            required.append(name)

    return FunctionDeclaration(
        name=func.__name__,
        description=doc.split('\n')[0] if doc else func.__name__,
        parameters={
            "type": "object",
            "properties": properties,
            "required": required
        }
    )


# Uso del decorador
def get_stock_price(symbol: str, currency: str = "USD") -> float:
    """
    Obtiene el precio actual de una acción.

    :param symbol: Símbolo de la acción (ej: GOOGL, AAPL)
    :param currency: Moneda para el precio
    """
    # Implementación real aquí
    pass


# Convertir automáticamente
stock_declaration = function_to_declaration(get_stock_price)
print(f"Nombre: {stock_declaration.name}")
print(f"Descripción: {stock_declaration.description}")
print(f"Parámetros: {stock_declaration.parameters}")
```

---

## Tipos de datos en JSON Schema

### Tipos primitivos

```python
# String
{"type": "string", "description": "Texto libre"}

# String con opciones fijas (enum)
{"type": "string", "enum": ["opcion1", "opcion2", "opcion3"]}

# Integer
{"type": "integer", "description": "Número entero"}

# Number (incluye decimales)
{"type": "number", "description": "Número decimal"}

# Boolean
{"type": "boolean", "description": "Verdadero o falso"}
```

### Tipos complejos

```python
# Array de strings
{
    "type": "array",
    "items": {"type": "string"},
    "description": "Lista de tags"
}

# Array de objetos
{
    "type": "array",
    "items": {
        "type": "object",
        "properties": {
            "name": {"type": "string"},
            "quantity": {"type": "integer"}
        }
    },
    "description": "Lista de productos"
}

# Objeto anidado
{
    "type": "object",
    "properties": {
        "address": {
            "type": "object",
            "properties": {
                "street": {"type": "string"},
                "city": {"type": "string"},
                "zip": {"type": "string"}
            }
        }
    }
}
```

### Ejemplo completo con tipos complejos

```python
create_order_function = FunctionDeclaration(
    name="create_order",
    description="Crea un pedido de productos. Usar cuando el usuario quiera comprar algo.",
    parameters={
        "type": "object",
        "properties": {
            "customer_email": {
                "type": "string",
                "description": "Email del cliente"
            },
            "items": {
                "type": "array",
                "description": "Lista de productos a ordenar",
                "items": {
                    "type": "object",
                    "properties": {
                        "product_id": {
                            "type": "string",
                            "description": "ID del producto"
                        },
                        "quantity": {
                            "type": "integer",
                            "description": "Cantidad a ordenar"
                        }
                    },
                    "required": ["product_id", "quantity"]
                }
            },
            "shipping_address": {
                "type": "object",
                "description": "Dirección de envío",
                "properties": {
                    "street": {"type": "string"},
                    "city": {"type": "string"},
                    "country": {"type": "string"},
                    "postal_code": {"type": "string"}
                },
                "required": ["street", "city", "country"]
            },
            "priority": {
                "type": "string",
                "enum": ["standard", "express", "overnight"],
                "description": "Velocidad de envío"
            }
        },
        "required": ["customer_email", "items", "shipping_address"]
    }
)
```

---

## Buenas prácticas para descripciones

### La descripción es CRÍTICA

El modelo decide si usar una función basándose en su descripción. Una mala descripción = la función no se usa cuando debería (o se usa cuando no debería).

```python
# ❌ Malo: descripción vaga
FunctionDeclaration(
    name="do_thing",
    description="Hace algo",  # ¿Cuándo usarla?
    ...
)

# ❌ Malo: descripción técnica sin contexto
FunctionDeclaration(
    name="get_data",
    description="Ejecuta SELECT * FROM users WHERE id = ?",  # No dice cuándo usarla
    ...
)

# ✓ Bueno: descripción clara con casos de uso
FunctionDeclaration(
    name="lookup_user",
    description="Busca información de un usuario por su ID o email. Usar cuando el usuario pregunte sobre datos de su cuenta, perfil, o historial.",
    ...
)

# ✓ Bueno: incluye qué NO hacer
FunctionDeclaration(
    name="delete_account",
    description="Elimina permanentemente una cuenta de usuario. SOLO usar si el usuario EXPLÍCITAMENTE pide eliminar su cuenta. Requiere confirmación.",
    ...
)
```

### Descripciones de parámetros

```python
# ❌ Malo
"location": {"type": "string"}

# ✓ Bueno
"location": {
    "type": "string",
    "description": "Ciudad y país en formato 'Ciudad, País'. Ejemplos: 'Madrid, España', 'New York, USA'"
}
```

---

## Casos de prueba

```python
# test_function_declarations.py
import pytest
from google.generativeai.types import FunctionDeclaration, Tool


def test_basic_declaration():
    """Test declaración básica de función."""
    func = FunctionDeclaration(
        name="test_func",
        description="Una función de prueba",
        parameters={
            "type": "object",
            "properties": {
                "param1": {"type": "string"}
            },
            "required": ["param1"]
        }
    )

    assert func.name == "test_func"
    assert "prueba" in func.description
    print("✓ Declaración básica válida")


def test_tool_creation():
    """Test creación de Tool con múltiples funciones."""
    func1 = FunctionDeclaration(name="func1", description="Función 1")
    func2 = FunctionDeclaration(name="func2", description="Función 2")

    tool = Tool(function_declarations=[func1, func2])
    assert len(tool.function_declarations) == 2
    print("✓ Tool con múltiples funciones")


def test_complex_parameters():
    """Test parámetros complejos (arrays, objetos)."""
    func = FunctionDeclaration(
        name="complex_func",
        description="Función con parámetros complejos",
        parameters={
            "type": "object",
            "properties": {
                "items": {
                    "type": "array",
                    "items": {"type": "string"}
                },
                "metadata": {
                    "type": "object",
                    "properties": {
                        "key": {"type": "string"}
                    }
                }
            }
        }
    )

    params = func.parameters
    assert params["properties"]["items"]["type"] == "array"
    assert params["properties"]["metadata"]["type"] == "object"
    print("✓ Parámetros complejos válidos")


def test_enum_parameter():
    """Test parámetro con enum."""
    func = FunctionDeclaration(
        name="with_enum",
        description="Función con enum",
        parameters={
            "type": "object",
            "properties": {
                "status": {
                    "type": "string",
                    "enum": ["active", "inactive", "pending"]
                }
            }
        }
    )

    enum_values = func.parameters["properties"]["status"]["enum"]
    assert "active" in enum_values
    assert len(enum_values) == 3
    print("✓ Enum válido")


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

---

## Resumen del concepto

**En una frase**: Una declaración de función es un contrato JSON Schema que le dice a Gemini qué funciones puede llamar, cuándo hacerlo, y qué datos necesita.

**Elementos críticos**:
1. `name`: Identificador único
2. `description`: **Lo más importante** - guía al modelo sobre cuándo usar la función
3. `parameters`: Estructura de datos que el modelo debe proporcionar
4. `required`: Lista de parámetros obligatorios

**Siguiente paso**: Tema 3.1.2 - Ciclo de Vida de Function Calling, donde veremos cómo ejecutar las funciones cuando el modelo las invoque.
