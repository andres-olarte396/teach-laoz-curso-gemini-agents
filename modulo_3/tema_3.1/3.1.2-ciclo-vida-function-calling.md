# Ciclo de Vida de Function Calling

**Tiempo estimado**: 50 minutos
**Nivel**: Intermedio
**Prerrequisitos**: Declaración de funciones (3.1.1)

## ¿Por qué importa este concepto?

Entender el ciclo completo de Function Calling te permite construir agentes que realmente interactúan con el mundo. El flujo es:

```
Usuario → Modelo → [Decide llamar función] → Tu código → Modelo → Respuesta final
```

Este es el puente entre "chatbot que habla" y "agente que actúa".

---

## El ciclo completo

```
┌──────────────┐
│   Usuario    │
│  "¿Qué hora  │
│  es en NYC?" │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│   Gemini     │
│  (Analiza)   │
│              │
│ "Necesito    │
│ get_time()"  │
└──────┬───────┘
       │
       ▼ Function Call
┌──────────────┐
│  Tu código   │
│              │
│ get_time(    │
│   "NYC"      │
│ )            │
│  → "14:30"   │
└──────┬───────┘
       │
       ▼ Resultado
┌──────────────┐
│   Gemini     │
│  (Responde)  │
│              │
│ "Son las     │
│  2:30 PM     │
│  en NYC"     │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│   Usuario    │
└──────────────┘
```

---

## Implementación paso a paso

### 1. Definir la función y herramienta

```python
import google.generativeai as genai
from google.generativeai.types import FunctionDeclaration, Tool
import os
from datetime import datetime
import pytz

genai.configure(api_key=os.environ["GOOGLE_API_KEY"])


# Declaración de la función para Gemini
get_time_function = FunctionDeclaration(
    name="get_current_time",
    description="Obtiene la hora actual en una zona horaria específica",
    parameters={
        "type": "object",
        "properties": {
            "timezone": {
                "type": "string",
                "description": "Zona horaria (ej: 'America/New_York', 'Europe/Madrid')"
            }
        },
        "required": ["timezone"]
    }
)

# La implementación REAL de la función
def get_current_time(timezone: str) -> str:
    """Implementación real de la función."""
    try:
        tz = pytz.timezone(timezone)
        now = datetime.now(tz)
        return now.strftime("%H:%M:%S %Z")
    except Exception as e:
        return f"Error: {str(e)}"


# Crear herramienta
time_tool = Tool(function_declarations=[get_time_function])

# Modelo con la herramienta
model = genai.GenerativeModel(
    "gemini-1.5-flash",
    tools=[time_tool]
)
```

### 2. Enviar prompt y detectar function call

```python
def process_with_functions(prompt: str) -> str:
    """
    Procesa un prompt que puede requerir function calling.
    """
    # Paso 1: Enviar prompt inicial
    response = model.generate_content(prompt)

    # Paso 2: Verificar si el modelo quiere llamar una función
    if response.candidates[0].content.parts:
        for part in response.candidates[0].content.parts:
            # Verificar si hay function call
            if hasattr(part, 'function_call') and part.function_call:
                function_call = part.function_call
                function_name = function_call.name
                function_args = dict(function_call.args)

                print(f"Modelo solicita: {function_name}({function_args})")

                # Paso 3: Ejecutar la función
                result = execute_function(function_name, function_args)
                print(f"Resultado: {result}")

                # Paso 4: Enviar resultado al modelo
                response = model.generate_content([
                    prompt,
                    response.candidates[0].content,  # La respuesta con el function call
                    genai.protos.Content(
                        parts=[genai.protos.Part(
                            function_response=genai.protos.FunctionResponse(
                                name=function_name,
                                response={"result": result}
                            )
                        )]
                    )
                ])

    return response.text


def execute_function(name: str, args: dict) -> str:
    """Ejecuta una función por nombre."""
    functions = {
        "get_current_time": get_current_time,
        # Agregar más funciones aquí
    }

    if name not in functions:
        return f"Error: Función '{name}' no encontrada"

    return functions[name](**args)


# Uso
result = process_with_functions("¿Qué hora es en Nueva York?")
print(result)
```

---

## Implementación completa con múltiples funciones

```python
from dataclasses import dataclass
from typing import Callable, Dict, Any, Optional
import json


@dataclass
class FunctionResult:
    """Resultado de ejecutar una función."""
    success: bool
    result: Any
    error: Optional[str] = None


class FunctionCallingAgent:
    """Agente con capacidad de Function Calling."""

    def __init__(self, model_name: str = "gemini-1.5-flash"):
        self.functions: Dict[str, Callable] = {}
        self.declarations: list = []
        self.model_name = model_name
        self._model = None

    def register_function(
        self,
        func: Callable,
        description: str,
        parameters: dict,
        name: Optional[str] = None
    ):
        """
        Registra una función que el modelo puede llamar.

        Args:
            func: La función Python a ejecutar
            description: Descripción para el modelo
            parameters: JSON Schema de los parámetros
            name: Nombre de la función (default: func.__name__)
        """
        func_name = name or func.__name__

        # Guardar referencia a la función
        self.functions[func_name] = func

        # Crear declaración para el modelo
        self.declarations.append(FunctionDeclaration(
            name=func_name,
            description=description,
            parameters=parameters
        ))

        # Invalidar modelo cacheado
        self._model = None

    @property
    def model(self) -> genai.GenerativeModel:
        """Obtiene modelo con herramientas registradas."""
        if self._model is None:
            tool = Tool(function_declarations=self.declarations)
            self._model = genai.GenerativeModel(
                self.model_name,
                tools=[tool]
            )
        return self._model

    def _execute_function(self, name: str, args: dict) -> FunctionResult:
        """Ejecuta una función registrada."""
        if name not in self.functions:
            return FunctionResult(
                success=False,
                result=None,
                error=f"Función no encontrada: {name}"
            )

        try:
            result = self.functions[name](**args)
            return FunctionResult(success=True, result=result)
        except Exception as e:
            return FunctionResult(
                success=False,
                result=None,
                error=f"{type(e).__name__}: {str(e)}"
            )

    def run(self, prompt: str, max_iterations: int = 5) -> str:
        """
        Ejecuta el agente con un prompt.

        Args:
            prompt: Mensaje del usuario
            max_iterations: Máximo de ciclos function call

        Returns:
            Respuesta final del modelo
        """
        messages = [prompt]
        iterations = 0

        while iterations < max_iterations:
            iterations += 1

            # Generar respuesta
            response = self.model.generate_content(messages)

            # Buscar function calls
            function_calls = []
            for part in response.candidates[0].content.parts:
                if hasattr(part, 'function_call') and part.function_call:
                    function_calls.append(part.function_call)

            # Si no hay function calls, terminamos
            if not function_calls:
                return response.text

            # Ejecutar cada function call
            messages.append(response.candidates[0].content)

            function_responses = []
            for fc in function_calls:
                name = fc.name
                args = dict(fc.args)

                print(f"[Iteración {iterations}] Llamando: {name}({json.dumps(args)})")

                result = self._execute_function(name, args)

                if result.success:
                    response_value = result.result
                else:
                    response_value = f"Error: {result.error}"

                print(f"  → Resultado: {response_value}")

                function_responses.append(
                    genai.protos.Part(
                        function_response=genai.protos.FunctionResponse(
                            name=name,
                            response={"result": str(response_value)}
                        )
                    )
                )

            # Agregar respuestas de funciones
            messages.append(genai.protos.Content(parts=function_responses))

        return "Máximo de iteraciones alcanzado"


# Ejemplo de uso completo
def demo_agent():
    """Demuestra el agente con múltiples funciones."""

    agent = FunctionCallingAgent()

    # Registrar funciones
    agent.register_function(
        func=get_current_time,
        description="Obtiene la hora actual en una zona horaria",
        parameters={
            "type": "object",
            "properties": {
                "timezone": {
                    "type": "string",
                    "description": "Zona horaria IANA (ej: 'America/New_York')"
                }
            },
            "required": ["timezone"]
        }
    )

    def calculate(expression: str) -> float:
        """Calcula una expresión matemática."""
        # NOTA: En producción, usar un parser seguro
        allowed = set("0123456789+-*/(). ")
        if not all(c in allowed for c in expression):
            raise ValueError("Expresión no permitida")
        return eval(expression)

    agent.register_function(
        func=calculate,
        description="Realiza cálculos matemáticos",
        parameters={
            "type": "object",
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Expresión matemática a evaluar"
                }
            },
            "required": ["expression"]
        }
    )

    def get_weather(city: str) -> dict:
        """Simula obtener el clima (en producción: llamar API real)."""
        # Datos simulados
        weather_data = {
            "Madrid": {"temp": 22, "condition": "soleado"},
            "London": {"temp": 15, "condition": "nublado"},
            "New York": {"temp": 18, "condition": "parcialmente nublado"},
        }
        return weather_data.get(city, {"temp": 20, "condition": "desconocido"})

    agent.register_function(
        func=get_weather,
        description="Obtiene el clima actual de una ciudad",
        parameters={
            "type": "object",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "Nombre de la ciudad"
                }
            },
            "required": ["city"]
        }
    )

    # Probar el agente
    queries = [
        "¿Qué hora es en Madrid?",
        "Calcula 15% de 250",
        "¿Cómo está el clima en Londres y qué hora es allí?",
    ]

    for query in queries:
        print(f"\n{'='*50}")
        print(f"Usuario: {query}")
        print("-" * 50)
        result = agent.run(query)
        print(f"\nRespuesta: {result}")


# demo_agent()
```

---

## Manejo de errores y edge cases

```python
class RobustFunctionCallingAgent(FunctionCallingAgent):
    """Versión robusta con mejor manejo de errores."""

    def _execute_function(self, name: str, args: dict) -> FunctionResult:
        """Ejecuta función con retry y timeout."""
        import time

        max_retries = 3
        for attempt in range(max_retries):
            try:
                result = super()._execute_function(name, args)
                if result.success:
                    return result
            except Exception as e:
                if attempt < max_retries - 1:
                    time.sleep(0.5 * (attempt + 1))
                    continue
                return FunctionResult(
                    success=False,
                    result=None,
                    error=f"Falló después de {max_retries} intentos: {e}"
                )

        return result

    def run(self, prompt: str, **kwargs) -> str:
        """Run con manejo de errores adicional."""
        try:
            return super().run(prompt, **kwargs)
        except Exception as e:
            return f"Error del agente: {type(e).__name__}: {str(e)}"
```

---

## Casos de prueba

```python
# test_function_calling.py
import pytest


def test_function_registration():
    """Test registro de funciones."""
    agent = FunctionCallingAgent()

    def my_func(x: int) -> int:
        return x * 2

    agent.register_function(
        func=my_func,
        description="Duplica un número",
        parameters={
            "type": "object",
            "properties": {"x": {"type": "integer"}},
            "required": ["x"]
        }
    )

    assert "my_func" in agent.functions
    assert len(agent.declarations) == 1
    print("✓ Registro de funciones")


def test_function_execution():
    """Test ejecución de funciones."""
    agent = FunctionCallingAgent()

    def add(a: int, b: int) -> int:
        return a + b

    agent.register_function(
        func=add,
        description="Suma dos números",
        parameters={
            "type": "object",
            "properties": {
                "a": {"type": "integer"},
                "b": {"type": "integer"}
            },
            "required": ["a", "b"]
        }
    )

    result = agent._execute_function("add", {"a": 2, "b": 3})
    assert result.success
    assert result.result == 5
    print("✓ Ejecución de funciones")


def test_error_handling():
    """Test manejo de errores."""
    agent = FunctionCallingAgent()

    def failing_func():
        raise ValueError("Error intencional")

    agent.register_function(
        func=failing_func,
        description="Función que falla",
        parameters={"type": "object", "properties": {}}
    )

    result = agent._execute_function("failing_func", {})
    assert not result.success
    assert "Error intencional" in result.error
    print("✓ Manejo de errores")


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

---

## Resumen del concepto

**En una frase**: El ciclo de Function Calling es: Usuario → Modelo detecta necesidad → Tu código ejecuta → Resultado vuelve al modelo → Respuesta final.

**Flujo clave**:
1. Registrar funciones con declaraciones
2. Detectar `function_call` en la respuesta
3. Ejecutar la función real
4. Enviar resultado como `function_response`
5. Obtener respuesta final

**Siguiente paso**: Tema 3.1.3 - Parallel Function Calling (llamadas simultáneas).
