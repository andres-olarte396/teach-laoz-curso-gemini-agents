# Manejo de Respuestas Asíncronas

**Tiempo estimado**: 40 minutos
**Nivel**: Intermedio-Avanzado
**Prerrequisitos**: APIs REST y Autenticación (3.3.1)

## ¿Por qué importa este concepto?

Muchas operaciones del mundo real no son instantáneas:

- Procesamiento de archivos grandes
- Generación de reportes
- Operaciones de ML/IA
- Transacciones bancarias
- Envío de emails masivos

Los agentes deben manejar operaciones que retornan inmediatamente un ID y requieren polling o webhooks para obtener el resultado final.

---

## Patrones de comunicación asíncrona

```
┌─────────────────────────────────────────────────────────────────┐
│ PATRÓN 1: POLLING                                               │
│ ────────────────                                                │
│                                                                 │
│ Cliente ──► POST /jobs ──► {job_id: "123"}                     │
│    │                                                            │
│    ├──► GET /jobs/123 ──► {status: "pending"}                  │
│    ├──► GET /jobs/123 ──► {status: "processing"}               │
│    └──► GET /jobs/123 ──► {status: "completed", result: ...}   │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│ PATRÓN 2: WEBHOOKS                                              │
│ ──────────────────                                              │
│                                                                 │
│ Cliente ──► POST /jobs {callback_url: "..."} ──► {job_id}      │
│                                                                 │
│ [Tiempo después...]                                             │
│                                                                 │
│ Servidor ──► POST callback_url {job_id, status, result}        │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│ PATRÓN 3: LONG POLLING                                          │
│ ──────────────────────                                          │
│                                                                 │
│ Cliente ──► GET /jobs/123?wait=true ──► [espera hasta listo]   │
│                                    └──► {status: "completed"}  │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│ PATRÓN 4: SERVER-SENT EVENTS (SSE)                              │
│ ──────────────────────────────────                              │
│                                                                 │
│ Cliente ──► GET /jobs/123/stream                                │
│        ◄── event: progress, data: 25%                          │
│        ◄── event: progress, data: 50%                          │
│        ◄── event: complete, data: {result}                     │
└─────────────────────────────────────────────────────────────────┘
```

---

## Implementación práctica

### Gestor de jobs asíncronos

```python
import asyncio
import time
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, Callable, List
from enum import Enum
from concurrent.futures import ThreadPoolExecutor
import uuid


class JobStatus(Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


@dataclass
class AsyncJob:
    """Representa un job asíncrono."""
    id: str
    status: JobStatus = JobStatus.PENDING
    progress: float = 0.0
    result: Any = None
    error: Optional[str] = None
    created_at: float = field(default_factory=time.time)
    updated_at: float = field(default_factory=time.time)
    metadata: Dict = field(default_factory=dict)

    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "status": self.status.value,
            "progress": self.progress,
            "result": self.result,
            "error": self.error,
            "created_at": self.created_at,
            "elapsed_seconds": time.time() - self.created_at
        }


class AsyncJobManager:
    """Gestor de jobs asíncronos con polling."""

    def __init__(self, max_workers: int = 5):
        self.jobs: Dict[str, AsyncJob] = {}
        self.executor = ThreadPoolExecutor(max_workers=max_workers)

    def create_job(self, metadata: Dict = None) -> AsyncJob:
        """Crea un nuevo job."""
        job = AsyncJob(
            id=str(uuid.uuid4()),
            metadata=metadata or {}
        )
        self.jobs[job.id] = job
        return job

    def get_job(self, job_id: str) -> Optional[AsyncJob]:
        """Obtiene estado de un job."""
        return self.jobs.get(job_id)

    def update_job(
        self,
        job_id: str,
        status: JobStatus = None,
        progress: float = None,
        result: Any = None,
        error: str = None
    ):
        """Actualiza un job."""
        job = self.jobs.get(job_id)
        if not job:
            return

        if status:
            job.status = status
        if progress is not None:
            job.progress = progress
        if result is not None:
            job.result = result
        if error:
            job.error = error

        job.updated_at = time.time()

    def submit(
        self,
        func: Callable,
        *args,
        metadata: Dict = None,
        **kwargs
    ) -> AsyncJob:
        """
        Envía una función para ejecución asíncrona.

        Args:
            func: Función a ejecutar
            args, kwargs: Argumentos de la función
            metadata: Metadata del job

        Returns:
            Job creado
        """
        job = self.create_job(metadata)

        def wrapper():
            try:
                self.update_job(job.id, status=JobStatus.PROCESSING)
                result = func(*args, **kwargs)
                self.update_job(
                    job.id,
                    status=JobStatus.COMPLETED,
                    progress=100.0,
                    result=result
                )
            except Exception as e:
                self.update_job(
                    job.id,
                    status=JobStatus.FAILED,
                    error=str(e)
                )

        self.executor.submit(wrapper)
        return job

    def wait_for_completion(
        self,
        job_id: str,
        timeout: float = 300,
        poll_interval: float = 1.0
    ) -> AsyncJob:
        """
        Espera a que un job complete (polling).

        Args:
            job_id: ID del job
            timeout: Timeout en segundos
            poll_interval: Intervalo de polling

        Returns:
            Job completado o con timeout
        """
        start = time.time()

        while time.time() - start < timeout:
            job = self.get_job(job_id)

            if not job:
                raise ValueError(f"Job not found: {job_id}")

            if job.status in [JobStatus.COMPLETED, JobStatus.FAILED, JobStatus.CANCELLED]:
                return job

            time.sleep(poll_interval)

        # Timeout
        job = self.get_job(job_id)
        if job:
            job.status = JobStatus.FAILED
            job.error = f"Timeout after {timeout}s"
        return job


# Cliente para APIs con operaciones asíncronas
class AsyncAPIClient:
    """Cliente para APIs que retornan jobs asíncronos."""

    def __init__(
        self,
        base_url: str,
        auth_header: Dict = None,
        default_timeout: float = 300
    ):
        self.base_url = base_url
        self.auth_header = auth_header or {}
        self.default_timeout = default_timeout
        # Importar requests aquí para evitar dependencia circular
        import requests
        self.session = requests.Session()
        self.session.headers.update(auth_header or {})

    def submit_job(self, endpoint: str, payload: Dict) -> Dict:
        """Envía un job a la API."""
        response = self.session.post(
            f"{self.base_url}{endpoint}",
            json=payload
        )
        response.raise_for_status()
        return response.json()

    def check_job_status(self, status_endpoint: str) -> Dict:
        """Consulta el estado de un job."""
        response = self.session.get(f"{self.base_url}{status_endpoint}")
        response.raise_for_status()
        return response.json()

    def wait_for_job(
        self,
        status_endpoint: str,
        timeout: float = None,
        poll_interval: float = 2.0,
        completed_statuses: List[str] = None
    ) -> Dict:
        """
        Espera a que un job complete con polling.

        Args:
            status_endpoint: Endpoint para consultar estado
            timeout: Timeout en segundos
            poll_interval: Intervalo entre polls
            completed_statuses: Estados que indican completitud

        Returns:
            Respuesta final del job
        """
        timeout = timeout or self.default_timeout
        completed_statuses = completed_statuses or ["completed", "failed", "error"]

        start = time.time()

        while time.time() - start < timeout:
            status = self.check_job_status(status_endpoint)

            if status.get("status", "").lower() in completed_statuses:
                return status

            # Extraer progreso si existe
            progress = status.get("progress", 0)
            print(f"Job progress: {progress}%")

            time.sleep(poll_interval)

        return {"status": "timeout", "error": f"Timeout after {timeout}s"}

    def submit_and_wait(
        self,
        submit_endpoint: str,
        payload: Dict,
        status_endpoint_template: str = "/jobs/{job_id}",
        **wait_kwargs
    ) -> Dict:
        """
        Envía un job y espera su completitud.

        Args:
            submit_endpoint: Endpoint para enviar job
            payload: Payload del job
            status_endpoint_template: Template del endpoint de estado
            wait_kwargs: Argumentos para wait_for_job

        Returns:
            Resultado final
        """
        # Enviar job
        submit_response = self.submit_job(submit_endpoint, payload)
        job_id = submit_response.get("job_id") or submit_response.get("id")

        if not job_id:
            return {"error": "No job_id in response", "response": submit_response}

        # Construir endpoint de estado
        status_endpoint = status_endpoint_template.format(job_id=job_id)

        # Esperar completitud
        return self.wait_for_job(status_endpoint, **wait_kwargs)
```

### Tool para operaciones asíncronas

```python
class AsyncOperationTool:
    """Tool para manejar operaciones asíncronas."""

    def __init__(self):
        self.job_manager = AsyncJobManager()
        self.pending_jobs: Dict[str, Dict] = {}

    def get_tool_definitions(self) -> List[Dict]:
        """Retorna definiciones de tools."""
        return [
            {
                "name": "start_async_operation",
                "description": """
Inicia una operación asíncrona de larga duración.
Retorna un job_id que puede usarse para consultar el estado.

Tipos de operaciones:
- report_generation: Genera reportes complejos
- data_export: Exporta grandes volúmenes de datos
- batch_processing: Procesa múltiples items
""",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "operation_type": {
                            "type": "string",
                            "enum": ["report_generation", "data_export", "batch_processing"]
                        },
                        "parameters": {
                            "type": "object",
                            "description": "Parámetros específicos de la operación"
                        }
                    },
                    "required": ["operation_type", "parameters"]
                }
            },
            {
                "name": "check_operation_status",
                "description": "Consulta el estado de una operación asíncrona",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "job_id": {
                            "type": "string",
                            "description": "ID del job a consultar"
                        }
                    },
                    "required": ["job_id"]
                }
            },
            {
                "name": "wait_for_operation",
                "description": "Espera a que una operación asíncrona complete",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "job_id": {
                            "type": "string",
                            "description": "ID del job"
                        },
                        "timeout_seconds": {
                            "type": "integer",
                            "description": "Timeout máximo en segundos (default: 60)"
                        }
                    },
                    "required": ["job_id"]
                }
            }
        ]

    def execute(self, tool_name: str, **kwargs) -> Dict:
        """Ejecuta una tool."""
        handlers = {
            "start_async_operation": self._start_operation,
            "check_operation_status": self._check_status,
            "wait_for_operation": self._wait_operation
        }

        handler = handlers.get(tool_name)
        if not handler:
            return {"error": f"Unknown tool: {tool_name}"}

        return handler(**kwargs)

    def _start_operation(
        self,
        operation_type: str,
        parameters: Dict
    ) -> Dict:
        """Inicia una operación asíncrona."""

        # Simular diferentes tipos de operaciones
        operation_funcs = {
            "report_generation": self._simulate_report_generation,
            "data_export": self._simulate_data_export,
            "batch_processing": self._simulate_batch_processing
        }

        func = operation_funcs.get(operation_type)
        if not func:
            return {"error": f"Unknown operation type: {operation_type}"}

        job = self.job_manager.submit(
            func,
            parameters,
            metadata={"operation_type": operation_type}
        )

        return {
            "job_id": job.id,
            "status": "submitted",
            "message": f"Operation '{operation_type}' started. Use job_id to check status."
        }

    def _check_status(self, job_id: str) -> Dict:
        """Consulta estado de un job."""
        job = self.job_manager.get_job(job_id)

        if not job:
            return {"error": f"Job not found: {job_id}"}

        return job.to_dict()

    def _wait_operation(
        self,
        job_id: str,
        timeout_seconds: int = 60
    ) -> Dict:
        """Espera a que complete una operación."""
        try:
            job = self.job_manager.wait_for_completion(
                job_id,
                timeout=timeout_seconds,
                poll_interval=1.0
            )
            return job.to_dict()
        except ValueError as e:
            return {"error": str(e)}

    # Simulaciones de operaciones
    def _simulate_report_generation(self, params: Dict) -> Dict:
        """Simula generación de reporte."""
        time.sleep(3)  # Simular trabajo
        return {
            "report_url": f"https://example.com/reports/{uuid.uuid4()}.pdf",
            "pages": 15,
            "generated_at": time.strftime("%Y-%m-%d %H:%M:%S")
        }

    def _simulate_data_export(self, params: Dict) -> Dict:
        """Simula exportación de datos."""
        time.sleep(5)
        return {
            "file_url": f"https://example.com/exports/{uuid.uuid4()}.csv",
            "rows_exported": 10000,
            "size_mb": 25.5
        }

    def _simulate_batch_processing(self, params: Dict) -> Dict:
        """Simula procesamiento por lotes."""
        items = params.get("items", [])
        time.sleep(len(items) * 0.5)  # 0.5s por item
        return {
            "processed": len(items),
            "successful": len(items),
            "failed": 0
        }
```

---

## Integración con agente

```python
import google.generativeai as genai


class AsyncCapableAgent:
    """Agente que puede manejar operaciones asíncronas."""

    def __init__(self):
        genai.configure(api_key="TU_API_KEY")
        self.async_tool = AsyncOperationTool()
        self.model = genai.GenerativeModel(
            "gemini-1.5-flash",
            tools=self.async_tool.get_tool_definitions()
        )

    def handle_request(self, user_request: str) -> str:
        """
        Maneja un request que puede requerir operaciones asíncronas.
        """
        chat = self.model.start_chat()
        response = chat.send_message(user_request)

        # Procesar function calls iterativamente
        while True:
            function_calls = []

            for part in response.candidates[0].content.parts:
                if hasattr(part, 'function_call'):
                    function_calls.append(part.function_call)

            if not function_calls:
                break

            # Ejecutar todas las function calls
            function_responses = []
            for fc in function_calls:
                result = self.async_tool.execute(
                    fc.name,
                    **dict(fc.args)
                )

                function_responses.append(
                    genai.protos.Part(
                        function_response=genai.protos.FunctionResponse(
                            name=fc.name,
                            response={"result": result}
                        )
                    )
                )

            # Enviar resultados al modelo
            response = chat.send_message(
                genai.protos.Content(parts=function_responses)
            )

        return response.text


# Uso
agent = AsyncCapableAgent()

# El agente maneja automáticamente operaciones asíncronas
result = agent.handle_request(
    "Genera un reporte de ventas del último mes y espera a que esté listo"
)
print(result)
```

---

## Errores frecuentes

### Error 1: Polling demasiado agresivo

```python
# ❌ Polling cada 100ms sobrecarga el servidor
while not is_complete:
    status = check_status()
    time.sleep(0.1)

# ✓ Backoff exponencial
delay = 1.0
max_delay = 30.0
while not is_complete:
    status = check_status()
    time.sleep(delay)
    delay = min(delay * 1.5, max_delay)
```

### Error 2: No manejar timeouts

```python
# ❌ Espera infinita
while job.status != "completed":
    time.sleep(1)

# ✓ Con timeout
start = time.time()
timeout = 300
while job.status != "completed":
    if time.time() - start > timeout:
        raise TimeoutError("Job timed out")
    time.sleep(1)
```

---

## Resumen del concepto

**En una frase**: El manejo de operaciones asíncronas permite a los agentes iniciar tareas de larga duración y monitorear su progreso sin bloquear.

**Patrones principales**:
- **Polling**: Consultar estado periódicamente
- **Webhooks**: Recibir notificación al completar
- **Long polling**: Conexión que espera hasta completar
- **SSE/WebSockets**: Actualizaciones en tiempo real

**Mejores prácticas**:
1. Backoff exponencial en polling
2. Siempre usar timeouts
3. Manejar estados de error
4. Informar progreso al usuario

**Siguiente paso**: Tema 3.3.3 - Rate Limiting y Retry Patterns.
