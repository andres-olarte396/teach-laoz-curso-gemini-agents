# APIs REST y Autenticación

**Tiempo estimado**: 45 minutos
**Nivel**: Intermedio
**Prerrequisitos**: Herramientas de Ejecución de Código (3.2.3)

## ¿Por qué importa este concepto?

Los agentes que interactúan con el mundo real necesitan comunicarse con servicios externos mediante APIs. Esto requiere:

- Entender estructuras de APIs REST
- Manejar autenticación de forma segura
- Transformar datos entre formatos
- Manejar errores de red y HTTP

Las APIs son el puente entre agentes y servicios como bases de datos, SaaS, IoT, y sistemas empresariales.

---

## Arquitectura de integración

```
┌─────────────────────────────────────────────────────────────────┐
│                        AGENTE                                   │
│                          │                                      │
│                    ┌─────┴─────┐                                │
│                    │ API Tool  │                                │
│                    └─────┬─────┘                                │
│                          │                                      │
│              ┌───────────┼───────────┐                          │
│              ▼           ▼           ▼                          │
│         ┌────────┐  ┌────────┐  ┌────────┐                     │
│         │ Auth   │  │Request │  │Response│                     │
│         │Manager │  │Builder │  │Parser  │                     │
│         └────┬───┘  └────┬───┘  └────┬───┘                     │
│              │           │           │                          │
│              └───────────┼───────────┘                          │
│                          ▼                                      │
│                    ┌──────────┐                                 │
│                    │ HTTP     │                                 │
│                    │ Client   │                                 │
│                    └────┬─────┘                                 │
└─────────────────────────┼───────────────────────────────────────┘
                          │
              ┌───────────┴───────────┐
              ▼           ▼           ▼
         [API 1]     [API 2]     [API 3]
```

---

## Implementación práctica

### Cliente HTTP base

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, Callable
from enum import Enum
from abc import ABC, abstractmethod
import requests
import json
import time
from urllib.parse import urljoin


class HTTPMethod(Enum):
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    PATCH = "PATCH"
    DELETE = "DELETE"


@dataclass
class APIResponse:
    """Respuesta estandarizada de API."""
    status_code: int
    data: Any
    headers: Dict
    elapsed_ms: float
    success: bool = True
    error: Optional[str] = None

    @property
    def is_success(self) -> bool:
        return 200 <= self.status_code < 300


@dataclass
class APIRequest:
    """Request estructurado."""
    method: HTTPMethod
    endpoint: str
    params: Dict = field(default_factory=dict)
    body: Any = None
    headers: Dict = field(default_factory=dict)


class HTTPClient:
    """Cliente HTTP con funcionalidades comunes."""

    def __init__(
        self,
        base_url: str,
        default_headers: Dict = None,
        timeout: float = 30.0
    ):
        self.base_url = base_url.rstrip('/')
        self.default_headers = default_headers or {}
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update(self.default_headers)

    def request(self, req: APIRequest) -> APIResponse:
        """Ejecuta un request HTTP."""
        url = urljoin(self.base_url + '/', req.endpoint.lstrip('/'))

        headers = {**self.default_headers, **req.headers}

        try:
            start = time.time()

            response = self.session.request(
                method=req.method.value,
                url=url,
                params=req.params,
                json=req.body if req.body else None,
                headers=headers,
                timeout=self.timeout
            )

            elapsed = (time.time() - start) * 1000

            # Intentar parsear JSON
            try:
                data = response.json()
            except json.JSONDecodeError:
                data = response.text

            return APIResponse(
                status_code=response.status_code,
                data=data,
                headers=dict(response.headers),
                elapsed_ms=elapsed,
                success=response.ok
            )

        except requests.Timeout:
            return APIResponse(
                status_code=0,
                data=None,
                headers={},
                elapsed_ms=self.timeout * 1000,
                success=False,
                error="Request timed out"
            )

        except requests.RequestException as e:
            return APIResponse(
                status_code=0,
                data=None,
                headers={},
                elapsed_ms=0,
                success=False,
                error=str(e)
            )

    def get(self, endpoint: str, params: Dict = None) -> APIResponse:
        return self.request(APIRequest(HTTPMethod.GET, endpoint, params or {}))

    def post(self, endpoint: str, body: Any, params: Dict = None) -> APIResponse:
        return self.request(APIRequest(HTTPMethod.POST, endpoint, params or {}, body))

    def put(self, endpoint: str, body: Any) -> APIResponse:
        return self.request(APIRequest(HTTPMethod.PUT, endpoint, {}, body))

    def delete(self, endpoint: str) -> APIResponse:
        return self.request(APIRequest(HTTPMethod.DELETE, endpoint))
```

### Gestores de autenticación

```python
class AuthStrategy(ABC):
    """Estrategia base de autenticación."""

    @abstractmethod
    def apply(self, request: APIRequest) -> APIRequest:
        """Aplica autenticación al request."""
        pass

    @abstractmethod
    def refresh(self) -> bool:
        """Refresca credenciales si es necesario."""
        pass


class APIKeyAuth(AuthStrategy):
    """Autenticación con API Key."""

    def __init__(
        self,
        api_key: str,
        header_name: str = "X-API-Key",
        prefix: str = ""
    ):
        self.api_key = api_key
        self.header_name = header_name
        self.prefix = prefix

    def apply(self, request: APIRequest) -> APIRequest:
        value = f"{self.prefix}{self.api_key}" if self.prefix else self.api_key
        request.headers[self.header_name] = value
        return request

    def refresh(self) -> bool:
        return True  # API keys no expiran típicamente


class BearerTokenAuth(AuthStrategy):
    """Autenticación con Bearer Token."""

    def __init__(
        self,
        token: str,
        refresh_token: Optional[str] = None,
        refresh_url: Optional[str] = None,
        expires_at: Optional[float] = None
    ):
        self.token = token
        self.refresh_token = refresh_token
        self.refresh_url = refresh_url
        self.expires_at = expires_at

    def apply(self, request: APIRequest) -> APIRequest:
        request.headers["Authorization"] = f"Bearer {self.token}"
        return request

    def refresh(self) -> bool:
        if not self.refresh_token or not self.refresh_url:
            return False

        try:
            response = requests.post(
                self.refresh_url,
                json={"refresh_token": self.refresh_token}
            )

            if response.ok:
                data = response.json()
                self.token = data.get("access_token", self.token)
                self.refresh_token = data.get("refresh_token", self.refresh_token)
                self.expires_at = time.time() + data.get("expires_in", 3600)
                return True

        except Exception:
            pass

        return False

    @property
    def is_expired(self) -> bool:
        if not self.expires_at:
            return False
        return time.time() >= self.expires_at - 60  # 60s de margen


class OAuth2Auth(AuthStrategy):
    """Autenticación OAuth2 con Client Credentials."""

    def __init__(
        self,
        client_id: str,
        client_secret: str,
        token_url: str,
        scopes: List[str] = None
    ):
        self.client_id = client_id
        self.client_secret = client_secret
        self.token_url = token_url
        self.scopes = scopes or []
        self.token: Optional[str] = None
        self.expires_at: Optional[float] = None

    def _fetch_token(self) -> bool:
        """Obtiene un nuevo token."""
        try:
            response = requests.post(
                self.token_url,
                data={
                    "grant_type": "client_credentials",
                    "client_id": self.client_id,
                    "client_secret": self.client_secret,
                    "scope": " ".join(self.scopes)
                }
            )

            if response.ok:
                data = response.json()
                self.token = data["access_token"]
                self.expires_at = time.time() + data.get("expires_in", 3600)
                return True

        except Exception:
            pass

        return False

    def apply(self, request: APIRequest) -> APIRequest:
        if not self.token or self.is_expired:
            self._fetch_token()

        if self.token:
            request.headers["Authorization"] = f"Bearer {self.token}"

        return request

    def refresh(self) -> bool:
        return self._fetch_token()

    @property
    def is_expired(self) -> bool:
        if not self.expires_at:
            return True
        return time.time() >= self.expires_at - 60


class BasicAuth(AuthStrategy):
    """Autenticación HTTP Basic."""

    def __init__(self, username: str, password: str):
        self.username = username
        self.password = password

    def apply(self, request: APIRequest) -> APIRequest:
        import base64
        credentials = base64.b64encode(
            f"{self.username}:{self.password}".encode()
        ).decode()
        request.headers["Authorization"] = f"Basic {credentials}"
        return request

    def refresh(self) -> bool:
        return True
```

### Cliente API con autenticación

```python
class AuthenticatedAPIClient:
    """Cliente API con gestión de autenticación."""

    def __init__(
        self,
        base_url: str,
        auth: AuthStrategy,
        default_headers: Dict = None
    ):
        self.client = HTTPClient(base_url, default_headers)
        self.auth = auth

    def request(self, req: APIRequest) -> APIResponse:
        """Ejecuta request con autenticación."""
        # Refrescar token si es necesario
        if hasattr(self.auth, 'is_expired') and self.auth.is_expired:
            self.auth.refresh()

        # Aplicar autenticación
        authenticated_req = self.auth.apply(req)

        # Ejecutar request
        response = self.client.request(authenticated_req)

        # Manejar 401 con retry después de refresh
        if response.status_code == 401:
            if self.auth.refresh():
                authenticated_req = self.auth.apply(req)
                response = self.client.request(authenticated_req)

        return response

    def get(self, endpoint: str, params: Dict = None) -> APIResponse:
        return self.request(APIRequest(HTTPMethod.GET, endpoint, params or {}))

    def post(self, endpoint: str, body: Any) -> APIResponse:
        return self.request(APIRequest(HTTPMethod.POST, endpoint, {}, body))

    def put(self, endpoint: str, body: Any) -> APIResponse:
        return self.request(APIRequest(HTTPMethod.PUT, endpoint, {}, body))

    def delete(self, endpoint: str) -> APIResponse:
        return self.request(APIRequest(HTTPMethod.DELETE, endpoint))
```

### Tool de API REST para agentes

```python
class RESTAPITool:
    """Tool para que agentes interactúen con APIs REST."""

    def __init__(self):
        self.clients: Dict[str, AuthenticatedAPIClient] = {}

    def register_api(
        self,
        name: str,
        base_url: str,
        auth: AuthStrategy,
        description: str = ""
    ):
        """Registra una API disponible."""
        self.clients[name] = {
            "client": AuthenticatedAPIClient(base_url, auth),
            "description": description,
            "base_url": base_url
        }

    def get_tool_definitions(self) -> List[Dict]:
        """Retorna definiciones de tools para Gemini."""
        tools = []

        # Tool genérica de API
        tools.append({
            "name": "call_api",
            "description": f"""
Realiza llamadas a APIs REST configuradas.

APIs disponibles:
{self._list_apis()}

Métodos soportados: GET, POST, PUT, DELETE
""",
            "parameters": {
                "type": "object",
                "properties": {
                    "api_name": {
                        "type": "string",
                        "description": "Nombre de la API a llamar",
                        "enum": list(self.clients.keys())
                    },
                    "method": {
                        "type": "string",
                        "enum": ["GET", "POST", "PUT", "DELETE"],
                        "description": "Método HTTP"
                    },
                    "endpoint": {
                        "type": "string",
                        "description": "Endpoint de la API (ej: /users/123)"
                    },
                    "params": {
                        "type": "object",
                        "description": "Query parameters"
                    },
                    "body": {
                        "type": "object",
                        "description": "Request body (para POST/PUT)"
                    }
                },
                "required": ["api_name", "method", "endpoint"]
            }
        })

        return tools

    def _list_apis(self) -> str:
        """Lista APIs disponibles."""
        lines = []
        for name, info in self.clients.items():
            lines.append(f"- {name}: {info['description']} ({info['base_url']})")
        return "\n".join(lines)

    def execute(
        self,
        api_name: str,
        method: str,
        endpoint: str,
        params: Dict = None,
        body: Any = None
    ) -> Dict:
        """Ejecuta una llamada a API."""
        if api_name not in self.clients:
            return {
                "success": False,
                "error": f"API not found: {api_name}"
            }

        client = self.clients[api_name]["client"]
        http_method = HTTPMethod[method.upper()]

        request = APIRequest(
            method=http_method,
            endpoint=endpoint,
            params=params or {},
            body=body
        )

        response = client.request(request)

        return {
            "success": response.is_success,
            "status_code": response.status_code,
            "data": response.data,
            "elapsed_ms": response.elapsed_ms,
            "error": response.error
        }


# Ejemplo de configuración
api_tool = RESTAPITool()

# Registrar APIs
api_tool.register_api(
    name="github",
    base_url="https://api.github.com",
    auth=BearerTokenAuth("ghp_xxxxxxxxxxxx"),
    description="API de GitHub para repositorios, issues, PRs"
)

api_tool.register_api(
    name="openweather",
    base_url="https://api.openweathermap.org/data/2.5",
    auth=APIKeyAuth("your_api_key", header_name="appid", prefix=""),
    description="API de clima OpenWeatherMap"
)

api_tool.register_api(
    name="stripe",
    base_url="https://api.stripe.com/v1",
    auth=BasicAuth("sk_test_xxxx", ""),
    description="API de Stripe para pagos"
)
```

---

## Manejo seguro de credenciales

```python
import os
from dataclasses import dataclass
from typing import Dict, Optional


@dataclass
class SecureCredentialStore:
    """Almacén seguro de credenciales."""

    def __init__(self):
        self._credentials: Dict[str, str] = {}
        self._load_from_env()

    def _load_from_env(self):
        """Carga credenciales de variables de entorno."""
        prefixes = ['API_KEY_', 'TOKEN_', 'SECRET_']

        for key, value in os.environ.items():
            for prefix in prefixes:
                if key.startswith(prefix):
                    clean_key = key[len(prefix):].lower()
                    self._credentials[clean_key] = value

    def get(self, name: str) -> Optional[str]:
        """Obtiene una credencial."""
        return self._credentials.get(name.lower())

    def set(self, name: str, value: str):
        """Establece una credencial (solo en memoria)."""
        self._credentials[name.lower()] = value


# Uso seguro
credentials = SecureCredentialStore()

# Las credenciales vienen de variables de entorno
# export API_KEY_GITHUB=ghp_xxxx
# export TOKEN_STRIPE=sk_test_xxxx

github_auth = BearerTokenAuth(credentials.get("github"))
stripe_auth = APIKeyAuth(credentials.get("stripe"))
```

---

## Errores frecuentes

### Error 1: Credenciales en código

```python
# ❌ NUNCA hacer esto
api_key = "sk_live_1234567890abcdef"
client = APIClient(api_key=api_key)

# ✓ Usar variables de entorno
import os
api_key = os.environ.get("STRIPE_API_KEY")
if not api_key:
    raise ValueError("STRIPE_API_KEY not set")
client = APIClient(api_key=api_key)
```

### Error 2: No manejar errores de red

```python
# ❌ Asumir que siempre funciona
def bad_api_call(endpoint):
    response = requests.get(endpoint)
    return response.json()  # Puede fallar

# ✓ Manejar errores
def good_api_call(endpoint):
    try:
        response = requests.get(endpoint, timeout=10)
        response.raise_for_status()
        return {"success": True, "data": response.json()}
    except requests.Timeout:
        return {"success": False, "error": "Request timed out"}
    except requests.HTTPError as e:
        return {"success": False, "error": f"HTTP {e.response.status_code}"}
    except Exception as e:
        return {"success": False, "error": str(e)}
```

---

## Resumen del concepto

**En una frase**: Las tools de API REST permiten a los agentes interactuar con servicios externos de forma segura y estructurada.

**Estrategias de autenticación**:
- **API Key**: Simple, en header o query param
- **Bearer Token**: JWT o tokens OAuth
- **OAuth2**: Para acceso delegado
- **Basic Auth**: Usuario/contraseña

**Mejores prácticas**:
1. Credenciales en variables de entorno
2. Timeouts en todos los requests
3. Manejo robusto de errores
4. Refresh automático de tokens
5. Logging de requests (sin credenciales)

**Siguiente paso**: Tema 3.3.2 - Manejo de Respuestas Asíncronas.
