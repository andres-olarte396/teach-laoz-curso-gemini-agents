# Prompts de Planificación y Descomposición

**Tiempo estimado**: 45 minutos
**Nivel**: Intermedio-Avanzado
**Prerrequisitos**: Tree of Thoughts (2.2.3)

## ¿Por qué importa este concepto?

Los agentes de IA efectivos no ejecutan tareas complejas de un solo golpe. La planificación y descomposición son habilidades fundamentales que permiten:

- Dividir problemas complejos en subtareas manejables
- Crear secuencias de acciones ordenadas y dependientes
- Identificar recursos y prerequisitos antes de ejecutar
- Facilitar la verificación y corrección de errores
- Habilitar la paralelización cuando es posible

Frameworks como LangChain, AutoGPT y BabyAGI usan estos patrones extensivamente.

---

## Patrones de descomposición

```
┌─────────────────────────────────────────────────────────────────┐
│ DESCOMPOSICIÓN JERÁRQUICA                                       │
│ ─────────────────────────                                       │
│                                                                 │
│                    ┌─────────────────┐                          │
│                    │ Tarea Principal │                          │
│                    └────────┬────────┘                          │
│              ┌──────────────┼──────────────┐                    │
│              ▼              ▼              ▼                    │
│        ┌─────────┐    ┌─────────┐    ┌─────────┐               │
│        │Subtarea1│    │Subtarea2│    │Subtarea3│               │
│        └────┬────┘    └────┬────┘    └────┬────┘               │
│         ┌───┴───┐       ┌──┴──┐       ┌───┴───┐                │
│         ▼       ▼       ▼     ▼       ▼       ▼                │
│       [1.1]   [1.2]   [2.1] [2.2]   [3.1]   [3.2]              │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│ DESCOMPOSICIÓN SECUENCIAL                                       │
│ ─────────────────────────                                       │
│                                                                 │
│ Tarea → Paso 1 → Paso 2 → Paso 3 → Paso 4 → Resultado          │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│ DESCOMPOSICIÓN CON DEPENDENCIAS                                 │
│ ───────────────────────────────                                 │
│                                                                 │
│    ┌─────┐     ┌─────┐                                         │
│    │  A  │────►│  C  │─────┐                                   │
│    └─────┘     └─────┘     │     ┌─────┐                       │
│                            ├────►│  E  │                       │
│    ┌─────┐     ┌─────┐     │     └─────┘                       │
│    │  B  │────►│  D  │─────┘                                   │
│    └─────┘     └─────┘                                         │
│                                                                 │
│    A,B: paralelos | C,D: dependen de A,B | E: depende de C,D   │
└─────────────────────────────────────────────────────────────────┘
```

---

## Implementación práctica

### Framework de planificación

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Set
from enum import Enum
import json


class TaskStatus(Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    BLOCKED = "blocked"
    FAILED = "failed"


@dataclass
class Task:
    """Representa una tarea en el plan."""
    id: str
    description: str
    dependencies: List[str] = field(default_factory=list)
    subtasks: List['Task'] = field(default_factory=list)
    status: TaskStatus = TaskStatus.PENDING
    result: Optional[str] = None
    estimated_steps: int = 1
    tools_needed: List[str] = field(default_factory=list)

    @property
    def is_ready(self) -> bool:
        """Verifica si la tarea está lista para ejecutar."""
        return self.status == TaskStatus.PENDING and len(self.dependencies) == 0

    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "description": self.description,
            "dependencies": self.dependencies,
            "status": self.status.value,
            "subtasks": [st.to_dict() for st in self.subtasks],
            "tools_needed": self.tools_needed
        }


@dataclass
class Plan:
    """Representa un plan completo."""
    goal: str
    tasks: List[Task] = field(default_factory=list)
    context: Dict = field(default_factory=dict)

    def get_ready_tasks(self) -> List[Task]:
        """Obtiene tareas listas para ejecutar."""
        completed_ids = {t.id for t in self.tasks if t.status == TaskStatus.COMPLETED}
        ready = []
        for task in self.tasks:
            if task.status == TaskStatus.PENDING:
                deps_met = all(dep in completed_ids for dep in task.dependencies)
                if deps_met:
                    ready.append(task)
        return ready

    def mark_complete(self, task_id: str, result: str):
        """Marca una tarea como completada."""
        for task in self.tasks:
            if task.id == task_id:
                task.status = TaskStatus.COMPLETED
                task.result = result
                break

    def to_dict(self) -> Dict:
        return {
            "goal": self.goal,
            "tasks": [t.to_dict() for t in self.tasks],
            "context": self.context
        }


class PlanningEngine:
    """Motor de planificación y descomposición de tareas."""

    def __init__(self, model_name: str = "gemini-1.5-flash"):
        genai.configure(api_key="TU_API_KEY")
        self.model = genai.GenerativeModel(model_name)

    def decompose(
        self,
        goal: str,
        context: Optional[Dict] = None,
        available_tools: Optional[List[str]] = None
    ) -> Plan:
        """
        Descompone un objetivo en un plan de tareas.

        Args:
            goal: Objetivo a lograr
            context: Información contextual adicional
            available_tools: Herramientas disponibles para el agente

        Returns:
            Plan estructurado con tareas y dependencias
        """
        tools_str = ", ".join(available_tools) if available_tools else "ninguna específica"

        prompt = f"""
Eres un planificador experto. Descompón el siguiente objetivo en tareas concretas y ejecutables.

OBJETIVO:
{goal}

CONTEXTO:
{json.dumps(context or {}, indent=2)}

HERRAMIENTAS DISPONIBLES:
{tools_str}

INSTRUCCIONES:
1. Identifica las tareas principales necesarias
2. Descompón cada tarea en subtareas si es necesario
3. Identifica dependencias entre tareas
4. Asigna herramientas necesarias a cada tarea
5. Ordena las tareas considerando las dependencias

Responde en formato JSON:
{{
  "tasks": [
    {{
      "id": "T1",
      "description": "Descripción clara de la tarea",
      "dependencies": [],
      "subtasks": [
        {{"id": "T1.1", "description": "Subtarea", "dependencies": []}}
      ],
      "tools_needed": ["tool1", "tool2"],
      "estimated_steps": 3
    }}
  ],
  "execution_order": ["T1", "T2", "T3"],
  "parallelizable_groups": [["T1", "T2"], ["T3"]]
}}
"""
        response = self.model.generate_content(prompt)

        # Parsear respuesta JSON
        try:
            # Extraer JSON del texto
            text = response.text
            json_start = text.find('{')
            json_end = text.rfind('}') + 1
            plan_data = json.loads(text[json_start:json_end])
        except (json.JSONDecodeError, ValueError):
            # Fallback si no se puede parsear
            plan_data = {"tasks": [{"id": "T1", "description": goal, "dependencies": []}]}

        # Construir Plan
        tasks = []
        for task_data in plan_data.get("tasks", []):
            subtasks = [
                Task(
                    id=st["id"],
                    description=st["description"],
                    dependencies=st.get("dependencies", [])
                )
                for st in task_data.get("subtasks", [])
            ]

            task = Task(
                id=task_data["id"],
                description=task_data["description"],
                dependencies=task_data.get("dependencies", []),
                subtasks=subtasks,
                tools_needed=task_data.get("tools_needed", []),
                estimated_steps=task_data.get("estimated_steps", 1)
            )
            tasks.append(task)

        return Plan(goal=goal, tasks=tasks, context=context or {})

    def refine_task(self, task: Task, feedback: str) -> Task:
        """Refina una tarea basándose en feedback."""
        prompt = f"""
TAREA ORIGINAL:
{task.description}

FEEDBACK:
{feedback}

Refina la tarea considerando el feedback.
Proporciona una descripción más precisa y pasos más claros.

Responde con:
DESCRIPCIÓN REFINADA: [nueva descripción]
PASOS ESPECÍFICOS:
1. [paso 1]
2. [paso 2]
...
"""
        response = self.model.generate_content(prompt)

        # Actualizar tarea (simplificado)
        task.description = f"{task.description} (refinado: {response.text[:200]})"
        return task
```

### Uso del motor de planificación

```python
# Crear motor
planner = PlanningEngine()

# Definir objetivo y contexto
goal = """
Crear una API REST para un sistema de gestión de tareas (todo list) con:
- CRUD de tareas
- Autenticación de usuarios
- Base de datos PostgreSQL
- Tests automatizados
"""

context = {
    "framework": "FastAPI",
    "language": "Python",
    "database": "PostgreSQL",
    "testing": "pytest"
}

available_tools = [
    "write_file",
    "read_file",
    "execute_code",
    "run_tests",
    "search_documentation"
]

# Generar plan
plan = planner.decompose(goal, context, available_tools)

# Visualizar plan
print("="*60)
print("PLAN GENERADO")
print("="*60)
print(f"\nObjetivo: {plan.goal}\n")

for task in plan.tasks:
    deps = f" (depende de: {', '.join(task.dependencies)})" if task.dependencies else ""
    print(f"[{task.id}] {task.description}{deps}")
    print(f"    Herramientas: {', '.join(task.tools_needed)}")
    print(f"    Pasos estimados: {task.estimated_steps}")
    for subtask in task.subtasks:
        print(f"    └─ [{subtask.id}] {subtask.description}")
    print()
```

---

## Patrones avanzados de descomposición

### 1. Descomposición recursiva

```python
class RecursiveDecomposer:
    """
    Descompone tareas recursivamente hasta alcanzar
    tareas atómicas ejecutables.
    """

    def __init__(
        self,
        max_depth: int = 3,
        complexity_threshold: int = 3
    ):
        self.planner = PlanningEngine()
        self.max_depth = max_depth
        self.complexity_threshold = complexity_threshold

    def _estimate_complexity(self, task: Task) -> int:
        """Estima la complejidad de una tarea (1-10)."""
        prompt = f"""
Evalúa la complejidad de esta tarea en escala 1-10:
1-3: Simple, ejecutable en un paso
4-6: Moderada, requiere algunos pasos
7-10: Compleja, necesita descomposición

TAREA: {task.description}

Responde solo con el número.
"""
        response = self.planner.model.generate_content(prompt)
        try:
            return int(response.text.strip())
        except ValueError:
            return 5

    def decompose_recursive(
        self,
        goal: str,
        depth: int = 0
    ) -> Plan:
        """Descompone recursivamente hasta tareas atómicas."""
        # Descomposición inicial
        plan = self.planner.decompose(goal)

        if depth >= self.max_depth:
            return plan

        # Evaluar y descomponer tareas complejas
        refined_tasks = []
        for task in plan.tasks:
            complexity = self._estimate_complexity(task)

            if complexity > self.complexity_threshold:
                # Descomponer recursivamente
                sub_plan = self.decompose_recursive(
                    task.description,
                    depth + 1
                )

                # Agregar subtareas como tareas principales con prefijo
                for sub_task in sub_plan.tasks:
                    sub_task.id = f"{task.id}.{sub_task.id}"
                    # Actualizar dependencias
                    sub_task.dependencies = [
                        f"{task.id}.{d}" for d in sub_task.dependencies
                    ]
                    # Agregar dependencias originales de la tarea padre
                    if not sub_task.dependencies:
                        sub_task.dependencies = task.dependencies.copy()

                refined_tasks.extend(sub_plan.tasks)
            else:
                refined_tasks.append(task)

        plan.tasks = refined_tasks
        return plan


# Uso
recursive_decomposer = RecursiveDecomposer(max_depth=2, complexity_threshold=5)

complex_goal = """
Desarrollar un sistema de recomendación de películas que:
1. Recopile preferencias del usuario
2. Analice el historial de visualización
3. Use algoritmos de filtrado colaborativo
4. Presente recomendaciones personalizadas
5. Aprenda de la retroalimentación del usuario
"""

detailed_plan = recursive_decomposer.decompose_recursive(complex_goal)

print("PLAN DETALLADO:")
for task in detailed_plan.tasks:
    indent = "  " * task.id.count(".")
    print(f"{indent}[{task.id}] {task.description}")
```

### 2. Descomposición con análisis de dependencias

```python
from collections import defaultdict
import networkx as nx


class DependencyAwareDecomposer:
    """
    Descompone tareas manteniendo un grafo de dependencias
    para optimizar el orden de ejecución.
    """

    def __init__(self):
        self.planner = PlanningEngine()

    def decompose_with_dag(self, goal: str) -> Dict:
        """
        Descompone y genera un DAG (Directed Acyclic Graph)
        de dependencias.
        """
        plan = self.planner.decompose(goal)

        # Construir grafo de dependencias
        G = nx.DiGraph()

        for task in plan.tasks:
            G.add_node(task.id, task=task)
            for dep in task.dependencies:
                G.add_edge(dep, task.id)

        # Verificar que es un DAG (sin ciclos)
        if not nx.is_directed_acyclic_graph(G):
            raise ValueError("El plan tiene dependencias circulares")

        # Calcular orden topológico
        execution_order = list(nx.topological_sort(G))

        # Identificar tareas paralelas (mismo nivel topológico)
        levels = defaultdict(list)
        for task_id in execution_order:
            # El nivel es la longitud del camino más largo hasta este nodo
            if G.in_degree(task_id) == 0:
                level = 0
            else:
                level = max(
                    levels[pred][0] + 1
                    for pred in G.predecessors(task_id)
                    for _ in [1]  # Hack para acceder al nivel
                    if pred in dict(levels)
                ) if any(pred in dict(levels) for pred in G.predecessors(task_id)) else 0
            levels[task_id] = (level, G.nodes[task_id]['task'])

        # Agrupar por nivel
        parallel_groups = defaultdict(list)
        for task_id, (level, task) in levels.items():
            parallel_groups[level].append(task_id)

        # Calcular camino crítico
        critical_path = nx.dag_longest_path(G) if G.nodes else []

        return {
            "plan": plan,
            "execution_order": execution_order,
            "parallel_groups": dict(parallel_groups),
            "critical_path": critical_path,
            "total_levels": len(parallel_groups)
        }

    def visualize_dependencies(self, decomposition: Dict) -> str:
        """Genera una visualización ASCII del grafo."""
        output = []
        output.append("GRAFO DE DEPENDENCIAS:")
        output.append("=" * 40)

        for level, tasks in sorted(decomposition["parallel_groups"].items()):
            output.append(f"\nNivel {level}: {' | '.join(tasks)}")

        output.append(f"\nCAMINO CRÍTICO: {' → '.join(decomposition['critical_path'])}")

        return "\n".join(output)


# Uso
dag_decomposer = DependencyAwareDecomposer()

result = dag_decomposer.decompose_with_dag("""
Configurar un pipeline de CI/CD completo:
- Configurar repositorio Git
- Escribir Dockerfile
- Configurar GitHub Actions
- Configurar tests automatizados
- Configurar deploy a staging
- Configurar deploy a producción
""")

print(dag_decomposer.visualize_dependencies(result))
print(f"\nOrden de ejecución: {result['execution_order']}")
print(f"Grupos paralelos: {result['parallel_groups']}")
```

### 3. Descomposición adaptativa

```python
class AdaptiveDecomposer:
    """
    Descompone tareas y se adapta basándose en
    resultados de ejecución.
    """

    def __init__(self):
        self.planner = PlanningEngine()
        self.execution_history: List[Dict] = []

    def decompose_initial(self, goal: str) -> Plan:
        """Descomposición inicial."""
        return self.planner.decompose(goal)

    def adapt_plan(
        self,
        plan: Plan,
        completed_task: Task,
        execution_result: Dict
    ) -> Plan:
        """
        Adapta el plan basándose en el resultado de una tarea.
        """
        # Registrar resultado
        self.execution_history.append({
            "task_id": completed_task.id,
            "result": execution_result
        })

        # Analizar si necesitamos adaptar
        if execution_result.get("status") == "failed":
            return self._handle_failure(plan, completed_task, execution_result)

        if execution_result.get("discovered_requirements"):
            return self._add_new_tasks(
                plan,
                execution_result["discovered_requirements"]
            )

        if execution_result.get("can_skip"):
            return self._skip_related_tasks(
                plan,
                execution_result["can_skip"]
            )

        return plan

    def _handle_failure(
        self,
        plan: Plan,
        failed_task: Task,
        error: Dict
    ) -> Plan:
        """Maneja un fallo adaptando el plan."""
        prompt = f"""
Una tarea falló durante la ejecución.

TAREA FALLIDA:
{failed_task.description}

ERROR:
{error.get('message', 'Error desconocido')}

PLAN ACTUAL:
{json.dumps(plan.to_dict(), indent=2)}

Propón adaptaciones al plan:
1. ¿La tarea debería reintentar con modificaciones?
2. ¿Hay una alternativa a esta tarea?
3. ¿Qué tareas dependientes se ven afectadas?

Responde en JSON:
{{
  "action": "retry|alternative|abort",
  "modified_task": {{...}} si aplica,
  "alternative_task": {{...}} si aplica,
  "tasks_to_remove": ["id1", "id2"]
}}
"""
        response = self.planner.model.generate_content(prompt)

        # Parsear y aplicar adaptaciones
        try:
            text = response.text
            json_start = text.find('{')
            json_end = text.rfind('}') + 1
            adaptation = json.loads(text[json_start:json_end])

            if adaptation.get("action") == "retry" and adaptation.get("modified_task"):
                # Modificar tarea existente
                for task in plan.tasks:
                    if task.id == failed_task.id:
                        task.description = adaptation["modified_task"].get(
                            "description", task.description
                        )
                        task.status = TaskStatus.PENDING
                        break

            elif adaptation.get("action") == "alternative" and adaptation.get("alternative_task"):
                # Reemplazar con alternativa
                alt = adaptation["alternative_task"]
                new_task = Task(
                    id=f"{failed_task.id}_alt",
                    description=alt["description"],
                    dependencies=failed_task.dependencies
                )

                # Actualizar dependencias de otras tareas
                for task in plan.tasks:
                    if failed_task.id in task.dependencies:
                        task.dependencies.remove(failed_task.id)
                        task.dependencies.append(new_task.id)

                # Reemplazar tarea
                plan.tasks = [t for t in plan.tasks if t.id != failed_task.id]
                plan.tasks.append(new_task)

            elif adaptation.get("tasks_to_remove"):
                plan.tasks = [
                    t for t in plan.tasks
                    if t.id not in adaptation["tasks_to_remove"]
                ]

        except (json.JSONDecodeError, KeyError):
            # Si falla el parsing, marcar tarea como fallida
            failed_task.status = TaskStatus.FAILED

        return plan

    def _add_new_tasks(
        self,
        plan: Plan,
        new_requirements: List[str]
    ) -> Plan:
        """Agrega nuevas tareas descubiertas durante ejecución."""
        for i, req in enumerate(new_requirements):
            new_task = Task(
                id=f"NEW_{len(plan.tasks) + i}",
                description=req,
                dependencies=[]
            )
            plan.tasks.append(new_task)

        return plan

    def _skip_related_tasks(
        self,
        plan: Plan,
        tasks_to_skip: List[str]
    ) -> Plan:
        """Marca tareas como completadas si pueden saltarse."""
        for task in plan.tasks:
            if task.id in tasks_to_skip:
                task.status = TaskStatus.COMPLETED
                task.result = "Skipped - not needed"

        return plan
```

---

## Errores frecuentes

### Error 1: Tareas demasiado vagas

```python
# ❌ Tareas que no son ejecutables
bad_tasks = [
    Task(id="T1", description="Hacer el backend"),
    Task(id="T2", description="Implementar features"),
]

# ✓ Tareas específicas y ejecutables
good_tasks = [
    Task(
        id="T1",
        description="Crear endpoint POST /api/users para registro de usuarios",
        tools_needed=["write_file", "execute_code"]
    ),
    Task(
        id="T2",
        description="Implementar validación de email con regex en UserService",
        dependencies=["T1"]
    ),
]
```

### Error 2: Dependencias circulares

```python
# ❌ Ciclo de dependencias
bad_plan = Plan(
    goal="Ejemplo",
    tasks=[
        Task(id="A", description="Tarea A", dependencies=["C"]),
        Task(id="B", description="Tarea B", dependencies=["A"]),
        Task(id="C", description="Tarea C", dependencies=["B"]),
    ]
)
# A → C → B → A (¡ciclo!)

# ✓ Verificación de DAG
def validate_no_cycles(plan: Plan) -> bool:
    """Verifica que no hay ciclos en las dependencias."""
    visited = set()
    rec_stack = set()

    def dfs(task_id: str) -> bool:
        visited.add(task_id)
        rec_stack.add(task_id)

        task = next((t for t in plan.tasks if t.id == task_id), None)
        if task:
            for dep in task.dependencies:
                if dep not in visited:
                    if dfs(dep):
                        return True
                elif dep in rec_stack:
                    return True

        rec_stack.remove(task_id)
        return False

    for task in plan.tasks:
        if task.id not in visited:
            if dfs(task.id):
                return False
    return True
```

### Error 3: Granularidad inconsistente

```python
# ❌ Mezcla de tareas de diferentes tamaños
bad_granularity = [
    Task(id="T1", description="Configurar variable de entorno"),  # 1 minuto
    Task(id="T2", description="Desarrollar sistema completo de autenticación"),  # 1 semana
]

# ✓ Granularidad consistente
def normalize_granularity(tasks: List[Task], target_steps: int = 5) -> List[Task]:
    """Normaliza tareas a una granularidad similar."""
    normalized = []

    for task in tasks:
        if task.estimated_steps > target_steps * 2:
            # Descomponer tarea grande
            # (usar planner para descomponer)
            pass
        elif task.estimated_steps < target_steps / 2:
            # Agrupar con tareas similares
            # (mantener por ahora)
            normalized.append(task)
        else:
            normalized.append(task)

    return normalized
```

---

## Aplicaciones reales

### Aplicación 1: Agente de desarrollo de software

```python
class SoftwareDevAgent:
    """Agente que planifica y ejecuta tareas de desarrollo."""

    def __init__(self):
        self.decomposer = RecursiveDecomposer()
        self.current_plan: Optional[Plan] = None

    def plan_feature(self, feature_request: str, codebase_context: Dict) -> Plan:
        """Planifica la implementación de una feature."""

        goal = f"""
Implementar la siguiente feature:
{feature_request}

Contexto del codebase:
- Lenguaje: {codebase_context.get('language', 'Python')}
- Framework: {codebase_context.get('framework', 'No especificado')}
- Estructura: {codebase_context.get('structure', 'Estándar')}

El plan debe incluir:
1. Análisis de requisitos
2. Diseño de la solución
3. Implementación del código
4. Escritura de tests
5. Documentación
6. Code review checklist
"""
        self.current_plan = self.decomposer.decompose_recursive(goal)
        return self.current_plan

    def get_next_action(self) -> Optional[Task]:
        """Obtiene la siguiente tarea a ejecutar."""
        if not self.current_plan:
            return None

        ready_tasks = self.current_plan.get_ready_tasks()
        return ready_tasks[0] if ready_tasks else None

    def report_progress(self) -> Dict:
        """Reporta el progreso actual."""
        if not self.current_plan:
            return {"status": "no_plan"}

        total = len(self.current_plan.tasks)
        completed = sum(
            1 for t in self.current_plan.tasks
            if t.status == TaskStatus.COMPLETED
        )
        in_progress = sum(
            1 for t in self.current_plan.tasks
            if t.status == TaskStatus.IN_PROGRESS
        )

        return {
            "total_tasks": total,
            "completed": completed,
            "in_progress": in_progress,
            "pending": total - completed - in_progress,
            "progress_percent": (completed / total * 100) if total > 0 else 0
        }


# Uso
agent = SoftwareDevAgent()

plan = agent.plan_feature(
    "Agregar sistema de notificaciones push para la app móvil",
    {
        "language": "TypeScript",
        "framework": "React Native",
        "structure": "Monorepo con Nx"
    }
)

print("PLAN DE IMPLEMENTACIÓN:")
for task in plan.tasks:
    print(f"[{task.id}] {task.description}")

print(f"\nProgreso: {agent.report_progress()}")
```

### Aplicación 2: Sistema de onboarding automatizado

```python
class OnboardingPlanner:
    """Planifica el onboarding de nuevos empleados o usuarios."""

    def __init__(self):
        self.planner = PlanningEngine()

    def create_onboarding_plan(
        self,
        role: str,
        department: str,
        start_date: str,
        tools: List[str]
    ) -> Plan:
        """Crea un plan de onboarding personalizado."""

        goal = f"""
Crear plan de onboarding para:
- Rol: {role}
- Departamento: {department}
- Fecha inicio: {start_date}
- Herramientas a configurar: {', '.join(tools)}

El plan debe cubrir:
1. Preparación pre-inicio (IT, accesos)
2. Día 1: Bienvenida y orientación
3. Semana 1: Configuración de herramientas y capacitación básica
4. Semana 2-4: Capacitación específica del rol
5. Mes 1-3: Integración al equipo y proyectos

Incluir checkpoints de verificación y responsables.
"""
        plan = self.planner.decompose(goal)

        # Agregar metadata específica de onboarding
        plan.context = {
            "role": role,
            "department": department,
            "start_date": start_date,
            "tools": tools
        }

        return plan


# Uso
onboarding = OnboardingPlanner()

plan = onboarding.create_onboarding_plan(
    role="Senior Software Engineer",
    department="Platform Team",
    start_date="2024-02-01",
    tools=["GitHub", "Jira", "Slack", "AWS Console", "Datadog"]
)

print("PLAN DE ONBOARDING:")
print(json.dumps(plan.to_dict(), indent=2))
```

---

## Resumen del concepto

**En una frase**: La descomposición de tareas convierte objetivos complejos en planes estructurados de subtareas ejecutables con dependencias claras.

**Patrones clave**:
1. **Jerárquica**: Divide en niveles de abstracción
2. **Secuencial**: Ordena pasos linealmente
3. **Con dependencias**: Modela prerequisitos como DAG
4. **Recursiva**: Descompone hasta alcanzar tareas atómicas
5. **Adaptativa**: Ajusta el plan según resultados

**Principios de buena descomposición**:
- Tareas específicas y ejecutables
- Granularidad consistente
- Dependencias explícitas sin ciclos
- Verificabilidad de completitud

**Siguiente paso**: Tema 2.3.2 - Prompts de Reflexión y Auto-Crítica.
