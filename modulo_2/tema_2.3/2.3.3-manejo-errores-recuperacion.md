# Manejo de Errores y Recuperación

**Tiempo estimado**: 45 minutos
**Nivel**: Avanzado
**Prerrequisitos**: Prompts de Reflexión y Auto-Crítica (2.3.2)

## ¿Por qué importa este concepto?

Los agentes de IA inevitablemente encontrarán errores: llamadas a API fallidas, respuestas malformadas, razonamiento incorrecto, herramientas que no funcionan. La diferencia entre un agente robusto y uno frágil está en cómo maneja estos errores:

- **Recuperación graceful**: Continuar operando a pesar de fallos parciales
- **Estrategias de retry**: Reintentar con modificaciones inteligentes
- **Degradación controlada**: Ofrecer funcionalidad reducida cuando lo ideal no es posible
- **Aprendizaje de errores**: Evitar repetir los mismos errores

Los sistemas de producción requieren robustez ante fallos. AutoGPT, LangChain y frameworks similares implementan patrones sofisticados de manejo de errores.

---

## Taxonomía de errores en agentes

```
┌─────────────────────────────────────────────────────────────────┐
│ ERRORES DE INFRAESTRUCTURA                                      │
│ ──────────────────────────                                      │
│ • Rate limiting de APIs                                         │
│ • Timeouts de red                                               │
│ • Errores de autenticación                                      │
│ • Servicios no disponibles                                      │
├─────────────────────────────────────────────────────────────────┤
│ ERRORES DE MODELO                                               │
│ ────────────────                                                │
│ • Respuestas malformadas (JSON inválido, formato incorrecto)    │
│ • Alucinaciones (información falsa)                             │
│ • Negativa a responder (safety filters)                         │
│ • Respuestas truncadas (límite de tokens)                       │
├─────────────────────────────────────────────────────────────────┤
│ ERRORES DE HERRAMIENTAS                                         │
│ ───────────────────────                                         │
│ • Herramienta no encontrada                                     │
│ • Parámetros inválidos                                          │
│ • Ejecución fallida                                             │
│ • Resultados inesperados                                        │
├─────────────────────────────────────────────────────────────────┤
│ ERRORES DE RAZONAMIENTO                                         │
│ ───────────────────────                                         │
│ • Bucles infinitos de pensamiento                               │
│ • Planes imposibles de ejecutar                                 │
│ • Interpretación incorrecta de instrucciones                    │
│ • Pérdida de contexto                                           │
└─────────────────────────────────────────────────────────────────┘
```

---

## Implementación práctica

### Framework de manejo de errores

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Callable, Any, Type
from enum import Enum
import time
import json
import traceback
from functools import wraps


class ErrorSeverity(Enum):
    LOW = "low"          # Puede ignorarse o logging
    MEDIUM = "medium"    # Requiere retry o fallback
    HIGH = "high"        # Requiere intervención o abort
    CRITICAL = "critical"  # Sistema debe detenerse


class ErrorCategory(Enum):
    INFRASTRUCTURE = "infrastructure"
    MODEL = "model"
    TOOL = "tool"
    REASONING = "reasoning"
    UNKNOWN = "unknown"


@dataclass
class AgentError:
    """Representa un error en el agente."""
    category: ErrorCategory
    severity: ErrorSeverity
    message: str
    original_exception: Optional[Exception] = None
    context: Dict = field(default_factory=dict)
    timestamp: float = field(default_factory=time.time)
    recoverable: bool = True
    retry_count: int = 0

    def to_dict(self) -> Dict:
        return {
            "category": self.category.value,
            "severity": self.severity.value,
            "message": self.message,
            "context": self.context,
            "timestamp": self.timestamp,
            "recoverable": self.recoverable,
            "retry_count": self.retry_count
        }


@dataclass
class RecoveryStrategy:
    """Define una estrategia de recuperación."""
    name: str
    applicable_categories: List[ErrorCategory]
    max_retries: int
    backoff_factor: float  # Multiplicador para exponential backoff
    fallback_action: Optional[Callable] = None


class ErrorHandler:
    """Manejador centralizado de errores para agentes."""

    def __init__(
        self,
        max_retries: int = 3,
        base_delay: float = 1.0,
        max_delay: float = 60.0
    ):
        self.max_retries = max_retries
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.error_history: List[AgentError] = []
        self.recovery_strategies: Dict[ErrorCategory, RecoveryStrategy] = {}
        self._setup_default_strategies()

    def _setup_default_strategies(self):
        """Configura estrategias de recuperación por defecto."""
        self.recovery_strategies = {
            ErrorCategory.INFRASTRUCTURE: RecoveryStrategy(
                name="retry_with_backoff",
                applicable_categories=[ErrorCategory.INFRASTRUCTURE],
                max_retries=5,
                backoff_factor=2.0
            ),
            ErrorCategory.MODEL: RecoveryStrategy(
                name="retry_with_modification",
                applicable_categories=[ErrorCategory.MODEL],
                max_retries=3,
                backoff_factor=1.5
            ),
            ErrorCategory.TOOL: RecoveryStrategy(
                name="try_alternative",
                applicable_categories=[ErrorCategory.TOOL],
                max_retries=2,
                backoff_factor=1.0
            ),
            ErrorCategory.REASONING: RecoveryStrategy(
                name="reset_and_retry",
                applicable_categories=[ErrorCategory.REASONING],
                max_retries=2,
                backoff_factor=1.0
            )
        }

    def classify_error(self, exception: Exception) -> AgentError:
        """Clasifica una excepción en una categoría de error."""
        error_type = type(exception).__name__
        message = str(exception)

        # Clasificación por tipo de excepción
        if any(keyword in error_type.lower() for keyword in
               ['timeout', 'connection', 'network', 'http']):
            return AgentError(
                category=ErrorCategory.INFRASTRUCTURE,
                severity=ErrorSeverity.MEDIUM,
                message=message,
                original_exception=exception,
                recoverable=True
            )

        if any(keyword in message.lower() for keyword in
               ['rate limit', '429', 'quota']):
            return AgentError(
                category=ErrorCategory.INFRASTRUCTURE,
                severity=ErrorSeverity.MEDIUM,
                message=message,
                original_exception=exception,
                context={"type": "rate_limit"},
                recoverable=True
            )

        if any(keyword in message.lower() for keyword in
               ['json', 'parse', 'decode', 'format']):
            return AgentError(
                category=ErrorCategory.MODEL,
                severity=ErrorSeverity.LOW,
                message=message,
                original_exception=exception,
                recoverable=True
            )

        if 'tool' in message.lower() or 'function' in message.lower():
            return AgentError(
                category=ErrorCategory.TOOL,
                severity=ErrorSeverity.MEDIUM,
                message=message,
                original_exception=exception,
                recoverable=True
            )

        # Default
        return AgentError(
            category=ErrorCategory.UNKNOWN,
            severity=ErrorSeverity.HIGH,
            message=message,
            original_exception=exception,
            recoverable=False
        )

    def calculate_delay(self, retry_count: int, strategy: RecoveryStrategy) -> float:
        """Calcula el delay para el próximo retry."""
        delay = self.base_delay * (strategy.backoff_factor ** retry_count)
        return min(delay, self.max_delay)

    def should_retry(self, error: AgentError) -> bool:
        """Determina si se debe reintentar."""
        if not error.recoverable:
            return False

        strategy = self.recovery_strategies.get(error.category)
        if not strategy:
            return error.retry_count < self.max_retries

        return error.retry_count < strategy.max_retries

    def log_error(self, error: AgentError):
        """Registra un error en el historial."""
        self.error_history.append(error)

    def get_error_summary(self) -> Dict:
        """Obtiene resumen de errores."""
        by_category = {}
        by_severity = {}

        for error in self.error_history:
            cat = error.category.value
            sev = error.severity.value
            by_category[cat] = by_category.get(cat, 0) + 1
            by_severity[sev] = by_severity.get(sev, 0) + 1

        return {
            "total_errors": len(self.error_history),
            "by_category": by_category,
            "by_severity": by_severity,
            "recovery_rate": sum(1 for e in self.error_history if e.retry_count > 0) / len(self.error_history) if self.error_history else 0
        }


def with_error_handling(
    handler: ErrorHandler,
    fallback_value: Any = None
):
    """Decorador para agregar manejo de errores a funciones."""
    def decorator(func: Callable):
        @wraps(func)
        def wrapper(*args, **kwargs):
            retry_count = 0

            while True:
                try:
                    return func(*args, **kwargs)

                except Exception as e:
                    error = handler.classify_error(e)
                    error.retry_count = retry_count
                    error.context["function"] = func.__name__
                    error.context["args"] = str(args)[:100]

                    handler.log_error(error)

                    if not handler.should_retry(error):
                        if fallback_value is not None:
                            return fallback_value
                        raise

                    strategy = handler.recovery_strategies.get(
                        error.category,
                        RecoveryStrategy("default", [], 3, 2.0)
                    )

                    delay = handler.calculate_delay(retry_count, strategy)
                    print(f"Error: {error.message}. Retrying in {delay:.1f}s...")
                    time.sleep(delay)
                    retry_count += 1

        return wrapper
    return decorator
```

### Uso del framework

```python
# Configurar handler
error_handler = ErrorHandler(
    max_retries=3,
    base_delay=1.0,
    max_delay=30.0
)

# Configurar modelo
genai.configure(api_key="TU_API_KEY")
model = genai.GenerativeModel("gemini-1.5-flash")


@with_error_handling(error_handler, fallback_value={"error": "Unable to process"})
def call_model(prompt: str) -> Dict:
    """Llama al modelo con manejo de errores."""
    response = model.generate_content(prompt)

    # Intentar parsear como JSON
    text = response.text
    json_start = text.find('{')
    json_end = text.rfind('}') + 1

    if json_start == -1:
        raise ValueError("No JSON found in response")

    return json.loads(text[json_start:json_end])


# Uso
result = call_model("Responde en JSON: {\"mensaje\": \"hola\"}")
print(result)
print(f"\nResumen de errores: {error_handler.get_error_summary()}")
```

---

## Patrones avanzados de recuperación

### 1. Retry con modificación de prompt

```python
class AdaptiveRetry:
    """
    Sistema de retry que modifica el prompt basándose
    en el tipo de error.
    """

    def __init__(self):
        self.model = genai.GenerativeModel("gemini-1.5-flash")
        self.modification_strategies = {
            "json_parse": self._add_json_emphasis,
            "truncated": self._request_shorter,
            "refused": self._rephrase_safely,
            "unclear": self._add_examples
        }

    def _add_json_emphasis(self, prompt: str) -> str:
        """Enfatiza el requisito de JSON válido."""
        return f"""
{prompt}

IMPORTANTE: Tu respuesta DEBE ser JSON válido.
- Comienza con {{ y termina con }}
- Usa comillas dobles para strings
- No incluyas texto fuera del JSON
- Verifica que el JSON sea parseable

JSON:
"""

    def _request_shorter(self, prompt: str) -> str:
        """Pide respuesta más corta."""
        return f"""
{prompt}

RESTRICCIÓN: Responde de forma CONCISA.
- Máximo 500 palabras
- Solo información esencial
- Sin introducciones ni despedidas
"""

    def _rephrase_safely(self, prompt: str) -> str:
        """Reformula para evitar filtros de seguridad."""
        return f"""
Contexto educativo/profesional.

{prompt}

Proporciona información objetiva y factual.
"""

    def _add_examples(self, prompt: str) -> str:
        """Agrega ejemplos para clarificar."""
        return f"""
{prompt}

Ejemplo de formato esperado:
Input: "ejemplo de entrada"
Output: "ejemplo de salida correspondiente"

Ahora procesa la solicitud original.
"""

    def _detect_error_type(self, error: Exception, response: Optional[str] = None) -> str:
        """Detecta el tipo de error para elegir estrategia."""
        error_msg = str(error).lower()

        if 'json' in error_msg or 'parse' in error_msg:
            return "json_parse"
        if 'length' in error_msg or 'truncat' in error_msg:
            return "truncated"
        if 'safety' in error_msg or 'blocked' in error_msg:
            return "refused"

        return "unclear"

    def execute_with_adaptive_retry(
        self,
        prompt: str,
        max_retries: int = 3,
        parser: Optional[Callable] = None
    ) -> Dict:
        """
        Ejecuta con retry adaptativo.

        Args:
            prompt: Prompt original
            max_retries: Máximo de reintentos
            parser: Función opcional para parsear respuesta

        Returns:
            Resultado o información de error
        """
        current_prompt = prompt
        errors = []

        for attempt in range(max_retries + 1):
            try:
                response = self.model.generate_content(current_prompt)
                text = response.text

                if parser:
                    result = parser(text)
                else:
                    result = text

                return {
                    "success": True,
                    "result": result,
                    "attempts": attempt + 1,
                    "final_prompt": current_prompt if attempt > 0 else None
                }

            except Exception as e:
                errors.append({
                    "attempt": attempt + 1,
                    "error": str(e),
                    "prompt_length": len(current_prompt)
                })

                if attempt < max_retries:
                    error_type = self._detect_error_type(e)
                    modifier = self.modification_strategies.get(
                        error_type,
                        self._add_examples
                    )
                    current_prompt = modifier(prompt)
                    print(f"Attempt {attempt + 1} failed ({error_type}). Modifying prompt...")

        return {
            "success": False,
            "errors": errors,
            "attempts": max_retries + 1
        }


# Uso
adaptive_retry = AdaptiveRetry()

result = adaptive_retry.execute_with_adaptive_retry(
    prompt="Lista 3 lenguajes de programación populares",
    parser=lambda x: json.loads(x) if '{' in x else {"raw": x}
)

print(f"Éxito: {result['success']}")
print(f"Intentos: {result['attempts']}")
if result['success']:
    print(f"Resultado: {result['result']}")
```

### 2. Fallback con degradación graceful

```python
class GracefulDegradation:
    """
    Sistema que degrada funcionalidad gracefully
    cuando los recursos principales fallan.
    """

    def __init__(self):
        self.primary_model = genai.GenerativeModel("gemini-1.5-pro")
        self.fallback_model = genai.GenerativeModel("gemini-1.5-flash")
        self.cache: Dict[str, str] = {}

    def _hash_prompt(self, prompt: str) -> str:
        """Genera hash simple del prompt."""
        import hashlib
        return hashlib.md5(prompt.encode()).hexdigest()[:16]

    def execute_with_fallback(
        self,
        prompt: str,
        require_full_capability: bool = False
    ) -> Dict:
        """
        Ejecuta con múltiples niveles de fallback.

        Niveles:
        1. Modelo primario (mejor calidad)
        2. Modelo fallback (más rápido/barato)
        3. Caché (si existe respuesta similar)
        4. Respuesta predeterminada
        """
        prompt_hash = self._hash_prompt(prompt)

        # Nivel 1: Modelo primario
        try:
            response = self.primary_model.generate_content(prompt)
            result = response.text

            # Guardar en caché
            self.cache[prompt_hash] = result

            return {
                "result": result,
                "source": "primary_model",
                "quality": "full"
            }

        except Exception as e1:
            print(f"Primary model failed: {e1}")

            if require_full_capability:
                raise

            # Nivel 2: Modelo fallback
            try:
                response = self.fallback_model.generate_content(prompt)
                result = response.text

                return {
                    "result": result,
                    "source": "fallback_model",
                    "quality": "degraded",
                    "note": "Using faster but potentially less capable model"
                }

            except Exception as e2:
                print(f"Fallback model failed: {e2}")

                # Nivel 3: Caché
                if prompt_hash in self.cache:
                    return {
                        "result": self.cache[prompt_hash],
                        "source": "cache",
                        "quality": "cached",
                        "note": "Using cached response (may be outdated)"
                    }

                # Nivel 4: Respuesta predeterminada
                return {
                    "result": None,
                    "source": "default",
                    "quality": "unavailable",
                    "error": f"All sources failed: {e1}, {e2}",
                    "suggestion": "Please try again later or rephrase your request"
                }


# Uso
degradation = GracefulDegradation()

# Poblar caché con una llamada exitosa
degradation.cache["abc123"] = "Respuesta cacheada de ejemplo"

result = degradation.execute_with_fallback(
    "¿Cuál es la capital de Francia?"
)

print(f"Fuente: {result['source']}")
print(f"Calidad: {result['quality']}")
print(f"Resultado: {result['result']}")
```

### 3. Circuit breaker para APIs

```python
class CircuitBreaker:
    """
    Implementación del patrón Circuit Breaker para
    proteger contra cascadas de fallos.
    """

    class State(Enum):
        CLOSED = "closed"      # Operación normal
        OPEN = "open"          # Bloqueando llamadas
        HALF_OPEN = "half_open"  # Probando recuperación

    def __init__(
        self,
        failure_threshold: int = 5,
        recovery_timeout: float = 30.0,
        half_open_max_calls: int = 3
    ):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.half_open_max_calls = half_open_max_calls

        self.state = self.State.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time: Optional[float] = None
        self.half_open_calls = 0

    def _should_allow_call(self) -> bool:
        """Determina si se permite una llamada."""
        if self.state == self.State.CLOSED:
            return True

        if self.state == self.State.OPEN:
            # Verificar si podemos pasar a half-open
            if self.last_failure_time and \
               time.time() - self.last_failure_time >= self.recovery_timeout:
                self.state = self.State.HALF_OPEN
                self.half_open_calls = 0
                return True
            return False

        if self.state == self.State.HALF_OPEN:
            return self.half_open_calls < self.half_open_max_calls

        return False

    def _record_success(self):
        """Registra una llamada exitosa."""
        if self.state == self.State.HALF_OPEN:
            self.success_count += 1
            if self.success_count >= self.half_open_max_calls:
                # Recuperación exitosa
                self.state = self.State.CLOSED
                self.failure_count = 0
                self.success_count = 0
        else:
            self.failure_count = max(0, self.failure_count - 1)

    def _record_failure(self):
        """Registra una llamada fallida."""
        self.failure_count += 1
        self.last_failure_time = time.time()

        if self.state == self.State.HALF_OPEN:
            # Volver a abrir
            self.state = self.State.OPEN
            self.success_count = 0

        elif self.state == self.State.CLOSED:
            if self.failure_count >= self.failure_threshold:
                self.state = self.State.OPEN

    def call(self, func: Callable, *args, **kwargs) -> Any:
        """
        Ejecuta función a través del circuit breaker.
        """
        if not self._should_allow_call():
            raise Exception(
                f"Circuit breaker is {self.state.value}. "
                f"Wait {self.recovery_timeout}s for recovery."
            )

        if self.state == self.State.HALF_OPEN:
            self.half_open_calls += 1

        try:
            result = func(*args, **kwargs)
            self._record_success()
            return result

        except Exception as e:
            self._record_failure()
            raise

    def get_status(self) -> Dict:
        """Obtiene estado del circuit breaker."""
        return {
            "state": self.state.value,
            "failure_count": self.failure_count,
            "success_count": self.success_count,
            "time_until_retry": max(
                0,
                self.recovery_timeout - (time.time() - (self.last_failure_time or 0))
            ) if self.state == self.State.OPEN else 0
        }


# Uso
circuit_breaker = CircuitBreaker(
    failure_threshold=3,
    recovery_timeout=10.0
)

model = genai.GenerativeModel("gemini-1.5-flash")


def call_api(prompt: str) -> str:
    response = model.generate_content(prompt)
    return response.text


# Wrapper con circuit breaker
def safe_call(prompt: str) -> Dict:
    try:
        result = circuit_breaker.call(call_api, prompt)
        return {"success": True, "result": result}
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "circuit_status": circuit_breaker.get_status()
        }


# Ejemplo de uso
for i in range(10):
    result = safe_call("Hola")
    print(f"Call {i+1}: {result.get('success', False)}, "
          f"Circuit: {circuit_breaker.get_status()['state']}")
```

---

## Errores frecuentes

### Error 1: Retry infinito

```python
# ❌ Sin límite de reintentos
def bad_retry(func):
    while True:
        try:
            return func()
        except:
            pass  # Retry forever

# ✓ Con límite y backoff
def good_retry(func, max_attempts=3, base_delay=1):
    for attempt in range(max_attempts):
        try:
            return func()
        except Exception as e:
            if attempt == max_attempts - 1:
                raise
            delay = base_delay * (2 ** attempt)
            time.sleep(delay)
```

### Error 2: Ignorar el contexto del error

```python
# ❌ Tratando todos los errores igual
def bad_error_handling():
    try:
        result = call_api()
    except Exception:
        return default_value  # Ignora el tipo de error

# ✓ Manejo específico por tipo de error
def good_error_handling():
    try:
        result = call_api()
    except RateLimitError:
        time.sleep(60)  # Esperar antes de retry
        return call_api()
    except AuthenticationError:
        refresh_credentials()
        return call_api()
    except ParseError:
        return call_api_with_format_hint()
    except Exception as e:
        log_unexpected_error(e)
        raise
```

### Error 3: No limpiar estado después de error

```python
# ❌ Estado corrupto después de error
class BadAgent:
    def __init__(self):
        self.state = {}

    def execute(self, task):
        self.state["current_task"] = task
        self.state["in_progress"] = True
        result = risky_operation()  # Si falla, state queda corrupto
        self.state["in_progress"] = False
        return result

# ✓ Cleanup garantizado
class GoodAgent:
    def __init__(self):
        self.state = {}

    def execute(self, task):
        self.state["current_task"] = task
        self.state["in_progress"] = True
        try:
            return risky_operation()
        finally:
            self.state["in_progress"] = False
            self.state.pop("current_task", None)
```

---

## Aplicación: Agente resiliente completo

```python
class ResilientAgent:
    """
    Agente con manejo completo de errores y recuperación.
    """

    def __init__(self):
        self.model = genai.GenerativeModel("gemini-1.5-flash")
        self.error_handler = ErrorHandler()
        self.circuit_breaker = CircuitBreaker(failure_threshold=5)
        self.adaptive_retry = AdaptiveRetry()
        self.degradation = GracefulDegradation()

        self.execution_log: List[Dict] = []

    def execute_task(
        self,
        task: str,
        require_high_quality: bool = False,
        timeout: float = 30.0
    ) -> Dict:
        """
        Ejecuta una tarea con todas las protecciones.
        """
        start_time = time.time()
        execution_id = f"exec_{int(start_time)}"

        log_entry = {
            "id": execution_id,
            "task": task,
            "start_time": start_time,
            "attempts": [],
            "status": "pending"
        }

        try:
            # Verificar circuit breaker
            if not self.circuit_breaker._should_allow_call():
                log_entry["status"] = "circuit_open"
                log_entry["error"] = "Circuit breaker is open"
                return self._create_response(log_entry, None, "blocked")

            # Intentar con retry adaptativo
            result = self.adaptive_retry.execute_with_adaptive_retry(
                prompt=self._create_task_prompt(task),
                max_retries=3
            )

            if result["success"]:
                self.circuit_breaker._record_success()
                log_entry["status"] = "success"
                log_entry["attempts"].append({"type": "primary", "success": True})
                return self._create_response(log_entry, result["result"], "primary")

            # Fallback con degradación
            if not require_high_quality:
                degraded_result = self.degradation.execute_with_fallback(
                    self._create_task_prompt(task)
                )

                log_entry["status"] = "degraded"
                log_entry["attempts"].append({
                    "type": "degraded",
                    "source": degraded_result["source"]
                })

                return self._create_response(
                    log_entry,
                    degraded_result["result"],
                    degraded_result["source"]
                )

            # Si se requiere alta calidad y falló, reportar error
            self.circuit_breaker._record_failure()
            log_entry["status"] = "failed"
            return self._create_response(log_entry, None, "failed")

        except Exception as e:
            self.circuit_breaker._record_failure()
            error = self.error_handler.classify_error(e)
            self.error_handler.log_error(error)

            log_entry["status"] = "error"
            log_entry["error"] = error.to_dict()

            return self._create_response(log_entry, None, "error", str(e))

        finally:
            log_entry["duration"] = time.time() - start_time
            self.execution_log.append(log_entry)

    def _create_task_prompt(self, task: str) -> str:
        """Crea prompt para la tarea."""
        return f"""
Ejecuta la siguiente tarea:
{task}

Proporciona una respuesta estructurada y completa.
"""

    def _create_response(
        self,
        log_entry: Dict,
        result: Optional[str],
        source: str,
        error: Optional[str] = None
    ) -> Dict:
        """Crea respuesta estandarizada."""
        return {
            "execution_id": log_entry["id"],
            "success": log_entry["status"] in ["success", "degraded"],
            "result": result,
            "source": source,
            "status": log_entry["status"],
            "error": error,
            "duration": log_entry.get("duration", 0),
            "circuit_status": self.circuit_breaker.get_status()
        }

    def get_health_status(self) -> Dict:
        """Obtiene estado de salud del agente."""
        recent_executions = self.execution_log[-100:]
        success_count = sum(
            1 for e in recent_executions
            if e["status"] in ["success", "degraded"]
        )

        return {
            "circuit_breaker": self.circuit_breaker.get_status(),
            "error_summary": self.error_handler.get_error_summary(),
            "recent_success_rate": success_count / len(recent_executions) if recent_executions else 1.0,
            "total_executions": len(self.execution_log)
        }


# Uso
agent = ResilientAgent()

# Ejecutar varias tareas
tasks = [
    "Calcula 2 + 2",
    "Explica la fotosíntesis",
    "Lista 5 países de Europa"
]

for task in tasks:
    result = agent.execute_task(task)
    print(f"\nTarea: {task[:30]}...")
    print(f"Éxito: {result['success']}")
    print(f"Fuente: {result['source']}")
    print(f"Duración: {result['duration']:.2f}s")

# Ver estado de salud
print("\n" + "="*50)
print("ESTADO DE SALUD DEL AGENTE:")
print(json.dumps(agent.get_health_status(), indent=2))
```

---

## Resumen del concepto

**En una frase**: El manejo de errores robusto permite que los agentes continúen operando efectivamente a pesar de fallos, mediante retry inteligente, fallbacks y degradación graceful.

**Patrones clave**:
1. **Retry con backoff**: Reintentos con delays exponenciales
2. **Retry adaptativo**: Modificar prompts según el error
3. **Degradación graceful**: Funcionalidad reducida vs fallo total
4. **Circuit breaker**: Proteger contra cascadas de fallos
5. **Logging y métricas**: Visibilidad para debugging

**Principios de resiliencia**:
- Fallar rápido, recuperarse rápido
- Siempre tener un plan B
- Limpiar estado después de errores
- Monitorear y aprender de los fallos

**Siguiente paso**: Módulo 3 - Function Calling y Herramientas.
