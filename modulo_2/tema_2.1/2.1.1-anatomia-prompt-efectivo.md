# Anatomía de un Prompt Efectivo

**Tiempo estimado**: 40 minutos
**Nivel**: Intermedio
**Prerrequisitos**: System Instructions (1.3.2)

## ¿Por qué importa este concepto?

Un prompt bien estructurado puede mejorar dramáticamente la calidad de las respuestas. La diferencia entre un prompt mediocre y uno excelente puede ser:
- Respuestas correctas vs incorrectas
- Formato útil vs caótico
- Completitud vs respuestas parciales
- Eficiencia en tokens vs desperdicio

---

## Los 5 componentes de un prompt efectivo

```
┌─────────────────────────────────────────┐
│ 1. CONTEXTO                             │
│    - Información de fondo               │
│    - Quién eres / a quién te diriges    │
├─────────────────────────────────────────┤
│ 2. TAREA                                │
│    - Qué necesitas que haga             │
│    - Objetivo claro y específico        │
├─────────────────────────────────────────┤
│ 3. INSTRUCCIONES                        │
│    - Cómo debe hacerlo                  │
│    - Pasos o restricciones              │
├─────────────────────────────────────────┤
│ 4. FORMATO                              │
│    - Estructura de la respuesta         │
│    - JSON, lista, párrafo, etc.         │
├─────────────────────────────────────────┤
│ 5. EJEMPLOS (opcional)                  │
│    - Demostración de lo esperado        │
│    - Input → Output                     │
└─────────────────────────────────────────┘
```

---

## Implementación práctica

### Prompt básico vs estructurado

```python
# ❌ Prompt vago
bad_prompt = "Escribe algo sobre Python"

# ✓ Prompt estructurado
good_prompt = """
# CONTEXTO
Soy un desarrollador junior aprendiendo Python para análisis de datos.

# TAREA
Explica la diferencia entre listas y tuplas en Python.

# INSTRUCCIONES
- Empieza con una analogía simple
- Proporciona ejemplos de código para cada uno
- Indica cuándo usar cada estructura

# FORMATO
- Usa bullet points para las diferencias
- Código en bloques con comentarios
- Máximo 300 palabras
"""
```

### Builder de prompts

```python
from dataclasses import dataclass, field
from typing import Optional, List


@dataclass
class PromptBuilder:
    """Constructor de prompts estructurados."""

    context: Optional[str] = None
    task: Optional[str] = None
    instructions: List[str] = field(default_factory=list)
    format_spec: Optional[str] = None
    examples: List[dict] = field(default_factory=list)
    constraints: List[str] = field(default_factory=list)

    def with_context(self, context: str) -> "PromptBuilder":
        """Agrega contexto."""
        self.context = context
        return self

    def with_task(self, task: str) -> "PromptBuilder":
        """Define la tarea principal."""
        self.task = task
        return self

    def add_instruction(self, instruction: str) -> "PromptBuilder":
        """Agrega una instrucción."""
        self.instructions.append(instruction)
        return self

    def with_format(self, format_spec: str) -> "PromptBuilder":
        """Especifica el formato de salida."""
        self.format_spec = format_spec
        return self

    def add_example(self, input_text: str, output_text: str) -> "PromptBuilder":
        """Agrega un ejemplo de entrada/salida."""
        self.examples.append({"input": input_text, "output": output_text})
        return self

    def add_constraint(self, constraint: str) -> "PromptBuilder":
        """Agrega una restricción."""
        self.constraints.append(constraint)
        return self

    def build(self) -> str:
        """Construye el prompt final."""
        sections = []

        if self.context:
            sections.append(f"# CONTEXTO\n{self.context}")

        if self.task:
            sections.append(f"# TAREA\n{self.task}")

        if self.instructions:
            instructions_text = "\n".join(f"- {i}" for i in self.instructions)
            sections.append(f"# INSTRUCCIONES\n{instructions_text}")

        if self.constraints:
            constraints_text = "\n".join(f"- {c}" for c in self.constraints)
            sections.append(f"# RESTRICCIONES\n{constraints_text}")

        if self.format_spec:
            sections.append(f"# FORMATO DE RESPUESTA\n{self.format_spec}")

        if self.examples:
            examples_text = ""
            for i, ex in enumerate(self.examples, 1):
                examples_text += f"\nEjemplo {i}:\n"
                examples_text += f"Input: {ex['input']}\n"
                examples_text += f"Output: {ex['output']}\n"
            sections.append(f"# EJEMPLOS{examples_text}")

        return "\n\n".join(sections)


# Uso
prompt = (
    PromptBuilder()
    .with_context("Sistema de análisis de sentimiento para reviews de productos")
    .with_task("Clasifica el sentimiento del siguiente texto de review")
    .add_instruction("Analiza el tono general del texto")
    .add_instruction("Identifica palabras clave positivas y negativas")
    .add_instruction("Proporciona una clasificación final")
    .with_format('''JSON con estructura:
{
    "sentiment": "positive|negative|neutral",
    "confidence": 0.0-1.0,
    "key_phrases": ["frase1", "frase2"],
    "summary": "resumen breve"
}''')
    .add_example(
        "Este producto es increíble, me encanta!",
        '{"sentiment": "positive", "confidence": 0.95, "key_phrases": ["increíble", "me encanta"], "summary": "Review muy positiva"}'
    )
    .add_constraint("Responde SOLO con el JSON, sin texto adicional")
    .build()
)

print(prompt)
```

---

## Técnicas de mejora de prompts

### 1. Delimitadores claros

```python
def create_delimited_prompt(
    instruction: str,
    content: str,
    delimiter: str = "###"
) -> str:
    """
    Usa delimitadores para separar instrucciones del contenido.
    """
    return f"""
{instruction}

{delimiter}
{content}
{delimiter}
"""


# Uso
prompt = create_delimited_prompt(
    instruction="Resume el siguiente texto en 2 oraciones:",
    content="Lorem ipsum dolor sit amet, consectetur adipiscing elit...",
    delimiter="---"
)
```

### 2. Especificar el rol

```python
def create_role_prompt(role: str, task: str) -> str:
    """Crea prompt con rol específico."""
    return f"""
Actúa como {role}.

Tu tarea: {task}

Responde desde la perspectiva y con el conocimiento de {role}.
"""


# Diferentes perspectivas
prompts = {
    "developer": create_role_prompt(
        "un desarrollador senior de Python con 15 años de experiencia",
        "Revisa este código y sugiere mejoras"
    ),
    "teacher": create_role_prompt(
        "un profesor universitario de ciencias de la computación",
        "Explica este algoritmo a un estudiante de primer año"
    ),
    "critic": create_role_prompt(
        "un revisor de código estricto enfocado en seguridad",
        "Encuentra vulnerabilidades en este código"
    )
}
```

### 3. Paso a paso explícito

```python
STEP_BY_STEP_TEMPLATE = """
# TAREA
{task}

# PROCESO
Sigue estos pasos en orden:

1. **Análisis inicial**: Lee y comprende completamente el input
2. **Identificación**: Identifica los elementos clave
3. **Procesamiento**: Aplica la lógica necesaria
4. **Verificación**: Verifica que tu resultado es correcto
5. **Respuesta**: Proporciona la respuesta final

Muestra tu razonamiento para cada paso.
"""

def create_step_by_step_prompt(task: str) -> str:
    return STEP_BY_STEP_TEMPLATE.format(task=task)
```

### 4. Restricciones explícitas

```python
CONSTRAINED_TEMPLATE = """
{task}

DEBES:
{must_do}

NO DEBES:
{must_not}

FORMATO:
{format_spec}
"""

def create_constrained_prompt(
    task: str,
    must_do: list,
    must_not: list,
    format_spec: str
) -> str:
    return CONSTRAINED_TEMPLATE.format(
        task=task,
        must_do="\n".join(f"- {m}" for m in must_do),
        must_not="\n".join(f"- {m}" for m in must_not),
        format_spec=format_spec
    )


# Uso
prompt = create_constrained_prompt(
    task="Genera un resumen ejecutivo de este documento",
    must_do=[
        "Incluir los 3 puntos principales",
        "Mantener un tono profesional",
        "Ser conciso (máximo 150 palabras)"
    ],
    must_not=[
        "Incluir opiniones personales",
        "Usar jerga técnica sin explicar",
        "Exceder el límite de palabras"
    ],
    format_spec="Un párrafo seguido de 3 bullet points"
)
```

---

## Templates reutilizables

```python
class PromptTemplates:
    """Biblioteca de templates de prompts."""

    @staticmethod
    def summarize(text: str, max_words: int = 100) -> str:
        return f"""
Resume el siguiente texto en máximo {max_words} palabras.
Mantén los puntos principales y el tono original.

TEXTO:
{text}

RESUMEN:"""

    @staticmethod
    def translate(text: str, target_lang: str) -> str:
        return f"""
Traduce el siguiente texto a {target_lang}.
Mantén el significado y tono original.
Si hay términos técnicos, mantén el original entre paréntesis.

TEXTO:
{text}

TRADUCCIÓN:"""

    @staticmethod
    def extract_entities(text: str) -> str:
        return f"""
Extrae las entidades nombradas del siguiente texto.

Categorías a identificar:
- PERSONA: Nombres de personas
- ORGANIZACIÓN: Empresas, instituciones
- LUGAR: Ciudades, países, direcciones
- FECHA: Fechas y períodos de tiempo
- PRODUCTO: Productos o servicios mencionados

TEXTO:
{text}

Responde en JSON:
{{"entities": [{{"text": "...", "type": "...", "context": "..."}}]}}"""

    @staticmethod
    def code_review(code: str, language: str = "Python") -> str:
        return f"""
Revisa el siguiente código {language} y proporciona feedback.

Analiza:
1. Correctitud: ¿El código hace lo que debería?
2. Eficiencia: ¿Hay optimizaciones posibles?
3. Legibilidad: ¿Es fácil de entender?
4. Mejores prácticas: ¿Sigue convenciones del lenguaje?
5. Seguridad: ¿Hay vulnerabilidades?

CÓDIGO:
```{language.lower()}
{code}
```

Proporciona:
- Lista de problemas encontrados
- Sugerencias de mejora
- Versión mejorada del código si es necesario"""

    @staticmethod
    def generate_tests(code: str, framework: str = "pytest") -> str:
        return f"""
Genera tests unitarios para el siguiente código usando {framework}.

CÓDIGO A TESTEAR:
```python
{code}
```

Genera tests que cubran:
- Casos normales (happy path)
- Casos límite (edge cases)
- Casos de error esperados

Formato: Código Python ejecutable con {framework}."""


# Uso
templates = PromptTemplates()

# Resumir
summary_prompt = templates.summarize(
    "Lorem ipsum dolor sit amet...",
    max_words=50
)

# Revisar código
review_prompt = templates.code_review(
    "def factorial(n): return 1 if n <= 1 else n * factorial(n-1)",
    "Python"
)
```

---

## Casos de prueba

```python
# test_prompt_builder.py
import pytest


def test_prompt_builder_basic():
    """Test construcción básica de prompt."""
    prompt = (
        PromptBuilder()
        .with_task("Tarea de prueba")
        .build()
    )

    assert "TAREA" in prompt
    assert "Tarea de prueba" in prompt
    print("✓ Builder básico funciona")


def test_prompt_builder_complete():
    """Test prompt con todos los componentes."""
    prompt = (
        PromptBuilder()
        .with_context("Contexto de prueba")
        .with_task("Tarea de prueba")
        .add_instruction("Instrucción 1")
        .add_instruction("Instrucción 2")
        .with_format("JSON")
        .add_example("input1", "output1")
        .add_constraint("No hagas X")
        .build()
    )

    assert "CONTEXTO" in prompt
    assert "TAREA" in prompt
    assert "INSTRUCCIONES" in prompt
    assert "FORMATO" in prompt
    assert "EJEMPLOS" in prompt
    assert "RESTRICCIONES" in prompt
    print("✓ Builder completo funciona")


def test_templates():
    """Test templates predefinidos."""
    prompt = PromptTemplates.summarize("Texto de prueba", 50)
    assert "50 palabras" in prompt
    assert "Texto de prueba" in prompt

    prompt = PromptTemplates.translate("Hello", "español")
    assert "español" in prompt
    assert "Hello" in prompt

    print("✓ Templates funcionan")


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

---

## Resumen del concepto

**En una frase**: Un prompt efectivo tiene contexto claro, tarea específica, instrucciones detalladas, formato definido y opcionalmente ejemplos.

**Framework CTIFO**:
- **C**ontexto: ¿Cuál es la situación?
- **T**area: ¿Qué necesitas?
- **I**nstrucciones: ¿Cómo hacerlo?
- **F**ormato: ¿Cómo debe verse la respuesta?
- **O**utput esperado: Ejemplos

**Siguiente paso**: Tema 2.1.2 - Zero-Shot, One-Shot y Few-Shot Learning.
