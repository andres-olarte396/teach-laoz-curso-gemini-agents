# 5.1.1 Memoria de Trabajo (Short-term)

## Tiempo estimado: 75 minutos
## Nivel: Intermedio-Avanzado

## Prerrequisitos
- Arquitectura de Agentes (Módulo 4)
- Bucle Observe-Think-Act (4.1.2)
- Chat Sessions y Historial (1.3.1)

## ¿Por qué es importante?

La **memoria de trabajo** (working memory) es el componente que permite a un agente mantener el contexto durante una sesión de interacción. Sin ella, cada paso del agente sería completamente independiente, perdiendo:
- El hilo de la conversación
- Los resultados de acciones previas
- El estado del objetivo actual
- La información temporal necesaria para razonar

> "La memoria de trabajo es el 'scratchpad' mental del agente - donde mantiene activa la información relevante para la tarea actual."

## Arquitectura de Memoria de Trabajo

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    SISTEMA DE MEMORIA DE TRABAJO                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   ┌─────────────────────────────────────────────────────────────────┐  │
│   │                    VENTANA DE CONTEXTO                           │  │
│   │              (Limited by Model's Context Window)                 │  │
│   │                                                                   │  │
│   │   ┌─────────────────────────────────────────────────────────┐   │  │
│   │   │                  SYSTEM PROMPT                           │   │  │
│   │   │   • Rol del agente                                       │   │  │
│   │   │   • Instrucciones base                                   │   │  │
│   │   │   • Herramientas disponibles                             │   │  │
│   │   └─────────────────────────────────────────────────────────┘   │  │
│   │                                                                   │  │
│   │   ┌─────────────────────────────────────────────────────────┐   │  │
│   │   │              MEMORIA DE TRABAJO ACTIVA                   │   │  │
│   │   │                                                           │   │  │
│   │   │   ┌───────────────┐  ┌───────────────┐                   │   │  │
│   │   │   │   OBJETIVO    │  │   ESTADO      │                   │   │  │
│   │   │   │   ACTUAL      │  │   ACTUAL      │                   │   │  │
│   │   │   └───────────────┘  └───────────────┘                   │   │  │
│   │   │                                                           │   │  │
│   │   │   ┌───────────────┐  ┌───────────────┐                   │   │  │
│   │   │   │  RESULTADOS   │  │  VARIABLES    │                   │   │  │
│   │   │   │  INTERMEDIOS  │  │  TEMPORALES   │                   │   │  │
│   │   │   └───────────────┘  └───────────────┘                   │   │  │
│   │   │                                                           │   │  │
│   │   └─────────────────────────────────────────────────────────┘   │  │
│   │                                                                   │  │
│   │   ┌─────────────────────────────────────────────────────────┐   │  │
│   │   │              HISTORIAL DE CONVERSACIÓN                   │   │  │
│   │   │                                                           │   │  │
│   │   │   [User] → [Assistant] → [Tool] → [Assistant] → ...     │   │  │
│   │   │                                                           │   │  │
│   │   │   ← Mensajes más antiguos    Mensajes recientes →        │   │  │
│   │   │                                                           │   │  │
│   │   └─────────────────────────────────────────────────────────┘   │  │
│   │                                                                   │  │
│   └─────────────────────────────────────────────────────────────────┘  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## Componentes de la Memoria de Trabajo

```
┌────────────────────────────────────────────────────────────────────────┐
│                    COMPONENTES DE MEMORIA DE TRABAJO                   │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  1. SCRATCHPAD (Bloc de notas)                                         │
│  ┌──────────────────────────────────────────────────────────────────┐ │
│  │ • Notas temporales del agente                                    │ │
│  │ • Cálculos intermedios                                           │ │
│  │ • Hipótesis en evaluación                                        │ │
│  │ • Información extraída pendiente de uso                          │ │
│  └──────────────────────────────────────────────────────────────────┘ │
│                                                                        │
│  2. ESTADO DE TAREA                                                    │
│  ┌──────────────────────────────────────────────────────────────────┐ │
│  │ • Objetivo actual                                                │ │
│  │ • Subobjetivos pendientes                                        │ │
│  │ • Paso actual en el plan                                         │ │
│  │ • Progreso (completado/pendiente)                                │ │
│  └──────────────────────────────────────────────────────────────────┘ │
│                                                                        │
│  3. RESULTADOS RECIENTES                                               │
│  ┌──────────────────────────────────────────────────────────────────┐ │
│  │ • Outputs de herramientas                                        │ │
│  │ • Respuestas de APIs                                             │ │
│  │ • Datos recuperados                                              │ │
│  │ • Errores encontrados                                            │ │
│  └──────────────────────────────────────────────────────────────────┘ │
│                                                                        │
│  4. CONTEXTO DE USUARIO                                                │
│  ┌──────────────────────────────────────────────────────────────────┐ │
│  │ • Preferencias expresadas                                        │ │
│  │ • Correcciones realizadas                                        │ │
│  │ • Información personal compartida                                │ │
│  │ • Intención inferida                                             │ │
│  └──────────────────────────────────────────────────────────────────┘ │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

## Implementación de Memoria de Trabajo

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Any, Optional
from datetime import datetime
from collections import deque
import json
import os

@dataclass
class MemoryItem:
    """Elemento individual de memoria."""
    content: Any
    memory_type: str  # scratchpad, task_state, result, user_context
    timestamp: datetime = field(default_factory=datetime.now)
    relevance: float = 1.0  # 0.0 a 1.0
    ttl: Optional[int] = None  # Time-to-live en segundos
    metadata: dict = field(default_factory=dict)

    def is_expired(self) -> bool:
        """Verifica si el item ha expirado."""
        if self.ttl is None:
            return False
        age = (datetime.now() - self.timestamp).total_seconds()
        return age > self.ttl

    def decay_relevance(self, factor: float = 0.95):
        """Reduce la relevancia con el tiempo."""
        self.relevance *= factor


class WorkingMemory:
    """
    Sistema de memoria de trabajo para agentes.

    Mantiene información temporal relevante para la sesión actual,
    con gestión automática de capacidad y relevancia.
    """

    def __init__(self, max_items: int = 50, max_tokens: int = 8000):
        self.max_items = max_items
        self.max_tokens = max_tokens

        # Almacenamiento por tipo
        self.scratchpad: dict[str, MemoryItem] = {}
        self.task_state: dict[str, MemoryItem] = {}
        self.results: deque[MemoryItem] = deque(maxlen=20)
        self.user_context: dict[str, MemoryItem] = {}

        # Historial de conversación
        self.conversation_history: list[dict] = []

        # Metadatos
        self.session_start = datetime.now()
        self.total_items_added = 0

    # ═══════════════════════════════════════════════════════════════
    # SCRATCHPAD: Notas temporales
    # ═══════════════════════════════════════════════════════════════

    def note(self, key: str, content: Any, ttl: int = 300):
        """
        Agrega una nota al scratchpad.

        Args:
            key: Identificador de la nota
            content: Contenido de la nota
            ttl: Tiempo de vida en segundos (default: 5 minutos)
        """
        self.scratchpad[key] = MemoryItem(
            content=content,
            memory_type="scratchpad",
            ttl=ttl
        )
        self._cleanup_expired()

    def get_note(self, key: str) -> Optional[Any]:
        """Recupera una nota del scratchpad."""
        item = self.scratchpad.get(key)
        if item and not item.is_expired():
            return item.content
        return None

    def clear_note(self, key: str):
        """Elimina una nota del scratchpad."""
        self.scratchpad.pop(key, None)

    # ═══════════════════════════════════════════════════════════════
    # TASK STATE: Estado de la tarea actual
    # ═══════════════════════════════════════════════════════════════

    def set_goal(self, goal: str, subgoals: list[str] = None):
        """Establece el objetivo actual."""
        self.task_state["current_goal"] = MemoryItem(
            content={
                "goal": goal,
                "subgoals": subgoals or [],
                "completed_subgoals": [],
                "started_at": datetime.now().isoformat()
            },
            memory_type="task_state"
        )

    def get_goal(self) -> Optional[dict]:
        """Obtiene el objetivo actual."""
        item = self.task_state.get("current_goal")
        return item.content if item else None

    def complete_subgoal(self, subgoal: str):
        """Marca un subobjetivo como completado."""
        goal_item = self.task_state.get("current_goal")
        if goal_item:
            content = goal_item.content
            if subgoal in content.get("subgoals", []):
                content["completed_subgoals"].append(subgoal)

    def set_current_step(self, step: int, total: int, description: str):
        """Establece el paso actual del plan."""
        self.task_state["current_step"] = MemoryItem(
            content={
                "step": step,
                "total": total,
                "description": description,
                "progress": f"{step}/{total}"
            },
            memory_type="task_state"
        )

    def get_current_step(self) -> Optional[dict]:
        """Obtiene información del paso actual."""
        item = self.task_state.get("current_step")
        return item.content if item else None

    # ═══════════════════════════════════════════════════════════════
    # RESULTS: Resultados de acciones
    # ═══════════════════════════════════════════════════════════════

    def store_result(self, action: str, result: Any, success: bool = True):
        """
        Almacena el resultado de una acción.

        Args:
            action: Nombre de la acción ejecutada
            result: Resultado obtenido
            success: Si la acción fue exitosa
        """
        self.results.append(MemoryItem(
            content={
                "action": action,
                "result": result,
                "success": success
            },
            memory_type="result"
        ))

    def get_last_result(self) -> Optional[dict]:
        """Obtiene el último resultado."""
        if self.results:
            return self.results[-1].content
        return None

    def get_recent_results(self, n: int = 5) -> list[dict]:
        """Obtiene los N resultados más recientes."""
        recent = list(self.results)[-n:]
        return [item.content for item in recent]

    def get_successful_results(self) -> list[dict]:
        """Obtiene solo los resultados exitosos."""
        return [
            item.content for item in self.results
            if item.content.get("success", False)
        ]

    # ═══════════════════════════════════════════════════════════════
    # USER CONTEXT: Contexto del usuario
    # ═══════════════════════════════════════════════════════════════

    def set_user_preference(self, key: str, value: Any):
        """Guarda una preferencia del usuario."""
        self.user_context[key] = MemoryItem(
            content=value,
            memory_type="user_context"
        )

    def get_user_preference(self, key: str) -> Optional[Any]:
        """Obtiene una preferencia del usuario."""
        item = self.user_context.get(key)
        return item.content if item else None

    def update_user_context(self, context: dict):
        """Actualiza múltiples elementos del contexto del usuario."""
        for key, value in context.items():
            self.set_user_preference(key, value)

    # ═══════════════════════════════════════════════════════════════
    # CONVERSATION HISTORY: Historial de conversación
    # ═══════════════════════════════════════════════════════════════

    def add_message(self, role: str, content: str):
        """Agrega un mensaje al historial."""
        self.conversation_history.append({
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat()
        })
        self._manage_history_size()

    def get_history(self, max_messages: int = None) -> list[dict]:
        """Obtiene el historial de conversación."""
        if max_messages:
            return self.conversation_history[-max_messages:]
        return self.conversation_history

    def get_history_for_model(self) -> list[dict]:
        """Formatea el historial para enviar al modelo."""
        return [
            {"role": msg["role"], "parts": [msg["content"]]}
            for msg in self.conversation_history
        ]

    def _manage_history_size(self):
        """Gestiona el tamaño del historial."""
        # Estimar tokens (aproximación simple)
        total_chars = sum(len(msg["content"]) for msg in self.conversation_history)
        estimated_tokens = total_chars // 4

        while estimated_tokens > self.max_tokens and len(self.conversation_history) > 2:
            # Mantener siempre el primer y último mensaje
            # Eliminar el segundo mensaje más antiguo
            if len(self.conversation_history) > 2:
                self.conversation_history.pop(1)
            total_chars = sum(len(msg["content"]) for msg in self.conversation_history)
            estimated_tokens = total_chars // 4

    # ═══════════════════════════════════════════════════════════════
    # UTILIDADES
    # ═══════════════════════════════════════════════════════════════

    def _cleanup_expired(self):
        """Elimina items expirados."""
        # Limpiar scratchpad
        expired_keys = [
            k for k, v in self.scratchpad.items() if v.is_expired()
        ]
        for key in expired_keys:
            del self.scratchpad[key]

    def get_summary(self) -> str:
        """Genera un resumen del estado de la memoria."""
        summary = []

        # Objetivo actual
        goal = self.get_goal()
        if goal:
            completed = len(goal.get("completed_subgoals", []))
            total = len(goal.get("subgoals", []))
            summary.append(f"Objetivo: {goal['goal']} ({completed}/{total} subobjetivos)")

        # Paso actual
        step = self.get_current_step()
        if step:
            summary.append(f"Paso actual: {step['description']} ({step['progress']})")

        # Resultados recientes
        recent = self.get_recent_results(3)
        if recent:
            summary.append(f"Últimas acciones: {[r['action'] for r in recent]}")

        # Notas activas
        active_notes = [k for k, v in self.scratchpad.items() if not v.is_expired()]
        if active_notes:
            summary.append(f"Notas activas: {active_notes}")

        return "\n".join(summary) if summary else "Memoria vacía"

    def to_context_string(self) -> str:
        """Convierte la memoria a string para incluir en el prompt."""
        sections = []

        # Estado de la tarea
        goal = self.get_goal()
        if goal:
            sections.append(f"""## Estado de la Tarea
- Objetivo: {goal['goal']}
- Subobjetivos pendientes: {[s for s in goal.get('subgoals', []) if s not in goal.get('completed_subgoals', [])]}
- Completados: {goal.get('completed_subgoals', [])}""")

        step = self.get_current_step()
        if step:
            sections.append(f"- Paso actual ({step['progress']}): {step['description']}")

        # Resultados relevantes
        recent = self.get_recent_results(3)
        if recent:
            sections.append("\n## Resultados Recientes")
            for r in recent:
                status = "✓" if r.get("success") else "✗"
                sections.append(f"- [{status}] {r['action']}: {str(r['result'])[:100]}")

        # Notas activas
        active_notes = {k: v.content for k, v in self.scratchpad.items() if not v.is_expired()}
        if active_notes:
            sections.append("\n## Notas")
            for key, content in active_notes.items():
                sections.append(f"- {key}: {content}")

        # Preferencias del usuario
        if self.user_context:
            sections.append("\n## Contexto del Usuario")
            for key, item in self.user_context.items():
                sections.append(f"- {key}: {item.content}")

        return "\n".join(sections)

    def clear(self):
        """Limpia toda la memoria de trabajo."""
        self.scratchpad.clear()
        self.task_state.clear()
        self.results.clear()
        self.user_context.clear()
        self.conversation_history.clear()
```

## Agente con Memoria de Trabajo

```python
class AgentWithWorkingMemory:
    """
    Agente que utiliza memoria de trabajo para mantener contexto.
    """

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)
        self.memory = WorkingMemory()
        self.tools: dict[str, callable] = {}

    def register_tool(self, name: str, func: callable, description: str):
        """Registra una herramienta."""
        self.tools[name] = {"function": func, "description": description}

    def _build_prompt(self, user_input: str) -> str:
        """Construye el prompt incluyendo la memoria de trabajo."""
        tools_desc = "\n".join([
            f"- {name}: {info['description']}"
            for name, info in self.tools.items()
        ])

        memory_context = self.memory.to_context_string()

        return f"""Eres un agente inteligente con memoria de trabajo.

## Herramientas Disponibles
{tools_desc}

## Estado de Memoria
{memory_context}

## Historial Reciente
{self._format_recent_history()}

## Instrucciones
- Usa tu memoria de trabajo para mantener el contexto
- Actualiza notas cuando descubras información importante
- Marca subobjetivos como completados cuando corresponda
- Referencia resultados anteriores cuando sean relevantes

## Input del Usuario
{user_input}

Responde de manera útil y contextual."""

    def _format_recent_history(self) -> str:
        """Formatea el historial reciente."""
        history = self.memory.get_history(5)
        if not history:
            return "Sin historial previo"

        formatted = []
        for msg in history:
            role = "Usuario" if msg["role"] == "user" else "Asistente"
            formatted.append(f"{role}: {msg['content'][:200]}...")

        return "\n".join(formatted)

    def think(self, user_input: str) -> str:
        """
        Procesa el input del usuario con contexto de memoria.
        """
        # Agregar mensaje al historial
        self.memory.add_message("user", user_input)

        # Construir prompt con contexto
        prompt = self._build_prompt(user_input)

        # Obtener respuesta
        response = self.model.generate_content(prompt)
        assistant_response = response.text

        # Agregar respuesta al historial
        self.memory.add_message("assistant", assistant_response)

        # Extraer y actualizar información de la respuesta
        self._update_memory_from_response(assistant_response, user_input)

        return assistant_response

    def _update_memory_from_response(self, response: str, user_input: str):
        """Actualiza la memoria basándose en la respuesta."""
        # Detectar si hay información para recordar
        if any(phrase in user_input.lower() for phrase in ["mi nombre es", "prefiero", "me gusta"]):
            # Extraer preferencia (simplificado)
            self.memory.note("user_info_detected", user_input, ttl=3600)

        # Detectar si se completó algo
        if any(phrase in response.lower() for phrase in ["completado", "listo", "hecho"]):
            current_step = self.memory.get_current_step()
            if current_step:
                # Avanzar al siguiente paso
                next_step = current_step["step"] + 1
                if next_step <= current_step["total"]:
                    self.memory.set_current_step(
                        next_step,
                        current_step["total"],
                        f"Paso {next_step}"
                    )

    def execute_task(self, task: str, steps: list[str]) -> str:
        """
        Ejecuta una tarea con múltiples pasos.
        """
        # Establecer objetivo
        self.memory.set_goal(task, steps)

        results = []

        for i, step in enumerate(steps, 1):
            self.memory.set_current_step(i, len(steps), step)

            print(f"\n[Paso {i}/{len(steps)}] {step}")
            print(f"Memoria: {self.memory.get_summary()}")

            # Ejecutar paso
            response = self.think(f"Ejecuta el siguiente paso: {step}")
            print(f"Respuesta: {response[:200]}...")

            # Almacenar resultado
            self.memory.store_result(step, response, success=True)
            self.memory.complete_subgoal(step)

            results.append({
                "step": step,
                "result": response
            })

        return json.dumps(results, indent=2)


# Uso
agent = AgentWithWorkingMemory()

# Ejecutar tarea con múltiples pasos
result = agent.execute_task(
    task="Investigar sobre Python y crear un resumen",
    steps=[
        "Buscar qué es Python",
        "Identificar características principales",
        "Crear un resumen de 3 puntos"
    ]
)
```

## Patrón: Memoria con Priorización

```python
class PrioritizedWorkingMemory(WorkingMemory):
    """
    Memoria de trabajo con priorización automática.

    Los items más relevantes se mantienen, los menos relevantes
    se eliminan cuando se alcanza el límite.
    """

    def __init__(self, max_items: int = 50, max_tokens: int = 8000):
        super().__init__(max_items, max_tokens)
        self.access_count: dict[str, int] = {}

    def note(self, key: str, content: Any, priority: float = 0.5, ttl: int = 300):
        """Agrega nota con prioridad."""
        self.scratchpad[key] = MemoryItem(
            content=content,
            memory_type="scratchpad",
            relevance=priority,
            ttl=ttl
        )
        self.access_count[key] = 0
        self._enforce_limits()

    def get_note(self, key: str) -> Optional[Any]:
        """Recupera nota y aumenta su relevancia."""
        item = self.scratchpad.get(key)
        if item and not item.is_expired():
            # Aumentar relevancia por acceso
            item.relevance = min(1.0, item.relevance + 0.1)
            self.access_count[key] = self.access_count.get(key, 0) + 1
            return item.content
        return None

    def _enforce_limits(self):
        """Elimina items de menor prioridad si se excede el límite."""
        self._cleanup_expired()

        # Aplicar decay a todos los items
        for item in self.scratchpad.values():
            item.decay_relevance()

        # Si excede el límite, eliminar los de menor relevancia
        if len(self.scratchpad) > self.max_items:
            sorted_items = sorted(
                self.scratchpad.items(),
                key=lambda x: x[1].relevance
            )

            # Eliminar el 20% menos relevante
            to_remove = len(sorted_items) // 5
            for key, _ in sorted_items[:to_remove]:
                del self.scratchpad[key]
                self.access_count.pop(key, None)

    def get_most_relevant(self, n: int = 5) -> list[tuple[str, Any]]:
        """Obtiene los N items más relevantes."""
        sorted_items = sorted(
            [(k, v) for k, v in self.scratchpad.items() if not v.is_expired()],
            key=lambda x: x[1].relevance,
            reverse=True
        )
        return [(k, v.content) for k, v in sorted_items[:n]]
```

## Errores Comunes y Soluciones

### 1. Contexto Desbordado

```python
# ❌ MAL: Agregar todo al contexto
def build_prompt(self):
    return f"{self.system_prompt}\n{ALL_MEMORY}\n{ALL_HISTORY}"  # ¡Overflow!

# ✅ BIEN: Seleccionar información relevante
def build_prompt(self, query: str):
    # Solo memoria relevante
    relevant_memory = self.memory.get_relevant_for_query(query)

    # Solo historial reciente
    recent_history = self.memory.get_history(5)

    # Resumir si es necesario
    if self._estimate_tokens(relevant_memory) > 2000:
        relevant_memory = self._summarize(relevant_memory)

    return f"{self.system_prompt}\n{relevant_memory}\n{recent_history}"
```

### 2. Memoria Stale

```python
# ❌ MAL: Información desactualizada persiste
memory.note("price", 100)  # Guardado hace 1 hora
# ... mucho tiempo después
price = memory.get_note("price")  # Retorna 100 aunque cambió

# ✅ BIEN: TTL y verificación de frescura
memory.note("price", 100, ttl=300)  # Expira en 5 minutos

# O verificar explícitamente
def get_fresh_data(self, key: str, max_age: int = 300):
    item = self.scratchpad.get(key)
    if item:
        age = (datetime.now() - item.timestamp).total_seconds()
        if age < max_age:
            return item.content
        # Refrescar datos si son viejos
        return self._refresh_data(key)
    return None
```

### 3. Pérdida de Contexto Importante

```python
# ❌ MAL: FIFO simple pierde información crítica
history.append(new_message)
if len(history) > limit:
    history.pop(0)  # Puede perder info importante

# ✅ BIEN: Preservar mensajes críticos
def add_to_history(self, message: dict, is_critical: bool = False):
    if is_critical:
        message["_critical"] = True

    self.history.append(message)

    while len(self.history) > self.limit:
        # Buscar mensaje no crítico más antiguo
        for i, msg in enumerate(self.history):
            if not msg.get("_critical"):
                self.history.pop(i)
                break
        else:
            # Todos son críticos, eliminar el más antiguo
            self.history.pop(0)
```

## Aplicaciones de Memoria de Trabajo

| Aplicación | Uso de Memoria |
|------------|----------------|
| Chatbot | Historial de conversación, preferencias |
| Agente de código | Variables definidas, errores previos |
| Asistente de investigación | Fuentes consultadas, hallazgos |
| Agente de soporte | Contexto del ticket, intentos previos |
| Tutor | Progreso del estudiante, errores comunes |

## Resumen

La **memoria de trabajo** mantiene el contexto durante una sesión:

**Componentes clave**:
1. **Scratchpad**: Notas temporales con TTL
2. **Task State**: Objetivo y progreso actual
3. **Results**: Resultados de acciones recientes
4. **User Context**: Preferencias e información del usuario
5. **Conversation History**: Historial de mensajes

**Mejores prácticas**:
- Usar TTL para información temporal
- Priorizar items más relevantes/accedidos
- Resumir cuando el contexto crece demasiado
- Preservar información crítica al recortar
- Separar tipos de memoria por propósito

---

## Navegación

- **Anterior**: [4.3.3 Agente de Automatización de Tareas](../../modulo_4/tema_4.3/4.3.3-agente-automatizacion-tareas.md)
- **Siguiente**: [5.1.2 Memoria Episódica (Long-term)](./5.1.2-memoria-episodica.md)
- **Índice**: [README del Curso](../../README.md)
