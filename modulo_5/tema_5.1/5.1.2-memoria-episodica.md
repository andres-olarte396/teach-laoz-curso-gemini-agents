# 5.1.2 Memoria Epis√≥dica (Long-term)

## Tiempo estimado: 75 minutos
## Nivel: Intermedio-Avanzado

## Prerrequisitos
- Memoria de Trabajo (5.1.1)
- Embeddings b√°sicos
- Conceptos de bases de datos

## ¬øPor qu√© es importante?

La **memoria epis√≥dica** permite a los agentes recordar experiencias pasadas m√°s all√° de la sesi√≥n actual:
- Interacciones previas con el mismo usuario
- Tareas completadas anteriormente
- Errores cometidos y lecciones aprendidas
- Patrones de comportamiento observados

> "La memoria epis√≥dica es el 'diario' del agente - un registro de experiencias espec√≠ficas que puede consultar para informar decisiones futuras."

## Arquitectura de Memoria Epis√≥dica

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SISTEMA DE MEMORIA EPIS√ìDICA                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    NUEVA EXPERIENCIA                             ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   "Usuario pidi√≥ an√°lisis de ventas Q3, preferencia: gr√°ficos"  ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    CODIFICADOR                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   Experiencia ‚îÄ‚îÄ‚ñ∂ Embedding ‚îÄ‚îÄ‚ñ∂ Metadata ‚îÄ‚îÄ‚ñ∂ Episodio           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    ALMAC√âN DE EPISODIOS                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îÇEpisodio ‚îÇ  ‚îÇEpisodio ‚îÇ  ‚îÇEpisodio ‚îÇ  ‚îÇEpisodio ‚îÇ           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   #1    ‚îÇ  ‚îÇ   #2    ‚îÇ  ‚îÇ   #3    ‚îÇ  ‚îÇ   #N    ‚îÇ           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ         ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ         ‚îÇ           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ embed[] ‚îÇ  ‚îÇ embed[] ‚îÇ  ‚îÇ embed[] ‚îÇ  ‚îÇ embed[] ‚îÇ           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ time    ‚îÇ  ‚îÇ time    ‚îÇ  ‚îÇ time    ‚îÇ  ‚îÇ time    ‚îÇ           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ context ‚îÇ  ‚îÇ context ‚îÇ  ‚îÇ context ‚îÇ  ‚îÇ context ‚îÇ           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    RECUPERADOR                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   Query ‚îÄ‚îÄ‚ñ∂ B√∫squeda Sem√°ntica ‚îÄ‚îÄ‚ñ∂ Ranking ‚îÄ‚îÄ‚ñ∂ Episodios       ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Diferencias: Memoria de Trabajo vs Epis√≥dica

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              MEMORIA DE TRABAJO vs MEMORIA EPIS√ìDICA                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                        ‚îÇ
‚îÇ  MEMORIA DE TRABAJO (Short-term)                                       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Duraci√≥n: Una sesi√≥n                                           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Capacidad: Limitada (ventana de contexto)                      ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Acceso: Directo, en el prompt                                  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Contenido: Estado actual, historial reciente                   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Almacenamiento: RAM / Variables                                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Ejemplo: "El usuario acaba de pedir X"                         ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  MEMORIA EPIS√ìDICA (Long-term)                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Duraci√≥n: Persistente (d√≠as, meses, a√±os)                      ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Capacidad: Pr√°cticamente ilimitada                             ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Acceso: Por b√∫squeda sem√°ntica                                 ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Contenido: Experiencias pasadas, interacciones                 ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Almacenamiento: Base de datos / Vector Store                   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Ejemplo: "Hace 2 meses el usuario prefiri√≥ formato tabla"      ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n de Memoria Epis√≥dica

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Optional, Any
from datetime import datetime
import json
import os
import hashlib
import numpy as np

@dataclass
class Episode:
    """
    Representa un episodio de memoria.

    Un episodio es una experiencia espec√≠fica con contexto temporal
    y metadata asociada.
    """
    id: str
    content: str
    embedding: Optional[list[float]] = None
    timestamp: datetime = field(default_factory=datetime.now)
    episode_type: str = "interaction"  # interaction, task, error, insight
    user_id: Optional[str] = None
    context: dict = field(default_factory=dict)
    importance: float = 0.5  # 0.0 a 1.0
    access_count: int = 0
    last_accessed: Optional[datetime] = None

    def to_dict(self) -> dict:
        """Convierte el episodio a diccionario."""
        return {
            "id": self.id,
            "content": self.content,
            "timestamp": self.timestamp.isoformat(),
            "episode_type": self.episode_type,
            "user_id": self.user_id,
            "context": self.context,
            "importance": self.importance,
            "access_count": self.access_count
        }

    @classmethod
    def from_dict(cls, data: dict, embedding: list[float] = None) -> 'Episode':
        """Crea un episodio desde diccionario."""
        return cls(
            id=data["id"],
            content=data["content"],
            embedding=embedding,
            timestamp=datetime.fromisoformat(data["timestamp"]),
            episode_type=data.get("episode_type", "interaction"),
            user_id=data.get("user_id"),
            context=data.get("context", {}),
            importance=data.get("importance", 0.5),
            access_count=data.get("access_count", 0)
        )


class EpisodicMemory:
    """
    Sistema de memoria epis√≥dica para agentes.

    Almacena, indexa y recupera experiencias pasadas
    usando b√∫squeda sem√°ntica basada en embeddings.
    """

    def __init__(
        self,
        model_name: str = "gemini-2.0-flash",
        storage_path: str = "episodic_memory.json"
    ):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)
        self.storage_path = storage_path

        # Almacenamiento en memoria
        self.episodes: dict[str, Episode] = {}
        self.embeddings_matrix: Optional[np.ndarray] = None
        self.episode_ids: list[str] = []

        # Cargar episodios existentes
        self._load_from_storage()

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # CODIFICACI√ìN: Crear y almacenar episodios
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def store_episode(
        self,
        content: str,
        episode_type: str = "interaction",
        user_id: str = None,
        context: dict = None,
        importance: float = 0.5
    ) -> Episode:
        """
        Almacena un nuevo episodio en la memoria.

        Args:
            content: Descripci√≥n textual de la experiencia
            episode_type: Tipo de episodio (interaction, task, error, insight)
            user_id: Identificador del usuario (si aplica)
            context: Metadata adicional
            importance: Importancia del episodio (0.0-1.0)

        Returns:
            Episode creado
        """
        # Generar ID √∫nico
        episode_id = self._generate_id(content)

        # Generar embedding
        embedding = self._generate_embedding(content)

        # Crear episodio
        episode = Episode(
            id=episode_id,
            content=content,
            embedding=embedding,
            episode_type=episode_type,
            user_id=user_id,
            context=context or {},
            importance=importance
        )

        # Almacenar
        self.episodes[episode_id] = episode
        self._update_embeddings_matrix()
        self._save_to_storage()

        print(f"üìù Episodio almacenado: {episode_id[:8]}... ({episode_type})")
        return episode

    def store_interaction(
        self,
        user_message: str,
        agent_response: str,
        user_id: str = None,
        outcome: str = "neutral"  # positive, negative, neutral
    ) -> Episode:
        """
        Almacena una interacci√≥n usuario-agente.
        """
        content = f"Usuario: {user_message}\nAgente: {agent_response}\nResultado: {outcome}"

        return self.store_episode(
            content=content,
            episode_type="interaction",
            user_id=user_id,
            context={
                "user_message": user_message,
                "agent_response": agent_response,
                "outcome": outcome
            },
            importance=0.6 if outcome == "positive" else 0.4
        )

    def store_task_completion(
        self,
        task: str,
        steps: list[str],
        result: str,
        success: bool,
        user_id: str = None
    ) -> Episode:
        """
        Almacena la completaci√≥n de una tarea.
        """
        content = f"Tarea: {task}\nPasos: {steps}\nResultado: {result}\n√âxito: {success}"

        return self.store_episode(
            content=content,
            episode_type="task",
            user_id=user_id,
            context={
                "task": task,
                "steps": steps,
                "result": result,
                "success": success
            },
            importance=0.8 if success else 0.7
        )

    def store_error(
        self,
        error: str,
        context: str,
        resolution: str = None,
        user_id: str = None
    ) -> Episode:
        """
        Almacena un error y su resoluci√≥n (si la hay).
        """
        content = f"Error: {error}\nContexto: {context}"
        if resolution:
            content += f"\nResoluci√≥n: {resolution}"

        return self.store_episode(
            content=content,
            episode_type="error",
            user_id=user_id,
            context={
                "error": error,
                "error_context": context,
                "resolution": resolution
            },
            importance=0.9  # Errores son importantes de recordar
        )

    def store_insight(
        self,
        insight: str,
        source: str = "observation",
        user_id: str = None
    ) -> Episode:
        """
        Almacena un insight o aprendizaje.
        """
        return self.store_episode(
            content=f"Insight: {insight}\nFuente: {source}",
            episode_type="insight",
            user_id=user_id,
            context={"source": source},
            importance=0.85
        )

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # RECUPERACI√ìN: Buscar episodios relevantes
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def recall(
        self,
        query: str,
        k: int = 5,
        episode_types: list[str] = None,
        user_id: str = None,
        min_importance: float = 0.0,
        recency_weight: float = 0.2
    ) -> list[Episode]:
        """
        Recupera episodios relevantes para una consulta.

        Args:
            query: Texto de b√∫squeda
            k: N√∫mero de episodios a retornar
            episode_types: Filtrar por tipo(s) de episodio
            user_id: Filtrar por usuario
            min_importance: Importancia m√≠nima
            recency_weight: Peso para episodios recientes (0.0-1.0)

        Returns:
            Lista de episodios ordenados por relevancia
        """
        if not self.episodes:
            return []

        # Generar embedding de la consulta
        query_embedding = self._generate_embedding(query)

        # Calcular similitudes
        scores = []
        for episode_id in self.episode_ids:
            episode = self.episodes[episode_id]

            # Aplicar filtros
            if episode_types and episode.episode_type not in episode_types:
                continue
            if user_id and episode.user_id != user_id:
                continue
            if episode.importance < min_importance:
                continue

            # Calcular score de similitud
            similarity = self._cosine_similarity(query_embedding, episode.embedding)

            # Ajustar por recencia
            age_days = (datetime.now() - episode.timestamp).days
            recency_score = 1.0 / (1.0 + age_days * 0.1)  # Decay suave

            # Score final
            final_score = (1 - recency_weight) * similarity + recency_weight * recency_score

            # Bonus por importancia
            final_score *= (0.5 + episode.importance * 0.5)

            scores.append((episode, final_score))

        # Ordenar por score y retornar top k
        scores.sort(key=lambda x: x[1], reverse=True)

        # Actualizar contadores de acceso
        results = []
        for episode, score in scores[:k]:
            episode.access_count += 1
            episode.last_accessed = datetime.now()
            results.append(episode)

        self._save_to_storage()
        return results

    def recall_by_type(self, episode_type: str, k: int = 10) -> list[Episode]:
        """Recupera episodios por tipo."""
        episodes = [
            e for e in self.episodes.values()
            if e.episode_type == episode_type
        ]
        # Ordenar por timestamp (m√°s recientes primero)
        episodes.sort(key=lambda x: x.timestamp, reverse=True)
        return episodes[:k]

    def recall_for_user(self, user_id: str, k: int = 10) -> list[Episode]:
        """Recupera episodios de un usuario espec√≠fico."""
        episodes = [
            e for e in self.episodes.values()
            if e.user_id == user_id
        ]
        episodes.sort(key=lambda x: x.timestamp, reverse=True)
        return episodes[:k]

    def recall_similar_errors(self, error: str, k: int = 3) -> list[Episode]:
        """Busca errores similares y sus resoluciones."""
        return self.recall(
            query=error,
            k=k,
            episode_types=["error"],
            min_importance=0.5
        )

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # UTILIDADES
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def _generate_id(self, content: str) -> str:
        """Genera un ID √∫nico para el episodio."""
        timestamp = datetime.now().isoformat()
        hash_input = f"{content}:{timestamp}"
        return hashlib.sha256(hash_input.encode()).hexdigest()[:16]

    def _generate_embedding(self, text: str) -> list[float]:
        """Genera embedding para un texto usando Gemini."""
        try:
            result = genai.embed_content(
                model="models/embedding-001",
                content=text,
                task_type="retrieval_document"
            )
            return result['embedding']
        except Exception as e:
            print(f"Error generando embedding: {e}")
            # Fallback: embedding aleatorio para no bloquear
            return list(np.random.randn(768))

    def _cosine_similarity(self, vec1: list[float], vec2: list[float]) -> float:
        """Calcula similitud coseno entre dos vectores."""
        a = np.array(vec1)
        b = np.array(vec2)
        return float(np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b)))

    def _update_embeddings_matrix(self):
        """Actualiza la matriz de embeddings."""
        self.episode_ids = list(self.episodes.keys())
        if self.episode_ids:
            embeddings = [self.episodes[eid].embedding for eid in self.episode_ids]
            self.embeddings_matrix = np.array(embeddings)

    def _save_to_storage(self):
        """Guarda episodios a disco."""
        data = {
            "episodes": {
                eid: {
                    **episode.to_dict(),
                    "embedding": episode.embedding
                }
                for eid, episode in self.episodes.items()
            }
        }
        with open(self.storage_path, 'w') as f:
            json.dump(data, f, indent=2)

    def _load_from_storage(self):
        """Carga episodios desde disco."""
        if not os.path.exists(self.storage_path):
            return

        try:
            with open(self.storage_path, 'r') as f:
                data = json.load(f)

            for eid, ep_data in data.get("episodes", {}).items():
                embedding = ep_data.pop("embedding", None)
                self.episodes[eid] = Episode.from_dict(ep_data, embedding)

            self._update_embeddings_matrix()
            print(f"üìö Cargados {len(self.episodes)} episodios desde almacenamiento")
        except Exception as e:
            print(f"Error cargando memoria: {e}")

    def get_statistics(self) -> dict:
        """Retorna estad√≠sticas de la memoria."""
        if not self.episodes:
            return {"total": 0}

        by_type = {}
        for ep in self.episodes.values():
            by_type[ep.episode_type] = by_type.get(ep.episode_type, 0) + 1

        ages = [(datetime.now() - ep.timestamp).days for ep in self.episodes.values()]

        return {
            "total": len(self.episodes),
            "by_type": by_type,
            "avg_age_days": sum(ages) / len(ages),
            "oldest_days": max(ages),
            "newest_days": min(ages),
            "avg_importance": sum(ep.importance for ep in self.episodes.values()) / len(self.episodes)
        }
```

## Agente con Memoria Epis√≥dica

```python
class AgentWithEpisodicMemory:
    """
    Agente que utiliza memoria epis√≥dica para aprender de experiencias pasadas.
    """

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)
        self.memory = EpisodicMemory(model_name)
        self.current_user: Optional[str] = None

    def set_user(self, user_id: str):
        """Establece el usuario actual."""
        self.current_user = user_id

    def respond(self, user_message: str) -> str:
        """
        Genera una respuesta informada por experiencias pasadas.
        """
        # 1. Recuperar episodios relevantes
        relevant_episodes = self.memory.recall(
            query=user_message,
            k=3,
            user_id=self.current_user
        )

        # 2. Formatear contexto hist√≥rico
        history_context = self._format_episodes(relevant_episodes)

        # 3. Generar respuesta
        prompt = f"""Eres un agente con memoria de experiencias pasadas.

## Experiencias Relevantes
{history_context}

## Mensaje del Usuario
{user_message}

## Instrucciones
- Usa las experiencias pasadas para informar tu respuesta
- Si hay preferencias del usuario en la memoria, resp√©talas
- Si hubo errores similares antes, menciona las resoluciones
- S√© consistente con interacciones previas

Respuesta:"""

        response = self.model.generate_content(prompt)
        agent_response = response.text

        # 4. Almacenar esta interacci√≥n
        self.memory.store_interaction(
            user_message=user_message,
            agent_response=agent_response,
            user_id=self.current_user
        )

        return agent_response

    def _format_episodes(self, episodes: list[Episode]) -> str:
        """Formatea episodios para el prompt."""
        if not episodes:
            return "No hay experiencias previas relevantes."

        formatted = []
        for ep in episodes:
            age = (datetime.now() - ep.timestamp).days
            formatted.append(f"""
[{ep.episode_type.upper()}] (hace {age} d√≠as)
{ep.content}
""")
        return "\n".join(formatted)

    def learn_from_feedback(self, feedback: str, was_helpful: bool):
        """
        Aprende del feedback del usuario.
        """
        if was_helpful:
            self.memory.store_insight(
                insight=f"El usuario encontr√≥ √∫til: {feedback}",
                source="user_feedback"
            )
        else:
            self.memory.store_error(
                error=f"Respuesta no √∫til: {feedback}",
                context="feedback del usuario",
                resolution="Ajustar enfoque en futuras interacciones"
            )

    def show_memory_stats(self):
        """Muestra estad√≠sticas de la memoria."""
        stats = self.memory.get_statistics()
        print("\nüìä Estad√≠sticas de Memoria Epis√≥dica:")
        print(f"   Total episodios: {stats['total']}")
        print(f"   Por tipo: {stats.get('by_type', {})}")
        print(f"   Edad promedio: {stats.get('avg_age_days', 0):.1f} d√≠as")
        print(f"   Importancia promedio: {stats.get('avg_importance', 0):.2f}")


# Uso
agent = AgentWithEpisodicMemory()
agent.set_user("user_123")

# Primera interacci√≥n
response = agent.respond("¬øPuedes ayudarme a analizar datos de ventas?")
print(response)

# Feedback
agent.learn_from_feedback("Los gr√°ficos de barras son m√°s claros", was_helpful=True)

# Segunda interacci√≥n (usar√° la preferencia aprendida)
response = agent.respond("Necesito otro an√°lisis de datos")
print(response)

# Ver estad√≠sticas
agent.show_memory_stats()
```

## Errores Comunes y Soluciones

### 1. Episodios Irrelevantes

```python
# ‚ùå MAL: Recuperar sin filtrar
episodes = memory.recall(query, k=10)  # Puede traer basura

# ‚úÖ BIEN: Umbral de similitud y filtros
def recall_quality(self, query, k=5, min_similarity=0.7):
    query_emb = self._generate_embedding(query)
    scored = []

    for ep in self.episodes.values():
        sim = self._cosine_similarity(query_emb, ep.embedding)
        if sim >= min_similarity:  # Solo los realmente relevantes
            scored.append((ep, sim))

    scored.sort(key=lambda x: x[1], reverse=True)
    return [ep for ep, _ in scored[:k]]
```

### 2. Memoria Infinita

```python
# ‚ùå MAL: Guardar todo sin l√≠mites
def store(self, content):
    self.episodes[self._generate_id()] = Episode(content)
    # ¬°Crece indefinidamente!

# ‚úÖ BIEN: Consolidaci√≥n y olvido
def store_with_management(self, content, importance):
    # Si excede l√≠mite, consolidar o eliminar
    if len(self.episodes) >= self.max_episodes:
        self._consolidate_old_episodes()
        self._forget_unimportant()

    self.episodes[self._generate_id()] = Episode(content, importance=importance)

def _forget_unimportant(self, threshold=0.3):
    """Elimina episodios de baja importancia poco accedidos."""
    to_delete = [
        eid for eid, ep in self.episodes.items()
        if ep.importance < threshold and ep.access_count < 2
        and (datetime.now() - ep.timestamp).days > 30
    ]
    for eid in to_delete:
        del self.episodes[eid]
```

### 3. Alucinaciones de Memoria

```python
# ‚ùå MAL: Confiar ciegamente en episodios
context = f"Seg√∫n tu memoria: {episode.content}"  # Puede ser incorrecto

# ‚úÖ BIEN: Indicar incertidumbre
def format_with_confidence(self, episodes):
    formatted = []
    for ep in episodes:
        age = (datetime.now() - ep.timestamp).days
        confidence = "alta" if age < 7 else "media" if age < 30 else "baja"

        formatted.append(f"""
[Confianza: {confidence}]
{ep.content}
(Hace {age} d√≠as, accedido {ep.access_count} veces)
""")
    return "\n".join(formatted)
```

## Resumen

La **memoria epis√≥dica** permite recordar experiencias a largo plazo:

**Tipos de episodios**:
- **Interaction**: Di√°logos usuario-agente
- **Task**: Tareas completadas
- **Error**: Errores y resoluciones
- **Insight**: Aprendizajes y observaciones

**Operaciones clave**:
1. **Store**: Codificar y almacenar experiencias
2. **Recall**: Recuperar por similitud sem√°ntica
3. **Manage**: Consolidar, olvidar, actualizar

**Mejores pr√°cticas**:
- Usar embeddings para b√∫squeda sem√°ntica
- Filtrar por relevancia m√≠nima
- Considerar recencia e importancia
- Implementar olvido para gestionar tama√±o
- Indicar confianza en recuerdos antiguos

---

## Navegaci√≥n

- **Anterior**: [5.1.1 Memoria de Trabajo](./5.1.1-memoria-trabajo.md)
- **Siguiente**: [5.1.3 Memoria Sem√°ntica](./5.1.3-memoria-semantica.md)
- **√çndice**: [README del Curso](../../README.md)
