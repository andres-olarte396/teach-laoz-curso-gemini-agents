# 5.1.3 Memoria Sem√°ntica

## Tiempo estimado: 75 minutos
## Nivel: Avanzado

## Prerrequisitos
- Memoria Epis√≥dica (5.1.2)
- Conceptos de ontolog√≠as y taxonom√≠as
- Grafos de conocimiento b√°sicos

## ¬øPor qu√© es importante?

La **memoria sem√°ntica** almacena conocimiento factual generalizado, a diferencia de la memoria epis√≥dica que guarda experiencias espec√≠ficas:
- Hechos sobre el mundo: "Python es un lenguaje de programaci√≥n"
- Relaciones entre conceptos: "Machine Learning es parte de AI"
- Definiciones y taxonom√≠as
- Conocimiento del dominio espec√≠fico

> "La memoria sem√°ntica es la 'enciclopedia interna' del agente - conocimiento abstracto independiente de experiencias espec√≠ficas."

## Comparaci√≥n de Tipos de Memoria

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              TIPOS DE MEMORIA EN AGENTES                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                        ‚îÇ
‚îÇ  MEMORIA DE TRABAJO                                                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Qu√©: Estado actual de la conversaci√≥n                            ‚îÇ ‚îÇ
‚îÇ  ‚îÇ Cu√°ndo: Solo sesi√≥n actual                                       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ Ejemplo: "El usuario est√° preguntando sobre Python"              ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  MEMORIA EPIS√ìDICA                                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Qu√©: Experiencias espec√≠ficas (qu√©, cu√°ndo, d√≥nde)               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ Cu√°ndo: Persiste entre sesiones                                  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ Ejemplo: "Ayer el usuario Juan pregunt√≥ sobre decoradores"       ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  MEMORIA SEM√ÅNTICA                                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Qu√©: Conocimiento factual generalizado (hechos, relaciones)      ‚îÇ ‚îÇ
‚îÇ  ‚îÇ Cu√°ndo: Atemporal, conocimiento permanente                       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ Ejemplo: "Python soporta programaci√≥n orientada a objetos"       ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Arquitectura de Memoria Sem√°ntica

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SISTEMA DE MEMORIA SEM√ÅNTICA                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    GRAFO DE CONOCIMIENTO                         ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ        ‚îÇ Concepto ‚îÇ         ‚îÇ Concepto ‚îÇ                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ        ‚îÇ  Python  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   OOP    ‚îÇ                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ             ‚îÇ                                                    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ             ‚îÇ es_un                                              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ             ‚ñº                                                    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ        ‚îÇ Concepto ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Concepto ‚îÇ                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ        ‚îÇ Lenguaje ‚îÇ   es_un ‚îÇ   Java   ‚îÇ                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    TRIPLAS (SUBJECT-PREDICATE-OBJECT)            ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   (Python) ‚îÄ‚îÄ[es_un]‚îÄ‚îÄ‚ñ∂ (Lenguaje de Programaci√≥n)              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   (Python) ‚îÄ‚îÄ[soporta]‚îÄ‚îÄ‚ñ∂ (OOP)                                 ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   (Python) ‚îÄ‚îÄ[creado_por]‚îÄ‚îÄ‚ñ∂ (Guido van Rossum)                 ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   (Python) ‚îÄ‚îÄ[a√±o_creaci√≥n]‚îÄ‚îÄ‚ñ∂ (1991)                           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    √çNDICE SEM√ÅNTICO                              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   Embeddings de conceptos para b√∫squeda por similitud           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n de Memoria Sem√°ntica

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Optional, Any, Set
from datetime import datetime
import json
import os
import numpy as np
from collections import defaultdict

@dataclass
class Concept:
    """Representa un concepto en la memoria sem√°ntica."""
    id: str
    name: str
    definition: str
    embedding: Optional[list[float]] = None
    category: str = "general"
    aliases: list[str] = field(default_factory=list)
    properties: dict = field(default_factory=dict)
    confidence: float = 1.0
    source: str = "system"  # system, learned, user

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "name": self.name,
            "definition": self.definition,
            "category": self.category,
            "aliases": self.aliases,
            "properties": self.properties,
            "confidence": self.confidence,
            "source": self.source
        }

@dataclass
class Relation:
    """Representa una relaci√≥n entre conceptos (tripla)."""
    subject_id: str
    predicate: str
    object_id: str
    confidence: float = 1.0
    source: str = "system"
    metadata: dict = field(default_factory=dict)

    def to_tuple(self) -> tuple:
        return (self.subject_id, self.predicate, self.object_id)

    def to_dict(self) -> dict:
        return {
            "subject": self.subject_id,
            "predicate": self.predicate,
            "object": self.object_id,
            "confidence": self.confidence,
            "source": self.source
        }


class SemanticMemory:
    """
    Sistema de memoria sem√°ntica basado en grafos de conocimiento.
    """

    # Predicados comunes
    PREDICATES = {
        "is_a": "Es un tipo de",
        "part_of": "Es parte de",
        "has_property": "Tiene la propiedad",
        "related_to": "Est√° relacionado con",
        "used_for": "Se usa para",
        "created_by": "Creado por",
        "contains": "Contiene",
        "requires": "Requiere",
        "produces": "Produce",
        "opposite_of": "Es opuesto a"
    }

    def __init__(
        self,
        model_name: str = "gemini-2.0-flash",
        storage_path: str = "semantic_memory.json"
    ):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)
        self.storage_path = storage_path

        # Almacenamiento
        self.concepts: dict[str, Concept] = {}
        self.relations: list[Relation] = []

        # √çndices para b√∫squeda eficiente
        self.concept_by_name: dict[str, str] = {}  # name -> id
        self.relations_by_subject: dict[str, list[Relation]] = defaultdict(list)
        self.relations_by_object: dict[str, list[Relation]] = defaultdict(list)
        self.relations_by_predicate: dict[str, list[Relation]] = defaultdict(list)

        self._load_from_storage()

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # GESTI√ìN DE CONCEPTOS
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def add_concept(
        self,
        name: str,
        definition: str,
        category: str = "general",
        aliases: list[str] = None,
        properties: dict = None,
        source: str = "system"
    ) -> Concept:
        """
        Agrega un concepto a la memoria sem√°ntica.
        """
        # Verificar si ya existe
        existing_id = self.concept_by_name.get(name.lower())
        if existing_id:
            print(f"‚ö†Ô∏è Concepto '{name}' ya existe, actualizando...")
            return self.update_concept(existing_id, definition=definition)

        # Crear ID
        concept_id = self._generate_concept_id(name)

        # Generar embedding
        embedding = self._generate_embedding(f"{name}: {definition}")

        # Crear concepto
        concept = Concept(
            id=concept_id,
            name=name,
            definition=definition,
            embedding=embedding,
            category=category,
            aliases=aliases or [],
            properties=properties or {},
            source=source
        )

        # Almacenar
        self.concepts[concept_id] = concept
        self.concept_by_name[name.lower()] = concept_id
        for alias in concept.aliases:
            self.concept_by_name[alias.lower()] = concept_id

        self._save_to_storage()
        print(f"üìñ Concepto agregado: {name}")
        return concept

    def get_concept(self, name_or_id: str) -> Optional[Concept]:
        """Obtiene un concepto por nombre o ID."""
        # Primero buscar por ID
        if name_or_id in self.concepts:
            return self.concepts[name_or_id]

        # Luego por nombre
        concept_id = self.concept_by_name.get(name_or_id.lower())
        if concept_id:
            return self.concepts.get(concept_id)

        return None

    def update_concept(self, concept_id: str, **updates) -> Optional[Concept]:
        """Actualiza un concepto existente."""
        concept = self.concepts.get(concept_id)
        if not concept:
            return None

        for key, value in updates.items():
            if hasattr(concept, key):
                setattr(concept, key, value)

        # Regenerar embedding si cambi√≥ la definici√≥n
        if "definition" in updates:
            concept.embedding = self._generate_embedding(
                f"{concept.name}: {concept.definition}"
            )

        self._save_to_storage()
        return concept

    def find_similar_concepts(self, query: str, k: int = 5) -> list[tuple[Concept, float]]:
        """Encuentra conceptos sem√°nticamente similares."""
        query_embedding = self._generate_embedding(query)

        scored = []
        for concept in self.concepts.values():
            if concept.embedding:
                similarity = self._cosine_similarity(query_embedding, concept.embedding)
                scored.append((concept, similarity))

        scored.sort(key=lambda x: x[1], reverse=True)
        return scored[:k]

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # GESTI√ìN DE RELACIONES
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def add_relation(
        self,
        subject: str,
        predicate: str,
        obj: str,
        confidence: float = 1.0,
        source: str = "system"
    ) -> Optional[Relation]:
        """
        Agrega una relaci√≥n entre dos conceptos.

        Args:
            subject: Nombre o ID del concepto sujeto
            predicate: Tipo de relaci√≥n
            obj: Nombre o ID del concepto objeto
            confidence: Confianza en la relaci√≥n
            source: Fuente de la informaci√≥n
        """
        # Resolver conceptos
        subject_concept = self.get_concept(subject)
        object_concept = self.get_concept(obj)

        # Crear conceptos si no existen
        if not subject_concept:
            subject_concept = self.add_concept(subject, f"Concepto: {subject}")
        if not object_concept:
            object_concept = self.add_concept(obj, f"Concepto: {obj}")

        # Verificar si la relaci√≥n ya existe
        for rel in self.relations:
            if (rel.subject_id == subject_concept.id and
                rel.predicate == predicate and
                rel.object_id == object_concept.id):
                print(f"‚ö†Ô∏è Relaci√≥n ya existe")
                return rel

        # Crear relaci√≥n
        relation = Relation(
            subject_id=subject_concept.id,
            predicate=predicate,
            object_id=object_concept.id,
            confidence=confidence,
            source=source
        )

        # Almacenar e indexar
        self.relations.append(relation)
        self.relations_by_subject[relation.subject_id].append(relation)
        self.relations_by_object[relation.object_id].append(relation)
        self.relations_by_predicate[relation.predicate].append(relation)

        self._save_to_storage()
        print(f"üîó Relaci√≥n agregada: {subject} --[{predicate}]--> {obj}")
        return relation

    def get_relations_for(
        self,
        concept: str,
        predicate: str = None,
        direction: str = "both"  # subject, object, both
    ) -> list[Relation]:
        """
        Obtiene relaciones de un concepto.
        """
        concept_obj = self.get_concept(concept)
        if not concept_obj:
            return []

        relations = []

        if direction in ["subject", "both"]:
            rels = self.relations_by_subject.get(concept_obj.id, [])
            if predicate:
                rels = [r for r in rels if r.predicate == predicate]
            relations.extend(rels)

        if direction in ["object", "both"]:
            rels = self.relations_by_object.get(concept_obj.id, [])
            if predicate:
                rels = [r for r in rels if r.predicate == predicate]
            relations.extend(rels)

        return relations

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # CONSULTAS AVANZADAS
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def query(self, question: str) -> str:
        """
        Responde una pregunta usando la memoria sem√°ntica.
        """
        # 1. Encontrar conceptos relevantes
        relevant = self.find_similar_concepts(question, k=5)

        if not relevant:
            return "No tengo informaci√≥n sobre eso en mi memoria sem√°ntica."

        # 2. Obtener relaciones de los conceptos relevantes
        knowledge = []
        for concept, score in relevant:
            if score < 0.5:
                continue

            knowledge.append(f"**{concept.name}**: {concept.definition}")

            relations = self.get_relations_for(concept.name)
            for rel in relations[:5]:
                subj = self.concepts.get(rel.subject_id)
                obj = self.concepts.get(rel.object_id)
                if subj and obj:
                    predicate_desc = self.PREDICATES.get(rel.predicate, rel.predicate)
                    knowledge.append(f"  - {subj.name} {predicate_desc} {obj.name}")

        # 3. Generar respuesta
        prompt = f"""Usando este conocimiento de la memoria sem√°ntica:

{chr(10).join(knowledge)}

Responde a esta pregunta: {question}

Si el conocimiento no es suficiente, ind√≠calo claramente."""

        response = self.model.generate_content(prompt)
        return response.text

    def get_hierarchy(self, concept_name: str, depth: int = 3) -> dict:
        """
        Obtiene la jerarqu√≠a de un concepto (is_a relations).
        """
        concept = self.get_concept(concept_name)
        if not concept:
            return {}

        def build_tree(concept_id: str, current_depth: int) -> dict:
            if current_depth <= 0:
                return {}

            concept = self.concepts.get(concept_id)
            if not concept:
                return {}

            tree = {"name": concept.name, "children": []}

            # Buscar hijos (conceptos que son "is_a" de este)
            for rel in self.relations:
                if rel.predicate == "is_a" and rel.object_id == concept_id:
                    child_tree = build_tree(rel.subject_id, current_depth - 1)
                    if child_tree:
                        tree["children"].append(child_tree)

            return tree

        return build_tree(concept.id, depth)

    def get_path_between(
        self,
        concept1: str,
        concept2: str,
        max_depth: int = 4
    ) -> Optional[list[tuple[str, str, str]]]:
        """
        Encuentra un camino de relaciones entre dos conceptos.
        """
        start = self.get_concept(concept1)
        end = self.get_concept(concept2)

        if not start or not end:
            return None

        # BFS para encontrar camino
        from collections import deque

        visited = set()
        queue = deque([(start.id, [])])

        while queue:
            current_id, path = queue.popleft()

            if current_id == end.id:
                return path

            if current_id in visited or len(path) >= max_depth:
                continue

            visited.add(current_id)

            # Explorar relaciones salientes
            for rel in self.relations_by_subject.get(current_id, []):
                if rel.object_id not in visited:
                    current = self.concepts.get(current_id)
                    target = self.concepts.get(rel.object_id)
                    if current and target:
                        new_path = path + [(current.name, rel.predicate, target.name)]
                        queue.append((rel.object_id, new_path))

            # Explorar relaciones entrantes (inversas)
            for rel in self.relations_by_object.get(current_id, []):
                if rel.subject_id not in visited:
                    current = self.concepts.get(current_id)
                    source = self.concepts.get(rel.subject_id)
                    if current and source:
                        new_path = path + [(source.name, f"inverse_{rel.predicate}", current.name)]
                        queue.append((rel.subject_id, new_path))

        return None

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # APRENDIZAJE AUTOM√ÅTICO
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def learn_from_text(self, text: str, source: str = "learned") -> dict:
        """
        Extrae conocimiento de un texto y lo agrega a la memoria.
        """
        prompt = f"""Extrae conocimiento factual de este texto en formato JSON:

TEXTO:
{text}

Extrae:
1. Conceptos mencionados con sus definiciones
2. Relaciones entre conceptos

Formato:
{{
    "concepts": [
        {{"name": "...", "definition": "...", "category": "..."}}
    ],
    "relations": [
        {{"subject": "...", "predicate": "is_a|part_of|has_property|related_to|used_for", "object": "..."}}
    ]
}}

Solo incluye informaci√≥n expl√≠cita en el texto."""

        response = self.model.generate_content(prompt)

        try:
            text = response.text.strip()
            if text.startswith("```"):
                text = text.split("```")[1]
                if text.startswith("json"):
                    text = text[4:]

            data = json.loads(text)

            # Agregar conceptos
            added_concepts = []
            for c in data.get("concepts", []):
                concept = self.add_concept(
                    name=c["name"],
                    definition=c.get("definition", ""),
                    category=c.get("category", "learned"),
                    source=source
                )
                added_concepts.append(concept.name)

            # Agregar relaciones
            added_relations = []
            for r in data.get("relations", []):
                rel = self.add_relation(
                    subject=r["subject"],
                    predicate=r["predicate"],
                    obj=r["object"],
                    source=source
                )
                if rel:
                    added_relations.append(rel.to_tuple())

            return {
                "concepts_added": added_concepts,
                "relations_added": added_relations
            }

        except json.JSONDecodeError:
            return {"error": "No se pudo parsear el conocimiento extra√≠do"}

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # UTILIDADES
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def _generate_concept_id(self, name: str) -> str:
        import hashlib
        return hashlib.sha256(name.lower().encode()).hexdigest()[:12]

    def _generate_embedding(self, text: str) -> list[float]:
        try:
            result = genai.embed_content(
                model="models/embedding-001",
                content=text,
                task_type="retrieval_document"
            )
            return result['embedding']
        except:
            return list(np.random.randn(768))

    def _cosine_similarity(self, vec1: list[float], vec2: list[float]) -> float:
        a = np.array(vec1)
        b = np.array(vec2)
        return float(np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b)))

    def _save_to_storage(self):
        data = {
            "concepts": {cid: {**c.to_dict(), "embedding": c.embedding}
                        for cid, c in self.concepts.items()},
            "relations": [r.to_dict() for r in self.relations]
        }
        with open(self.storage_path, 'w') as f:
            json.dump(data, f, indent=2)

    def _load_from_storage(self):
        if not os.path.exists(self.storage_path):
            return

        try:
            with open(self.storage_path, 'r') as f:
                data = json.load(f)

            for cid, cdata in data.get("concepts", {}).items():
                embedding = cdata.pop("embedding", None)
                self.concepts[cid] = Concept(
                    id=cdata["id"],
                    name=cdata["name"],
                    definition=cdata["definition"],
                    embedding=embedding,
                    category=cdata.get("category", "general"),
                    aliases=cdata.get("aliases", []),
                    properties=cdata.get("properties", {}),
                    confidence=cdata.get("confidence", 1.0),
                    source=cdata.get("source", "system")
                )
                self.concept_by_name[cdata["name"].lower()] = cid

            for rdata in data.get("relations", []):
                rel = Relation(
                    subject_id=rdata["subject"],
                    predicate=rdata["predicate"],
                    object_id=rdata["object"],
                    confidence=rdata.get("confidence", 1.0),
                    source=rdata.get("source", "system")
                )
                self.relations.append(rel)
                self.relations_by_subject[rel.subject_id].append(rel)
                self.relations_by_object[rel.object_id].append(rel)
                self.relations_by_predicate[rel.predicate].append(rel)

            print(f"üìö Cargados {len(self.concepts)} conceptos y {len(self.relations)} relaciones")

        except Exception as e:
            print(f"Error cargando memoria sem√°ntica: {e}")

    def get_statistics(self) -> dict:
        by_category = defaultdict(int)
        for c in self.concepts.values():
            by_category[c.category] += 1

        by_predicate = defaultdict(int)
        for r in self.relations:
            by_predicate[r.predicate] += 1

        return {
            "total_concepts": len(self.concepts),
            "total_relations": len(self.relations),
            "concepts_by_category": dict(by_category),
            "relations_by_predicate": dict(by_predicate)
        }
```

## Ejemplo de Uso

```python
# Crear memoria sem√°ntica
memory = SemanticMemory()

# Agregar conceptos
memory.add_concept("Python", "Lenguaje de programaci√≥n de alto nivel", category="programming")
memory.add_concept("Machine Learning", "Subcampo de IA que permite aprender de datos", category="ai")
memory.add_concept("Neural Network", "Modelo computacional inspirado en el cerebro", category="ai")
memory.add_concept("TensorFlow", "Biblioteca de machine learning de Google", category="framework")

# Agregar relaciones
memory.add_relation("Python", "used_for", "Machine Learning")
memory.add_relation("Neural Network", "is_a", "Machine Learning")
memory.add_relation("TensorFlow", "is_a", "Machine Learning")
memory.add_relation("TensorFlow", "requires", "Python")

# Consultar
answer = memory.query("¬øQu√© relaci√≥n tiene Python con Machine Learning?")
print(answer)

# Aprender de texto
text = """
Django es un framework web de alto nivel escrito en Python.
Sigue el patr√≥n MVC (Modelo-Vista-Controlador) y es utilizado
para desarrollo r√°pido de aplicaciones web seguras.
"""
result = memory.learn_from_text(text)
print(f"Aprendido: {result}")

# Encontrar camino entre conceptos
path = memory.get_path_between("TensorFlow", "Python")
if path:
    print("Camino encontrado:")
    for subj, pred, obj in path:
        print(f"  {subj} --[{pred}]--> {obj}")

# Estad√≠sticas
print(memory.get_statistics())
```

## Resumen

La **memoria sem√°ntica** almacena conocimiento factual:

**Componentes**:
1. **Conceptos**: Entidades con definiciones y propiedades
2. **Relaciones**: Triplas subject-predicate-object
3. **√çndices**: Para b√∫squeda eficiente

**Operaciones**:
- Agregar y consultar conceptos
- Definir relaciones entre conceptos
- B√∫squeda sem√°ntica por similitud
- Navegaci√≥n del grafo de conocimiento
- Aprendizaje autom√°tico desde texto

---

## Navegaci√≥n

- **Anterior**: [5.1.2 Memoria Epis√≥dica](./5.1.2-memoria-episodica.md)
- **Siguiente**: [5.2.1 Memoria con Vector Stores](../tema_5.2/5.2.1-memoria-vector-stores.md)
- **√çndice**: [README del Curso](../../README.md)
