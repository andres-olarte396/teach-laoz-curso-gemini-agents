# 5.2.2 Memoria Estructurada (Grafos de Conocimiento)

## Tiempo estimado: 90 minutos
## Nivel: Avanzado

## Prerrequisitos
- Memoria Sem√°ntica (5.1.3)
- Vector Stores (5.2.1)
- Conceptos b√°sicos de grafos

## ¬øPor qu√© es importante?

Los **grafos de conocimiento** ofrecen ventajas √∫nicas sobre los vector stores:
- Relaciones expl√≠citas entre entidades
- Razonamiento transitivo (A‚ÜíB‚ÜíC implica A‚ÜíC)
- Consultas estructuradas precisas
- Explicabilidad de las conexiones

> "Los grafos de conocimiento capturan el 'c√≥mo' y 'por qu√©' de las conexiones, no solo el 'qu√©'."

## Arquitectura de Memoria con Grafos

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    MEMORIA CON GRAFO DE CONOCIMIENTO                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    ESTRUCTURA DEL GRAFO                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ            ‚îÇ Usuario ‚îÇ                                           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ            ‚îÇ  Juan   ‚îÇ                                           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                 ‚îÇ                                                ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ          [pregunt√≥_sobre]                                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                 ‚îÇ                                                ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                 ‚ñº                                                ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        [es_parte_de]        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ            ‚îÇ Python  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   AI    ‚îÇ  ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                 ‚îÇ                                       ‚îÇ        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ          [usado_para]                            [incluye]      ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                 ‚îÇ                                       ‚îÇ        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                 ‚ñº                                       ‚ñº        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ            ‚îÇ   ML    ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[usa]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ Gemini  ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    TIPOS DE NODOS                                ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Entity: Personas, lugares, cosas (Usuario, Python)          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Concept: Ideas abstractas (ML, AI)                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Event: Acciones y eventos (pregunt√≥, complet√≥)              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Property: Atributos (preferencia, nivel)                    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    TIPOS DE RELACIONES                           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Sem√°nticas: is_a, part_of, related_to                       ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Temporales: before, after, during                           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Causales: causes, enables, prevents                         ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Agentivas: created_by, used_by, asked_about                 ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n con NetworkX

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Optional, Any, Set
from datetime import datetime
import networkx as nx
import json
import os

@dataclass
class Node:
    """Nodo en el grafo de conocimiento."""
    id: str
    label: str
    node_type: str  # entity, concept, event, property
    properties: dict = field(default_factory=dict)
    embedding: Optional[list[float]] = None
    created_at: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "label": self.label,
            "node_type": self.node_type,
            "properties": self.properties,
            "created_at": self.created_at.isoformat()
        }

@dataclass
class Edge:
    """Arista en el grafo de conocimiento."""
    source_id: str
    target_id: str
    relation_type: str
    properties: dict = field(default_factory=dict)
    weight: float = 1.0
    created_at: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> dict:
        return {
            "source": self.source_id,
            "target": self.target_id,
            "relation": self.relation_type,
            "properties": self.properties,
            "weight": self.weight
        }


class KnowledgeGraphMemory:
    """
    Sistema de memoria basado en grafos de conocimiento.
    """

    # Relaciones predefinidas
    RELATIONS = {
        # Sem√°nticas
        "is_a": {"inverse": "has_instance", "transitive": True},
        "part_of": {"inverse": "has_part", "transitive": True},
        "related_to": {"inverse": "related_to", "transitive": False},

        # Temporales
        "before": {"inverse": "after", "transitive": True},
        "during": {"inverse": None, "transitive": False},

        # Causales
        "causes": {"inverse": "caused_by", "transitive": False},
        "enables": {"inverse": "enabled_by", "transitive": False},

        # Agentivas
        "created_by": {"inverse": "created", "transitive": False},
        "used_by": {"inverse": "uses", "transitive": False},
        "asked_about": {"inverse": "was_asked_by", "transitive": False},
        "knows": {"inverse": "known_by", "transitive": False},
        "prefers": {"inverse": "preferred_by", "transitive": False}
    }

    def __init__(
        self,
        model_name: str = "gemini-2.0-flash",
        storage_path: str = "knowledge_graph.json"
    ):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)
        self.storage_path = storage_path

        # Grafo NetworkX
        self.graph = nx.DiGraph()

        # √çndices
        self.nodes: dict[str, Node] = {}
        self.edges: list[Edge] = []
        self.label_to_id: dict[str, str] = {}

        self._load_from_storage()

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # GESTI√ìN DE NODOS
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def add_node(
        self,
        label: str,
        node_type: str = "entity",
        properties: dict = None,
        generate_embedding: bool = True
    ) -> Node:
        """
        Agrega un nodo al grafo.
        """
        # Verificar si existe
        if label.lower() in self.label_to_id:
            existing_id = self.label_to_id[label.lower()]
            print(f"‚ö†Ô∏è Nodo '{label}' ya existe")
            return self.nodes[existing_id]

        # Crear nodo
        node_id = self._generate_id(label)

        embedding = None
        if generate_embedding:
            embedding = self._generate_embedding(
                f"{label}: {properties.get('description', '')}"
            )

        node = Node(
            id=node_id,
            label=label,
            node_type=node_type,
            properties=properties or {},
            embedding=embedding
        )

        # Agregar a estructuras
        self.nodes[node_id] = node
        self.label_to_id[label.lower()] = node_id
        self.graph.add_node(
            node_id,
            label=label,
            node_type=node_type,
            **node.properties
        )

        self._save_to_storage()
        print(f"üìç Nodo agregado: {label} ({node_type})")
        return node

    def get_node(self, label_or_id: str) -> Optional[Node]:
        """Obtiene un nodo por label o ID."""
        if label_or_id in self.nodes:
            return self.nodes[label_or_id]

        node_id = self.label_to_id.get(label_or_id.lower())
        if node_id:
            return self.nodes.get(node_id)

        return None

    def update_node(self, label_or_id: str, **properties) -> Optional[Node]:
        """Actualiza propiedades de un nodo."""
        node = self.get_node(label_or_id)
        if not node:
            return None

        node.properties.update(properties)
        nx.set_node_attributes(self.graph, {node.id: properties})

        self._save_to_storage()
        return node

    def delete_node(self, label_or_id: str) -> bool:
        """Elimina un nodo y sus relaciones."""
        node = self.get_node(label_or_id)
        if not node:
            return False

        # Eliminar de estructuras
        del self.nodes[node.id]
        del self.label_to_id[node.label.lower()]
        self.graph.remove_node(node.id)

        # Eliminar aristas relacionadas
        self.edges = [e for e in self.edges
                     if e.source_id != node.id and e.target_id != node.id]

        self._save_to_storage()
        print(f"üóëÔ∏è Nodo eliminado: {node.label}")
        return True

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # GESTI√ìN DE RELACIONES
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def add_relation(
        self,
        source: str,
        relation_type: str,
        target: str,
        properties: dict = None,
        weight: float = 1.0,
        create_inverse: bool = True
    ) -> Optional[Edge]:
        """
        Agrega una relaci√≥n entre dos nodos.
        """
        # Obtener o crear nodos
        source_node = self.get_node(source)
        if not source_node:
            source_node = self.add_node(source)

        target_node = self.get_node(target)
        if not target_node:
            target_node = self.add_node(target)

        # Verificar si la relaci√≥n ya existe
        if self.graph.has_edge(source_node.id, target_node.id):
            existing = self.graph.edges[source_node.id, target_node.id]
            if existing.get("relation") == relation_type:
                print(f"‚ö†Ô∏è Relaci√≥n ya existe")
                return None

        # Crear arista
        edge = Edge(
            source_id=source_node.id,
            target_id=target_node.id,
            relation_type=relation_type,
            properties=properties or {},
            weight=weight
        )

        self.edges.append(edge)
        self.graph.add_edge(
            source_node.id,
            target_node.id,
            relation=relation_type,
            weight=weight,
            **edge.properties
        )

        # Crear relaci√≥n inversa si existe
        if create_inverse:
            rel_info = self.RELATIONS.get(relation_type, {})
            inverse = rel_info.get("inverse")
            if inverse:
                inverse_edge = Edge(
                    source_id=target_node.id,
                    target_id=source_node.id,
                    relation_type=inverse,
                    properties=properties or {},
                    weight=weight
                )
                self.edges.append(inverse_edge)
                self.graph.add_edge(
                    target_node.id,
                    source_node.id,
                    relation=inverse,
                    weight=weight
                )

        self._save_to_storage()
        print(f"üîó Relaci√≥n: {source} --[{relation_type}]--> {target}")
        return edge

    def get_relations(
        self,
        node: str,
        relation_type: str = None,
        direction: str = "both"  # out, in, both
    ) -> list[dict]:
        """
        Obtiene relaciones de un nodo.
        """
        node_obj = self.get_node(node)
        if not node_obj:
            return []

        relations = []

        if direction in ["out", "both"]:
            for target_id in self.graph.successors(node_obj.id):
                edge_data = self.graph.edges[node_obj.id, target_id]
                if relation_type and edge_data.get("relation") != relation_type:
                    continue

                target = self.nodes.get(target_id)
                if target:
                    relations.append({
                        "direction": "out",
                        "source": node_obj.label,
                        "relation": edge_data.get("relation"),
                        "target": target.label,
                        "properties": {k: v for k, v in edge_data.items()
                                      if k not in ["relation", "weight"]}
                    })

        if direction in ["in", "both"]:
            for source_id in self.graph.predecessors(node_obj.id):
                edge_data = self.graph.edges[source_id, node_obj.id]
                if relation_type and edge_data.get("relation") != relation_type:
                    continue

                source = self.nodes.get(source_id)
                if source:
                    relations.append({
                        "direction": "in",
                        "source": source.label,
                        "relation": edge_data.get("relation"),
                        "target": node_obj.label,
                        "properties": {k: v for k, v in edge_data.items()
                                      if k not in ["relation", "weight"]}
                    })

        return relations

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # CONSULTAS AVANZADAS
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def find_path(
        self,
        source: str,
        target: str,
        max_length: int = 4
    ) -> Optional[list[dict]]:
        """
        Encuentra el camino m√°s corto entre dos nodos.
        """
        source_node = self.get_node(source)
        target_node = self.get_node(target)

        if not source_node or not target_node:
            return None

        try:
            path = nx.shortest_path(
                self.graph,
                source_node.id,
                target_node.id
            )

            if len(path) > max_length + 1:
                return None

            # Formatear camino
            result = []
            for i in range(len(path) - 1):
                src = self.nodes[path[i]]
                tgt = self.nodes[path[i + 1]]
                edge = self.graph.edges[path[i], path[i + 1]]

                result.append({
                    "from": src.label,
                    "relation": edge.get("relation", "related_to"),
                    "to": tgt.label
                })

            return result

        except nx.NetworkXNoPath:
            return None

    def get_neighbors(
        self,
        node: str,
        depth: int = 1,
        relation_types: list[str] = None
    ) -> dict:
        """
        Obtiene el subgrafo de vecinos de un nodo.
        """
        node_obj = self.get_node(node)
        if not node_obj:
            return {}

        # BFS para obtener vecinos hasta cierta profundidad
        visited = {node_obj.id}
        current_level = [node_obj.id]
        result = {"center": node_obj.label, "neighbors": []}

        for d in range(depth):
            next_level = []
            for nid in current_level:
                for neighbor_id in self.graph.neighbors(nid):
                    if neighbor_id not in visited:
                        edge = self.graph.edges[nid, neighbor_id]
                        rel = edge.get("relation")

                        if relation_types and rel not in relation_types:
                            continue

                        visited.add(neighbor_id)
                        next_level.append(neighbor_id)

                        neighbor = self.nodes.get(neighbor_id)
                        if neighbor:
                            result["neighbors"].append({
                                "node": neighbor.label,
                                "relation": rel,
                                "depth": d + 1
                            })

            current_level = next_level

        return result

    def query_pattern(
        self,
        pattern: str
    ) -> list[dict]:
        """
        Consulta el grafo con un patr√≥n simple.

        Patrones soportados:
        - "A -> B": A tiene alguna relaci√≥n con B
        - "A -[rel]-> B": A tiene relaci√≥n 'rel' con B
        - "A -[rel]-> ?": Encontrar todos los B donde A -[rel]-> B
        - "? -[rel]-> B": Encontrar todos los A donde A -[rel]-> B
        """
        import re

        # Parsear patr√≥n
        match = re.match(r"(\?|\w+)\s*-\[?(\w+)?\]?->\s*(\?|\w+)", pattern)
        if not match:
            return []

        source_pattern, relation, target_pattern = match.groups()
        results = []

        for edge in self.edges:
            source = self.nodes.get(edge.source_id)
            target = self.nodes.get(edge.target_id)

            if not source or not target:
                continue

            # Verificar source
            if source_pattern != "?" and source.label.lower() != source_pattern.lower():
                continue

            # Verificar relation
            if relation and edge.relation_type != relation:
                continue

            # Verificar target
            if target_pattern != "?" and target.label.lower() != target_pattern.lower():
                continue

            results.append({
                "source": source.label,
                "relation": edge.relation_type,
                "target": target.label
            })

        return results

    def reason_about(self, question: str) -> str:
        """
        Responde una pregunta usando razonamiento sobre el grafo.
        """
        # 1. Extraer entidades de la pregunta
        entities = self._extract_entities(question)

        # 2. Obtener subgrafo relevante
        relevant_facts = []
        for entity in entities:
            node = self.get_node(entity)
            if node:
                relations = self.get_relations(node.label)
                for rel in relations:
                    relevant_facts.append(
                        f"{rel['source']} {rel['relation']} {rel['target']}"
                    )

                # Tambi√©n obtener vecinos
                neighbors = self.get_neighbors(node.label, depth=2)
                for n in neighbors.get("neighbors", []):
                    relevant_facts.append(
                        f"{node.label} {n['relation']} {n['node']}"
                    )

        # 3. Generar respuesta con LLM
        prompt = f"""Usando estos hechos del grafo de conocimiento:

{chr(10).join(set(relevant_facts)) if relevant_facts else "No se encontraron hechos relevantes."}

Responde a esta pregunta: {question}

Si los hechos no son suficientes, ind√≠calo claramente.
Muestra tu razonamiento paso a paso."""

        response = self.model.generate_content(prompt)
        return response.text

    def _extract_entities(self, text: str) -> list[str]:
        """Extrae entidades potenciales del texto."""
        # Simplificado: usar palabras capitalizadas y sustantivos
        entities = []
        for word in text.split():
            word_clean = word.strip(".,?!")
            # Buscar si existe como nodo
            if word_clean.lower() in self.label_to_id:
                entities.append(word_clean)

        return entities

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # APRENDIZAJE
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def learn_from_text(self, text: str, source: str = "learned") -> dict:
        """
        Extrae conocimiento de texto y lo agrega al grafo.
        """
        prompt = f"""Extrae entidades y relaciones de este texto.

TEXTO:
{text}

Extrae en formato JSON:
{{
    "entities": [
        {{"label": "nombre", "type": "entity|concept|event", "description": "..."}}
    ],
    "relations": [
        {{"source": "entidad1", "relation": "tipo_relacion", "target": "entidad2"}}
    ]
}}

Tipos de relaci√≥n v√°lidos: {list(self.RELATIONS.keys())}

Solo extrae informaci√≥n expl√≠cita en el texto."""

        response = self.model.generate_content(prompt)

        try:
            text_response = response.text.strip()
            if text_response.startswith("```"):
                text_response = text_response.split("```")[1]
                if text_response.startswith("json"):
                    text_response = text_response[4:]

            data = json.loads(text_response)

            # Agregar entidades
            added_entities = []
            for e in data.get("entities", []):
                node = self.add_node(
                    label=e["label"],
                    node_type=e.get("type", "entity"),
                    properties={"description": e.get("description", ""), "source": source}
                )
                added_entities.append(node.label)

            # Agregar relaciones
            added_relations = []
            for r in data.get("relations", []):
                rel_type = r["relation"]
                if rel_type not in self.RELATIONS:
                    rel_type = "related_to"

                edge = self.add_relation(
                    source=r["source"],
                    relation_type=rel_type,
                    target=r["target"]
                )
                if edge:
                    added_relations.append(f"{r['source']} -> {r['target']}")

            return {
                "entities_added": added_entities,
                "relations_added": added_relations
            }

        except json.JSONDecodeError:
            return {"error": "No se pudo parsear"}

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # UTILIDADES
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def _generate_id(self, label: str) -> str:
        import hashlib
        return hashlib.sha256(label.lower().encode()).hexdigest()[:12]

    def _generate_embedding(self, text: str) -> list[float]:
        try:
            result = genai.embed_content(
                model="models/embedding-001",
                content=text
            )
            return result['embedding']
        except:
            import numpy as np
            return list(np.random.randn(768))

    def _save_to_storage(self):
        data = {
            "nodes": {nid: {**n.to_dict(), "embedding": n.embedding}
                     for nid, n in self.nodes.items()},
            "edges": [e.to_dict() for e in self.edges]
        }
        with open(self.storage_path, 'w') as f:
            json.dump(data, f, indent=2)

    def _load_from_storage(self):
        if not os.path.exists(self.storage_path):
            return

        try:
            with open(self.storage_path, 'r') as f:
                data = json.load(f)

            for nid, ndata in data.get("nodes", {}).items():
                embedding = ndata.pop("embedding", None)
                node = Node(
                    id=ndata["id"],
                    label=ndata["label"],
                    node_type=ndata["node_type"],
                    properties=ndata.get("properties", {}),
                    embedding=embedding
                )
                self.nodes[nid] = node
                self.label_to_id[node.label.lower()] = nid
                self.graph.add_node(nid, label=node.label, **node.properties)

            for edata in data.get("edges", []):
                edge = Edge(
                    source_id=edata["source"],
                    target_id=edata["target"],
                    relation_type=edata["relation"],
                    properties=edata.get("properties", {}),
                    weight=edata.get("weight", 1.0)
                )
                self.edges.append(edge)
                self.graph.add_edge(
                    edge.source_id,
                    edge.target_id,
                    relation=edge.relation_type,
                    weight=edge.weight
                )

            print(f"üìä Grafo cargado: {len(self.nodes)} nodos, {len(self.edges)} aristas")

        except Exception as e:
            print(f"Error cargando grafo: {e}")

    def get_statistics(self) -> dict:
        return {
            "nodes": len(self.nodes),
            "edges": len(self.edges),
            "node_types": dict(nx.get_node_attributes(self.graph, "node_type")),
            "density": nx.density(self.graph),
            "components": nx.number_weakly_connected_components(self.graph)
        }
```

## Ejemplo de Uso

```python
# Crear grafo de conocimiento
kg = KnowledgeGraphMemory()

# Agregar conocimiento sobre un usuario
kg.add_node("Usuario_Juan", "entity", {"role": "developer", "level": "senior"})
kg.add_node("Python", "concept", {"description": "Lenguaje de programaci√≥n"})
kg.add_node("Machine Learning", "concept", {"description": "Subcampo de IA"})

# Agregar relaciones
kg.add_relation("Usuario_Juan", "knows", "Python")
kg.add_relation("Usuario_Juan", "asked_about", "Machine Learning")
kg.add_relation("Python", "used_for", "Machine Learning")

# Consultas
print(kg.get_relations("Usuario_Juan"))
print(kg.find_path("Usuario_Juan", "Machine Learning"))
print(kg.query_pattern("Usuario_Juan -[knows]-> ?"))

# Razonamiento
answer = kg.reason_about("¬øQu√© relaci√≥n tiene Juan con Machine Learning?")
print(answer)

# Aprendizaje autom√°tico
kg.learn_from_text("""
TensorFlow es una biblioteca de machine learning creada por Google.
Se usa principalmente con Python y es popular para deep learning.
""")
```

## Resumen

Los **grafos de conocimiento** ofrecen memoria estructurada:

**Ventajas**:
- Relaciones expl√≠citas y tipadas
- Razonamiento transitivo
- Consultas precisas
- Explicabilidad

**Operaciones**:
- CRUD de nodos y relaciones
- B√∫squeda de caminos
- Consultas por patr√≥n
- Razonamiento con LLM

---

## Navegaci√≥n

- **Anterior**: [5.2.1 Memoria con Vector Stores](./5.2.1-memoria-vector-stores.md)
- **Siguiente**: [5.2.3 Compresi√≥n y Sumarizaci√≥n](./5.2.3-compresion-sumarizacion.md)
- **√çndice**: [README del Curso](../../README.md)
