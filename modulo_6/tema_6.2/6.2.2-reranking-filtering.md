# 6.2.2 Re-ranking y Filtering

## Objetivo de Aprendizaje

Al finalizar este subtema, serás capaz de implementar técnicas de re-ranking y filtrado para mejorar la precisión de los resultados de búsqueda en sistemas RAG usando modelos de Gemini.

## Introducción

El **re-ranking** es una segunda etapa de procesamiento que reordena los resultados iniciales usando criterios más sofisticados. Mientras que la búsqueda inicial prioriza velocidad (recall), el re-ranking prioriza precisión.

### Pipeline con Re-ranking

```
┌─────────────────────────────────────────────────────────────────┐
│                    PIPELINE DE BÚSQUEDA                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────┐                                                    │
│  │  Query  │                                                    │
│  └────┬────┘                                                    │
│       │                                                          │
│       ▼                                                          │
│  ┌──────────────────┐     ┌─────────────────────────────┐       │
│  │  STAGE 1:        │     │ Características:             │       │
│  │  Retrieval       │     │ • Rápido (ms)               │       │
│  │  (Búsqueda)      │────▶│ • Alta cobertura (recall)    │       │
│  │                  │     │ • Top 50-100 candidatos     │       │
│  └────────┬─────────┘     └─────────────────────────────┘       │
│           │                                                      │
│           ▼                                                      │
│  ┌──────────────────┐     ┌─────────────────────────────┐       │
│  │  STAGE 2:        │     │ Características:             │       │
│  │  Re-ranking      │     │ • Más lento (segundos)      │       │
│  │                  │────▶│ • Alta precisión            │       │
│  │                  │     │ • Top 5-10 finales          │       │
│  └────────┬─────────┘     └─────────────────────────────┘       │
│           │                                                      │
│           ▼                                                      │
│  ┌──────────────────┐     ┌─────────────────────────────┐       │
│  │  STAGE 3:        │     │ Características:             │       │
│  │  Filtering       │     │ • Reglas de negocio         │       │
│  │  (Opcional)      │────▶│ • Permisos/acceso           │       │
│  │                  │     │ • Relevancia temporal       │       │
│  └────────┬─────────┘     └─────────────────────────────┘       │
│           │                                                      │
│           ▼                                                      │
│     Final Results                                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## Re-ranking con Cross-Encoder

Un **Cross-Encoder** procesa el par (query, documento) juntos, permitiendo una comprensión más profunda de la relevancia.

### Implementación con Gemini

```python
"""
Re-ranking usando Gemini como Cross-Encoder
"""
import google.generativeai as genai
from dataclasses import dataclass
from typing import List, Dict, Any, Optional
import json
import re


@dataclass
class RankedResult:
    """Resultado con score de re-ranking."""
    doc_id: str
    content: str
    original_score: float
    rerank_score: float
    final_rank: int
    metadata: Dict[str, Any]


class GeminiReranker:
    """
    Re-ranker usando Gemini para evaluar relevancia query-documento.
    """

    def __init__(
        self,
        api_key: str,
        model: str = "gemini-2.0-flash"
    ):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel(model)

    def _score_single(
        self,
        query: str,
        document: str
    ) -> float:
        """
        Calcula score de relevancia para un documento.
        """
        prompt = f"""Evalúa qué tan relevante es el siguiente documento para responder la pregunta.

PREGUNTA: {query}

DOCUMENTO:
{document}

Responde SOLO con un número del 0 al 10, donde:
- 0: Completamente irrelevante
- 5: Parcialmente relevante
- 10: Perfectamente relevante y responde directamente la pregunta

SCORE:"""

        try:
            response = self.model.generate_content(prompt)
            # Extraer número de la respuesta
            score_text = response.text.strip()
            score = float(re.search(r'\d+(?:\.\d+)?', score_text).group())
            return min(max(score / 10, 0), 1)  # Normalizar a [0, 1]
        except Exception as e:
            print(f"Error scoring: {e}")
            return 0.5  # Score neutral en caso de error

    def _score_batch(
        self,
        query: str,
        documents: List[str]
    ) -> List[float]:
        """
        Calcula scores para múltiples documentos en una sola llamada.
        Más eficiente que scoring individual.
        """
        docs_text = "\n\n".join([
            f"[DOC {i+1}]\n{doc}"
            for i, doc in enumerate(documents)
        ])

        prompt = f"""Evalúa la relevancia de cada documento para responder la pregunta.

PREGUNTA: {query}

DOCUMENTOS:
{docs_text}

Para cada documento, asigna un score del 0 al 10:
- 0: Completamente irrelevante
- 5: Parcialmente relevante
- 10: Perfectamente relevante

Responde en formato JSON:
{{"scores": [score_doc1, score_doc2, ...]}}

Solo el JSON, sin explicaciones."""

        try:
            response = self.model.generate_content(prompt)
            # Parsear JSON
            json_match = re.search(r'\{.*\}', response.text, re.DOTALL)
            if json_match:
                data = json.loads(json_match.group())
                scores = data.get("scores", [])
                # Normalizar a [0, 1]
                return [min(max(s / 10, 0), 1) for s in scores]
        except Exception as e:
            print(f"Error batch scoring: {e}")

        # Fallback: scores neutrales
        return [0.5] * len(documents)

    def rerank(
        self,
        query: str,
        documents: List[Dict[str, Any]],
        top_k: int = 5,
        batch_size: int = 10
    ) -> List[RankedResult]:
        """
        Re-rankea documentos basado en relevancia con la query.

        Args:
            query: Pregunta del usuario
            documents: Lista de dicts con 'id', 'content', 'score', 'metadata'
            top_k: Número de resultados finales
            batch_size: Tamaño de batch para scoring

        Returns:
            Lista de resultados re-rankeados
        """
        # Procesar en batches
        all_scores = []

        for i in range(0, len(documents), batch_size):
            batch = documents[i:i+batch_size]
            batch_contents = [doc['content'] for doc in batch]
            scores = self._score_batch(query, batch_contents)
            all_scores.extend(scores)

        # Combinar con resultados originales
        results = []
        for i, doc in enumerate(documents):
            results.append(RankedResult(
                doc_id=doc.get('id', f'doc_{i}'),
                content=doc['content'],
                original_score=doc.get('score', 0),
                rerank_score=all_scores[i] if i < len(all_scores) else 0.5,
                final_rank=0,  # Se asignará después de ordenar
                metadata=doc.get('metadata', {})
            ))

        # Ordenar por rerank_score
        results.sort(key=lambda x: x.rerank_score, reverse=True)

        # Asignar ranks finales
        for i, result in enumerate(results[:top_k]):
            result.final_rank = i + 1

        return results[:top_k]


# Ejemplo de uso
def demo_reranker():
    reranker = GeminiReranker(api_key="TU_API_KEY")

    query = "¿Cómo configuro la autenticación de dos factores?"

    # Resultados de búsqueda inicial (simulados)
    search_results = [
        {
            "id": "doc_1",
            "content": "La autenticación de dos factores (2FA) agrega una capa extra de seguridad. Para activarla, vaya a Configuración > Seguridad > Activar 2FA.",
            "score": 0.85,
            "metadata": {"source": "manual"}
        },
        {
            "id": "doc_2",
            "content": "Los factores de autenticación pueden ser: algo que sabes (contraseña), algo que tienes (teléfono), o algo que eres (huella).",
            "score": 0.82,
            "metadata": {"source": "blog"}
        },
        {
            "id": "doc_3",
            "content": "Error de autenticación: si ve el código AUTH-001, verifique sus credenciales.",
            "score": 0.78,
            "metadata": {"source": "faq"}
        },
        {
            "id": "doc_4",
            "content": "Para configurar 2FA: 1) Descargue una app autenticadora, 2) Escanee el QR, 3) Ingrese el código.",
            "score": 0.75,
            "metadata": {"source": "tutorial"}
        },
        {
            "id": "doc_5",
            "content": "La configuración del sistema permite personalizar varios aspectos de la interfaz.",
            "score": 0.72,
            "metadata": {"source": "manual"}
        }
    ]

    print(f"Query: {query}\n")
    print("="*60)
    print("ANTES del re-ranking (por score de búsqueda):")
    print("="*60)

    for doc in search_results:
        print(f"[{doc['score']:.2f}] {doc['content'][:60]}...")

    # Aplicar re-ranking
    reranked = reranker.rerank(query, search_results, top_k=3)

    print("\n" + "="*60)
    print("DESPUÉS del re-ranking:")
    print("="*60)

    for result in reranked:
        print(f"\nRank {result.final_rank}:")
        print(f"  Original: {result.original_score:.2f} -> Rerank: {result.rerank_score:.2f}")
        print(f"  {result.content[:80]}...")


if __name__ == "__main__":
    demo_reranker()
```

## Re-ranking con Puntuación Multi-Criterio

```python
"""
Re-ranking con múltiples criterios de evaluación
"""
import google.generativeai as genai
from typing import List, Dict
import json


class MultiCriteriaReranker:
    """
    Re-ranker que evalúa múltiples dimensiones de relevancia.
    """

    def __init__(self, api_key: str):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel("gemini-2.0-flash")

        # Criterios de evaluación con pesos
        self.criteria = {
            "relevance": {
                "description": "¿Qué tan directamente responde la pregunta?",
                "weight": 0.4
            },
            "completeness": {
                "description": "¿La respuesta es completa o parcial?",
                "weight": 0.25
            },
            "accuracy": {
                "description": "¿La información parece precisa y confiable?",
                "weight": 0.2
            },
            "clarity": {
                "description": "¿La información está clara y bien explicada?",
                "weight": 0.15
            }
        }

    def _evaluate_document(
        self,
        query: str,
        document: str
    ) -> Dict[str, float]:
        """Evalúa documento en múltiples criterios."""

        criteria_text = "\n".join([
            f"- {name}: {info['description']}"
            for name, info in self.criteria.items()
        ])

        prompt = f"""Evalúa el siguiente documento para responder la pregunta.

PREGUNTA: {query}

DOCUMENTO:
{document}

Evalúa en estos criterios (0-10 cada uno):
{criteria_text}

Responde en JSON:
{{"relevance": X, "completeness": X, "accuracy": X, "clarity": X}}"""

        try:
            response = self.model.generate_content(prompt)
            json_match = re.search(r'\{.*\}', response.text, re.DOTALL)
            if json_match:
                scores = json.loads(json_match.group())
                return {k: v/10 for k, v in scores.items()}
        except Exception:
            pass

        return {k: 0.5 for k in self.criteria.keys()}

    def _calculate_weighted_score(
        self,
        criteria_scores: Dict[str, float]
    ) -> float:
        """Calcula score ponderado."""
        total = 0
        for criterion, score in criteria_scores.items():
            weight = self.criteria.get(criterion, {}).get("weight", 0)
            total += score * weight
        return total

    def rerank(
        self,
        query: str,
        documents: List[Dict],
        top_k: int = 5
    ) -> List[Dict]:
        """Re-rankea con evaluación multi-criterio."""

        results = []
        for doc in documents:
            criteria_scores = self._evaluate_document(query, doc['content'])
            weighted_score = self._calculate_weighted_score(criteria_scores)

            results.append({
                **doc,
                "criteria_scores": criteria_scores,
                "weighted_score": weighted_score
            })

        # Ordenar por score ponderado
        results.sort(key=lambda x: x["weighted_score"], reverse=True)

        return results[:top_k]


# Ejemplo
def demo_multi_criteria():
    reranker = MultiCriteriaReranker(api_key="TU_API_KEY")

    query = "¿Cuáles son las mejores prácticas para manejo de contraseñas?"

    documents = [
        {
            "id": "1",
            "content": "Use contraseñas largas y únicas para cada cuenta."
        },
        {
            "id": "2",
            "content": "Las mejores prácticas incluyen: 1) Usar al menos 12 caracteres, 2) Combinar mayúsculas, minúsculas, números y símbolos, 3) No reutilizar contraseñas, 4) Usar un gestor de contraseñas, 5) Activar 2FA cuando sea posible."
        },
        {
            "id": "3",
            "content": "La contraseña es una forma de autenticación."
        }
    ]

    results = reranker.rerank(query, documents)

    for result in results:
        print(f"\n[Score: {result['weighted_score']:.2f}]")
        print(f"  {result['content'][:80]}...")
        print(f"  Criterios: {result['criteria_scores']}")
```

## Filtrado Post-Retrieval

### Filtros por Metadata

```python
"""
Sistema de filtrado post-retrieval
"""
from dataclasses import dataclass
from typing import List, Dict, Any, Callable, Optional
from datetime import datetime, timedelta
from enum import Enum


class FilterOperator(Enum):
    """Operadores de filtro."""
    EQUALS = "eq"
    NOT_EQUALS = "ne"
    GREATER_THAN = "gt"
    LESS_THAN = "lt"
    CONTAINS = "contains"
    IN = "in"
    NOT_IN = "not_in"


@dataclass
class Filter:
    """Definición de un filtro."""
    field: str
    operator: FilterOperator
    value: Any


class PostRetrievalFilter:
    """
    Aplica filtros a resultados de búsqueda.
    """

    def __init__(self):
        self.filters: List[Filter] = []

    def add_filter(
        self,
        field: str,
        operator: FilterOperator,
        value: Any
    ) -> 'PostRetrievalFilter':
        """Agrega un filtro (fluent interface)."""
        self.filters.append(Filter(field, operator, value))
        return self

    def _evaluate_filter(
        self,
        document: Dict,
        filter: Filter
    ) -> bool:
        """Evalúa si un documento pasa un filtro."""
        # Obtener valor del campo (soporta anidados con ".")
        parts = filter.field.split(".")
        value = document
        for part in parts:
            if isinstance(value, dict):
                value = value.get(part)
            else:
                return False

        if value is None:
            return filter.operator == FilterOperator.NOT_EQUALS

        # Aplicar operador
        op = filter.operator
        if op == FilterOperator.EQUALS:
            return value == filter.value
        elif op == FilterOperator.NOT_EQUALS:
            return value != filter.value
        elif op == FilterOperator.GREATER_THAN:
            return value > filter.value
        elif op == FilterOperator.LESS_THAN:
            return value < filter.value
        elif op == FilterOperator.CONTAINS:
            return filter.value in str(value).lower()
        elif op == FilterOperator.IN:
            return value in filter.value
        elif op == FilterOperator.NOT_IN:
            return value not in filter.value

        return True

    def apply(
        self,
        documents: List[Dict]
    ) -> List[Dict]:
        """Aplica todos los filtros a los documentos."""
        filtered = []
        for doc in documents:
            passes_all = True
            for f in self.filters:
                if not self._evaluate_filter(doc, f):
                    passes_all = False
                    break
            if passes_all:
                filtered.append(doc)
        return filtered

    def clear(self):
        """Limpia todos los filtros."""
        self.filters = []


# Filtros predefinidos comunes
class CommonFilters:
    """Filtros comunes predefinidos."""

    @staticmethod
    def by_date_range(
        field: str,
        start: datetime,
        end: datetime
    ) -> PostRetrievalFilter:
        """Filtra por rango de fechas."""
        return (PostRetrievalFilter()
                .add_filter(field, FilterOperator.GREATER_THAN, start)
                .add_filter(field, FilterOperator.LESS_THAN, end))

    @staticmethod
    def by_categories(
        field: str,
        categories: List[str]
    ) -> PostRetrievalFilter:
        """Filtra por categorías permitidas."""
        return PostRetrievalFilter().add_filter(
            field, FilterOperator.IN, categories
        )

    @staticmethod
    def exclude_categories(
        field: str,
        categories: List[str]
    ) -> PostRetrievalFilter:
        """Excluye categorías."""
        return PostRetrievalFilter().add_filter(
            field, FilterOperator.NOT_IN, categories
        )

    @staticmethod
    def recent_only(
        field: str,
        days: int = 30
    ) -> PostRetrievalFilter:
        """Solo documentos recientes."""
        cutoff = datetime.now() - timedelta(days=days)
        return PostRetrievalFilter().add_filter(
            field, FilterOperator.GREATER_THAN, cutoff
        )


# Ejemplo de uso
def demo_filtering():
    # Resultados de búsqueda simulados
    results = [
        {
            "id": "1",
            "content": "Guía de Python 3.10",
            "metadata": {
                "category": "programming",
                "language": "python",
                "date": datetime(2024, 1, 15),
                "access_level": "public"
            }
        },
        {
            "id": "2",
            "content": "Manual interno de procesos",
            "metadata": {
                "category": "internal",
                "date": datetime(2023, 6, 1),
                "access_level": "internal"
            }
        },
        {
            "id": "3",
            "content": "Tutorial de JavaScript moderno",
            "metadata": {
                "category": "programming",
                "language": "javascript",
                "date": datetime(2024, 2, 20),
                "access_level": "public"
            }
        },
        {
            "id": "4",
            "content": "Documentación deprecada de API v1",
            "metadata": {
                "category": "api",
                "deprecated": True,
                "date": datetime(2022, 3, 10),
                "access_level": "public"
            }
        }
    ]

    # Filtro 1: Solo contenido público de programación
    filter1 = (PostRetrievalFilter()
               .add_filter("metadata.category", FilterOperator.EQUALS, "programming")
               .add_filter("metadata.access_level", FilterOperator.EQUALS, "public"))

    print("Filtro: Programación + Público")
    for doc in filter1.apply(results):
        print(f"  - {doc['content']}")

    # Filtro 2: Excluir deprecados y contenido antiguo
    from datetime import datetime
    filter2 = (PostRetrievalFilter()
               .add_filter("metadata.deprecated", FilterOperator.NOT_EQUALS, True)
               .add_filter("metadata.date", FilterOperator.GREATER_THAN, datetime(2023, 1, 1)))

    print("\nFiltro: No deprecado + Después de 2023")
    for doc in filter2.apply(results):
        print(f"  - {doc['content']}")


if __name__ == "__main__":
    demo_filtering()
```

### Filtrado por Permisos de Usuario

```python
"""
Filtrado basado en permisos de usuario
"""
from typing import List, Dict, Set


class PermissionBasedFilter:
    """
    Filtra resultados basados en permisos del usuario.
    """

    def __init__(self):
        # Jerarquía de permisos
        self.permission_hierarchy = {
            "admin": {"admin", "manager", "employee", "public"},
            "manager": {"manager", "employee", "public"},
            "employee": {"employee", "public"},
            "public": {"public"}
        }

    def get_accessible_levels(self, user_role: str) -> Set[str]:
        """Obtiene niveles de acceso para un rol."""
        return self.permission_hierarchy.get(user_role, {"public"})

    def filter_by_permissions(
        self,
        documents: List[Dict],
        user_role: str,
        access_field: str = "metadata.access_level"
    ) -> List[Dict]:
        """Filtra documentos según permisos del usuario."""
        accessible = self.get_accessible_levels(user_role)

        filtered = []
        for doc in documents:
            # Obtener nivel de acceso del documento
            parts = access_field.split(".")
            value = doc
            for part in parts:
                value = value.get(part, {}) if isinstance(value, dict) else None

            if value in accessible:
                filtered.append(doc)

        return filtered


class DepartmentFilter:
    """
    Filtra por departamento del usuario.
    """

    def __init__(self):
        # Mapeo de departamentos a categorías permitidas
        self.department_access = {
            "engineering": ["tech", "general", "hr"],
            "sales": ["sales", "marketing", "general"],
            "hr": ["hr", "general"],
            "management": ["tech", "sales", "marketing", "hr", "finance", "general"]
        }

    def filter_by_department(
        self,
        documents: List[Dict],
        user_department: str,
        category_field: str = "metadata.category"
    ) -> List[Dict]:
        """Filtra documentos según departamento."""
        allowed = self.department_access.get(user_department, ["general"])

        return [
            doc for doc in documents
            if doc.get("metadata", {}).get("category", "general") in allowed
        ]


# Ejemplo de uso combinado
def demo_permission_filtering():
    perm_filter = PermissionBasedFilter()
    dept_filter = DepartmentFilter()

    documents = [
        {"id": "1", "content": "Presupuesto Q4", "metadata": {"access_level": "manager", "category": "finance"}},
        {"id": "2", "content": "Manual de producto", "metadata": {"access_level": "public", "category": "general"}},
        {"id": "3", "content": "Nómina empleados", "metadata": {"access_level": "admin", "category": "hr"}},
        {"id": "4", "content": "Guía de API", "metadata": {"access_level": "employee", "category": "tech"}},
        {"id": "5", "content": "Estrategia ventas", "metadata": {"access_level": "manager", "category": "sales"}}
    ]

    # Usuario: empleado de engineering
    user_role = "employee"
    user_dept = "engineering"

    # Aplicar filtros en secuencia
    by_permission = perm_filter.filter_by_permissions(documents, user_role)
    by_department = dept_filter.filter_by_department(by_permission, user_dept)

    print(f"Usuario: {user_role} de {user_dept}")
    print(f"Documentos originales: {len(documents)}")
    print(f"Después de permisos: {len(by_permission)}")
    print(f"Después de departamento: {len(by_department)}")

    print("\nDocumentos accesibles:")
    for doc in by_department:
        print(f"  - {doc['content']}")
```

## Pipeline Completo: Retrieval + Rerank + Filter

```python
"""
Pipeline RAG completo con reranking y filtrado
"""
import google.generativeai as genai
from typing import List, Dict, Any, Optional
from dataclasses import dataclass


@dataclass
class RAGResponse:
    """Respuesta del pipeline RAG."""
    answer: str
    sources: List[Dict]
    stages: Dict[str, int]  # Conteo por etapa


class AdvancedRAGPipeline:
    """
    Pipeline RAG con retrieval, reranking y filtrado.
    """

    def __init__(
        self,
        api_key: str,
        retrieval_k: int = 20,
        rerank_k: int = 5,
        enable_rerank: bool = True,
        enable_filter: bool = True
    ):
        genai.configure(api_key=api_key)

        self.retrieval_k = retrieval_k
        self.rerank_k = rerank_k
        self.enable_rerank = enable_rerank
        self.enable_filter = enable_filter

        # Componentes
        self.reranker = GeminiReranker(api_key)
        self.filter = PostRetrievalFilter()

        # Generador
        self.generation_model = genai.GenerativeModel("gemini-2.0-flash")

        # Mock vector store (reemplazar con implementación real)
        self.documents: List[Dict] = []

    def add_documents(self, documents: List[Dict]):
        """Agrega documentos al store."""
        self.documents.extend(documents)

    def _retrieve(
        self,
        query: str,
        k: int
    ) -> List[Dict]:
        """
        Etapa 1: Retrieval inicial.
        Reemplazar con búsqueda vectorial real.
        """
        # Simulación: retorna documentos con scores ficticios
        results = []
        for i, doc in enumerate(self.documents[:k]):
            results.append({
                **doc,
                "score": 0.9 - (i * 0.05)  # Score decreciente
            })
        return results

    def _rerank(
        self,
        query: str,
        documents: List[Dict],
        k: int
    ) -> List[Dict]:
        """Etapa 2: Re-ranking."""
        if not self.enable_rerank:
            return documents[:k]

        reranked = self.reranker.rerank(query, documents, top_k=k)

        return [
            {
                "id": r.doc_id,
                "content": r.content,
                "score": r.rerank_score,
                "metadata": r.metadata
            }
            for r in reranked
        ]

    def _filter(
        self,
        documents: List[Dict],
        user_context: Dict = None
    ) -> List[Dict]:
        """Etapa 3: Filtrado."""
        if not self.enable_filter or not user_context:
            return documents

        # Aplicar filtros según contexto del usuario
        filtered = documents

        # Filtro por permisos
        if "role" in user_context:
            perm_filter = PermissionBasedFilter()
            filtered = perm_filter.filter_by_permissions(
                filtered,
                user_context["role"]
            )

        # Filtros adicionales
        if "filters" in user_context:
            custom_filter = PostRetrievalFilter()
            for f in user_context["filters"]:
                custom_filter.add_filter(
                    f["field"],
                    FilterOperator(f["operator"]),
                    f["value"]
                )
            filtered = custom_filter.apply(filtered)

        return filtered

    def _generate(
        self,
        query: str,
        context_docs: List[Dict]
    ) -> str:
        """Genera respuesta usando contexto."""
        context = "\n\n".join([
            f"[Fuente {i+1}]\n{doc['content']}"
            for i, doc in enumerate(context_docs)
        ])

        prompt = f"""Basándote en el siguiente contexto, responde la pregunta.

CONTEXTO:
{context}

PREGUNTA: {query}

RESPUESTA:"""

        response = self.generation_model.generate_content(prompt)
        return response.text

    def query(
        self,
        query: str,
        user_context: Optional[Dict] = None
    ) -> RAGResponse:
        """
        Ejecuta el pipeline completo.

        Args:
            query: Pregunta del usuario
            user_context: Contexto del usuario (role, department, filters)

        Returns:
            RAGResponse con respuesta y fuentes
        """
        stages = {}

        # Stage 1: Retrieval
        retrieved = self._retrieve(query, self.retrieval_k)
        stages["retrieved"] = len(retrieved)

        # Stage 2: Re-ranking
        reranked = self._rerank(query, retrieved, self.rerank_k * 2)
        stages["reranked"] = len(reranked)

        # Stage 3: Filtering
        filtered = self._filter(reranked, user_context)
        stages["filtered"] = len(filtered)

        # Tomar top-k final
        final_docs = filtered[:self.rerank_k]
        stages["final"] = len(final_docs)

        # Generar respuesta
        if final_docs:
            answer = self._generate(query, final_docs)
        else:
            answer = "No encontré información relevante que puedas acceder."

        return RAGResponse(
            answer=answer,
            sources=[
                {"id": d["id"], "content": d["content"][:100], "score": d.get("score", 0)}
                for d in final_docs
            ],
            stages=stages
        )


# Ejemplo completo
def demo_advanced_pipeline():
    pipeline = AdvancedRAGPipeline(
        api_key="TU_API_KEY",
        retrieval_k=20,
        rerank_k=5
    )

    # Agregar documentos
    documents = [
        {
            "id": "1",
            "content": "Guía de configuración de 2FA paso a paso con capturas de pantalla.",
            "metadata": {"category": "security", "access_level": "public"}
        },
        {
            "id": "2",
            "content": "La autenticación de dos factores mejora la seguridad de cuentas.",
            "metadata": {"category": "security", "access_level": "public"}
        },
        {
            "id": "3",
            "content": "Credenciales de API de producción: NO COMPARTIR",
            "metadata": {"category": "security", "access_level": "admin"}
        },
        {
            "id": "4",
            "content": "Resumen de políticas de contraseñas corporativas.",
            "metadata": {"category": "hr", "access_level": "employee"}
        },
        {
            "id": "5",
            "content": "Para activar 2FA: Configuración > Seguridad > Autenticación en dos pasos",
            "metadata": {"category": "security", "access_level": "public"}
        }
    ]

    pipeline.add_documents(documents)

    # Query como usuario employee
    query = "¿Cómo activo la autenticación de dos factores?"

    user_context = {
        "role": "employee",
        "department": "engineering",
        "filters": [
            {"field": "metadata.category", "operator": "eq", "value": "security"}
        ]
    }

    print(f"Query: {query}")
    print(f"Usuario: {user_context['role']}\n")

    response = pipeline.query(query, user_context)

    print("="*60)
    print("RESPUESTA:")
    print("="*60)
    print(response.answer)

    print("\n" + "="*60)
    print("FUENTES:")
    print("="*60)
    for source in response.sources:
        print(f"  [{source['score']:.2f}] {source['content']}...")

    print("\n" + "="*60)
    print("PIPELINE STAGES:")
    print("="*60)
    for stage, count in response.stages.items():
        print(f"  {stage}: {count} documentos")


if __name__ == "__main__":
    demo_advanced_pipeline()
```

## Ejercicio Práctico

```python
"""
EJERCICIO: Sistema de Soporte con Re-ranking Contextual

Implementa un sistema de soporte que use re-ranking basado
en el contexto del usuario (producto que usa, historial, etc.).
"""


class ContextualSupportRAG:
    """
    Sistema de soporte con re-ranking contextual.

    TODO: Implementar las funcionalidades.
    """

    def __init__(self, api_key: str):
        """
        TODO:
        1. Inicializar componentes de RAG
        2. Configurar reranker con criterios específicos de soporte
        """
        pass

    def add_support_articles(
        self,
        articles: List[Dict]
    ):
        """
        Agrega artículos de soporte.

        articles = [
            {
                "id": "...",
                "title": "...",
                "content": "...",
                "product": "ProductA",
                "difficulty": "beginner|intermediate|advanced",
                "tags": ["setup", "troubleshooting", ...]
            }
        ]

        TODO: Indexar artículos
        """
        pass

    def set_user_context(
        self,
        user_id: str,
        context: Dict
    ):
        """
        Establece contexto del usuario.

        context = {
            "product": "ProductA",
            "experience_level": "beginner",
            "previous_issues": ["setup", "login"],
            "language": "es"
        }

        TODO: Almacenar contexto
        """
        pass

    def contextual_rerank(
        self,
        query: str,
        documents: List[Dict],
        user_context: Dict
    ) -> List[Dict]:
        """
        Re-rankea considerando contexto del usuario.

        TODO:
        1. Boost para documentos del mismo producto
        2. Boost para dificultad apropiada
        3. Boost para temas relacionados a historial
        4. Usar Gemini para relevancia semántica
        """
        pass

    def answer_support_query(
        self,
        user_id: str,
        query: str
    ) -> Dict:
        """
        Responde consulta de soporte con contexto.

        TODO:
        1. Obtener contexto del usuario
        2. Buscar artículos relevantes
        3. Aplicar re-ranking contextual
        4. Generar respuesta personalizada
        5. Actualizar historial del usuario
        """
        pass


def test_contextual_support():
    """Prueba el sistema de soporte contextual."""

    # TODO: Implementar prueba
    # rag = ContextualSupportRAG(api_key="TU_KEY")
    #
    # # Agregar artículos
    # articles = [...]
    # rag.add_support_articles(articles)
    #
    # # Establecer contexto
    # rag.set_user_context("user_1", {
    #     "product": "CloudApp",
    #     "experience_level": "beginner",
    #     "previous_issues": ["installation"]
    # })
    #
    # # Query
    # result = rag.answer_support_query("user_1", "no puedo conectarme")
    # print(result)


if __name__ == "__main__":
    test_contextual_support()
```

## Resumen

| Técnica | Cuándo Usar | Impacto |
|---------|-------------|---------|
| Re-ranking básico | Siempre | +20-30% precisión |
| Multi-criterio | Dominios especializados | +15-25% relevancia |
| Filtrado por permisos | Aplicaciones empresariales | Seguridad |
| Filtrado temporal | Contenido con fecha | Actualidad |
| Re-ranking contextual | UX personalizada | +30-40% satisfacción |

### Checklist de Implementación

- [ ] Retrieval inicial con alta cobertura (top-50+)
- [ ] Re-ranker con Gemini para precisión
- [ ] Filtros de permisos antes de mostrar resultados
- [ ] Filtros de metadata para relevancia contextual
- [ ] Métricas de evaluación por etapa
- [ ] Logging para debugging

## Siguiente Paso

En el próximo subtema exploraremos **Agentic RAG: Retrieval Iterativo**, donde los agentes refinan sus búsquedas de forma autónoma.
