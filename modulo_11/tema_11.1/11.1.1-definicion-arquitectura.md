# 11.1.1 Definición de Arquitectura

## Objetivo de Aprendizaje

Al finalizar este subtema, serás capaz de diseñar la arquitectura completa de un sistema multi-agente de producción, tomando decisiones fundamentadas sobre componentes, comunicación y despliegue.

## Introducción

El proyecto integrador consolida todo lo aprendido en el curso. Construirás un **Asistente de Investigación Multi-Agente** — un sistema donde múltiples agentes colaboran para investigar temas, analizar información, generar reportes y mantener conocimiento actualizado.

```
┌─────────────────────────────────────────────────────────────────┐
│         ASISTENTE DE INVESTIGACIÓN MULTI-AGENTE                │
│              (PROYECTO INTEGRADOR)                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                     ┌──────────────┐                            │
│                     │   USUARIO    │                            │
│                     └──────┬───────┘                            │
│                            │                                    │
│                            ▼                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              ORCHESTRATOR AGENT                          │   │
│  │  • Recibe solicitudes    • Planifica investigación      │   │
│  │  • Coordina agentes      • Consolida resultados        │   │
│  └────────┬──────────┬──────────┬──────────┬───────────────┘   │
│           │          │          │          │                    │
│     ┌─────▼────┐ ┌───▼────┐ ┌──▼─────┐ ┌─▼────────┐          │
│     │RESEARCHER│ │ANALYST │ │ WRITER │ │ CRITIC   │          │
│     │ AGENT    │ │ AGENT  │ │ AGENT  │ │ AGENT    │          │
│     │          │ │        │ │        │ │          │          │
│     │Search &  │ │Data    │ │Report  │ │Quality   │          │
│     │Retrieve  │ │Analysis│ │Writing │ │Review    │          │
│     └──────────┘ └────────┘ └────────┘ └──────────┘          │
│           │          │          │          │                    │
│  ┌────────┴──────────┴──────────┴──────────┴───────────────┐   │
│  │                  SHARED INFRASTRUCTURE                   │   │
│  │  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐        │   │
│  │  │ Vector │  │ Redis  │  │Postgres│  │  Pub/  │        │   │
│  │  │   DB   │  │ Cache  │  │  State │  │  Sub   │        │   │
│  │  └────────┘  └────────┘  └────────┘  └────────┘        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Requisitos del Proyecto

### Requisitos Funcionales

```python
"""
Requisitos funcionales del Asistente de Investigación Multi-Agente
"""

FUNCTIONAL_REQUIREMENTS = {
    "FR-001": {
        "title": "Investigación por Tema",
        "description": "El usuario puede solicitar investigación sobre cualquier tema",
        "acceptance_criteria": [
            "El sistema acepta queries en lenguaje natural",
            "Genera plan de investigación automáticamente",
            "Busca en múltiples fuentes de información",
            "Produce reporte estructurado con fuentes citadas"
        ],
        "priority": "HIGH"
    },
    "FR-002": {
        "title": "Análisis de Datos",
        "description": "Los datos encontrados se analizan cuantitativamente",
        "acceptance_criteria": [
            "Extrae datos numéricos de fuentes",
            "Genera estadísticas y tendencias",
            "Crea visualizaciones cuando aplique",
            "Identifica patrones y outliers"
        ],
        "priority": "HIGH"
    },
    "FR-003": {
        "title": "Generación de Reportes",
        "description": "Genera reportes profesionales",
        "acceptance_criteria": [
            "Formato markdown estructurado",
            "Executive summary",
            "Secciones con profundidad configurable",
            "Referencias y bibliografía"
        ],
        "priority": "HIGH"
    },
    "FR-004": {
        "title": "Revisión de Calidad",
        "description": "El reporte se revisa antes de entregarse",
        "acceptance_criteria": [
            "Verificación de coherencia",
            "Validación de fuentes",
            "Detección de sesgos",
            "Sugerencias de mejora"
        ],
        "priority": "MEDIUM"
    },
    "FR-005": {
        "title": "Memoria de Sesión",
        "description": "El sistema recuerda investigaciones previas",
        "acceptance_criteria": [
            "Memoria a corto plazo por sesión",
            "Memoria a largo plazo entre sesiones",
            "Capacidad de referir investigaciones anteriores",
            "Búsqueda semántica en conocimiento previo"
        ],
        "priority": "MEDIUM"
    },
    "FR-006": {
        "title": "Interfaz de API",
        "description": "API REST para interacción programática",
        "acceptance_criteria": [
            "Endpoints para crear investigaciones",
            "Consulta de estado y progreso",
            "Descarga de reportes",
            "Webhook para notificaciones"
        ],
        "priority": "HIGH"
    }
}
```

### Requisitos No Funcionales

```python
NON_FUNCTIONAL_REQUIREMENTS = {
    "NFR-001": {
        "title": "Performance",
        "specs": {
            "latency_p95": "< 30s para chat, < 5min para investigación completa",
            "throughput": "> 10 investigaciones concurrentes",
            "availability": "99.5%"
        }
    },
    "NFR-002": {
        "title": "Escalabilidad",
        "specs": {
            "horizontal_scaling": "Hasta 20 instancias",
            "token_budget": "< 100K tokens por investigación",
            "storage": "< 10MB por investigación"
        }
    },
    "NFR-003": {
        "title": "Seguridad",
        "specs": {
            "authentication": "API Keys + JWT",
            "authorization": "RBAC con 3 roles",
            "data_encryption": "TLS en tránsito",
            "audit": "Logging completo de acciones"
        }
    },
    "NFR-004": {
        "title": "Observabilidad",
        "specs": {
            "logging": "Structured JSON logging",
            "metrics": "Prometheus + Grafana",
            "tracing": "OpenTelemetry + Jaeger",
            "alerting": "PagerDuty para P1/P2"
        }
    },
    "NFR-005": {
        "title": "Costos",
        "specs": {
            "target_cost_per_investigation": "< $0.50",
            "monthly_budget": "< $500 para 1000 investigaciones/día",
            "optimization": "Cache, model routing, token budgeting"
        }
    }
}
```

## Decisiones de Arquitectura

### Architecture Decision Records (ADR)

```python
from dataclasses import dataclass, field
from typing import List

@dataclass
class ADR:
    """Architecture Decision Record"""
    id: str
    title: str
    status: str  # "accepted", "proposed", "deprecated"
    context: str
    decision: str
    consequences: List[str]
    alternatives_considered: List[str] = field(default_factory=list)

# ADRs del proyecto
ADRS = [
    ADR(
        id="ADR-001",
        title="Modelo base: Gemini 2.0 Flash",
        status="accepted",
        context="Necesitamos elegir el modelo LLM principal para los agentes.",
        decision="Usar Gemini 2.0 Flash como modelo principal, con opción de "
                 "escalar a Gemini Pro para tareas complejas de análisis.",
        consequences=[
            "Costos bajos por token",
            "Baja latencia para interacciones de chat",
            "Function calling nativo disponible",
            "Puede requerir Pro para razonamiento complejo"
        ],
        alternatives_considered=[
            "Solo Gemini Pro: Mayor calidad pero 10x más costoso",
            "GPT-4: No alineado con el objetivo del curso",
            "Open source: Menor calidad, mayor complejidad operativa"
        ]
    ),
    ADR(
        id="ADR-002",
        title="Patrón de orquestación: Supervisor",
        status="accepted",
        context="Definir cómo se coordinan los agentes.",
        decision="Usar patrón Supervisor donde el Orchestrator Agent "
                 "planifica y delega a agentes especializados.",
        consequences=[
            "Control centralizado del flujo",
            "Fácil de debuggear y monitorear",
            "Single point of failure en orquestador",
            "Escalable añadiendo más agentes especializados"
        ],
        alternatives_considered=[
            "Peer-to-peer: Más resiliente pero difícil de debuggear",
            "Pipeline fijo: Simple pero inflexible",
            "Debate/Consensus: Mejor calidad pero más costoso"
        ]
    ),
    ADR(
        id="ADR-003",
        title="Comunicación: Message Passing con Redis",
        status="accepted",
        context="Definir cómo se comunican los agentes entre sí.",
        decision="Message passing a través de Redis Pub/Sub con schema "
                 "estandarizado de mensajes.",
        consequences=[
            "Desacoplamiento entre agentes",
            "Fácil de escalar horizontalmente",
            "Persistencia de mensajes configurable",
            "Latencia adicional mínima (~1ms)"
        ]
    ),
    ADR(
        id="ADR-004",
        title="Memoria: Híbrida (Redis + ChromaDB + PostgreSQL)",
        status="accepted",
        context="El sistema necesita múltiples tipos de memoria.",
        decision="Redis para memoria de trabajo, ChromaDB para memoria "
                 "semántica (RAG), PostgreSQL para memoria persistente.",
        consequences=[
            "Cada tipo de memoria optimizado para su uso",
            "Tres sistemas a mantener",
            "Búsqueda semántica eficiente",
            "Durabilidad de datos garantizada"
        ]
    ),
    ADR(
        id="ADR-005",
        title="Despliegue: Docker Compose → Kubernetes",
        status="accepted",
        context="Elegir estrategia de despliegue.",
        decision="Desarrollo local con Docker Compose, producción con "
                 "Kubernetes. CI/CD con GitHub Actions.",
        consequences=[
            "Desarrollo local rápido",
            "Producción escalable y resiliente",
            "Requiere conocimiento de K8s para producción",
            "CI/CD automatizado desde día 1"
        ]
    ),
]

def print_adrs():
    """Imprime ADRs del proyecto"""
    for adr in ADRS:
        print(f"\n{'='*60}")
        print(f"[{adr.id}] {adr.title}")
        print(f"Status: {adr.status}")
        print(f"\nContexto: {adr.context}")
        print(f"\nDecisión: {adr.decision}")
        print(f"\nConsecuencias:")
        for c in adr.consequences:
            print(f"  • {c}")
        if adr.alternatives_considered:
            print(f"\nAlternativas consideradas:")
            for a in adr.alternatives_considered:
                print(f"  - {a}")
```

## Diagrama de Componentes

```python
"""
Estructura de directorios del proyecto
"""

PROJECT_STRUCTURE = """
research-agent/
├── src/
│   ├── __init__.py
│   ├── agents/                    # Agentes del sistema
│   │   ├── __init__.py
│   │   ├── base.py               # BaseAgent abstracto
│   │   ├── orchestrator.py       # Agente orquestador
│   │   ├── researcher.py         # Agente investigador
│   │   ├── analyst.py            # Agente analista
│   │   ├── writer.py             # Agente escritor
│   │   └── critic.py             # Agente crítico
│   ├── tools/                    # Herramientas de los agentes
│   │   ├── __init__.py
│   │   ├── search.py             # Búsqueda web
│   │   ├── scraper.py            # Web scraping
│   │   ├── calculator.py         # Cálculos y estadísticas
│   │   ├── memory_tools.py       # Operaciones de memoria
│   │   └── file_tools.py         # Operaciones con archivos
│   ├── memory/                   # Sistema de memoria
│   │   ├── __init__.py
│   │   ├── working.py            # Memoria de trabajo (Redis)
│   │   ├── semantic.py           # Memoria semántica (ChromaDB)
│   │   ├── persistent.py         # Memoria persistente (PostgreSQL)
│   │   └── manager.py            # Gestor unificado
│   ├── communication/            # Comunicación inter-agente
│   │   ├── __init__.py
│   │   ├── messages.py           # Schemas de mensajes
│   │   ├── broker.py             # Message broker
│   │   └── protocols.py          # Protocolos de comunicación
│   ├── api/                      # API REST
│   │   ├── __init__.py
│   │   ├── main.py               # FastAPI app
│   │   ├── routes/
│   │   │   ├── research.py       # Endpoints de investigación
│   │   │   ├── chat.py           # Endpoints de chat
│   │   │   ├── reports.py        # Endpoints de reportes
│   │   │   └── admin.py          # Endpoints admin
│   │   ├── middleware/
│   │   │   ├── auth.py           # Autenticación
│   │   │   ├── rate_limit.py     # Rate limiting
│   │   │   └── logging.py        # Request logging
│   │   └── schemas.py            # Pydantic models
│   ├── config/                   # Configuración
│   │   ├── __init__.py
│   │   └── settings.py           # Settings con pydantic
│   └── observability/            # Monitoreo
│       ├── __init__.py
│       ├── metrics.py            # Prometheus metrics
│       ├── tracing.py            # OpenTelemetry tracing
│       └── logging.py            # Structured logging
├── tests/                        # Tests
│   ├── unit/
│   │   ├── test_agents/
│   │   ├── test_tools/
│   │   └── test_memory/
│   ├── integration/
│   │   ├── test_flows/
│   │   └── test_api/
│   └── adversarial/
│       └── test_security/
├── k8s/                          # Manifiestos Kubernetes
│   ├── base/
│   └── overlays/
├── docker/
│   ├── Dockerfile
│   ├── Dockerfile.dev
│   └── docker-compose.yml
├── docs/                         # Documentación
│   ├── architecture.md
│   ├── api.md
│   └── runbooks/
├── scripts/
│   ├── setup.sh
│   ├── deploy.sh
│   └── seed_data.py
├── requirements.txt
├── requirements-dev.txt
├── pyproject.toml
├── .env.example
└── README.md
"""

print(PROJECT_STRUCTURE)
```

## Flujo Principal

```python
"""
Flujo de una investigación completa
"""

INVESTIGATION_FLOW = """
1. RECEPCIÓN
   Usuario envía query → API recibe → Valida → Crea tarea

2. PLANIFICACIÓN (Orchestrator Agent)
   Analiza query → Define subtemas → Asigna a agentes → Establece orden

3. INVESTIGACIÓN (Researcher Agent)
   Para cada subtema:
   - Busca en web (search tool)
   - Extrae contenido relevante (scraper tool)
   - Almacena en memoria semántica (memory tool)
   - Verifica calidad de fuentes

4. ANÁLISIS (Analyst Agent)
   - Revisa material recopilado
   - Extrae datos cuantitativos
   - Identifica patrones y tendencias
   - Genera insights

5. REDACCIÓN (Writer Agent)
   - Estructura el reporte
   - Escribe secciones
   - Integra análisis y datos
   - Añade referencias

6. REVISIÓN (Critic Agent)
   - Revisa coherencia
   - Verifica afirmaciones
   - Detecta sesgos
   - Sugiere mejoras

7. ITERACIÓN (Orchestrator)
   Si calidad < umbral:
   - Identifica debilidades
   - Solicita mejoras específicas
   - Reenvía a agentes correspondientes

8. ENTREGA
   - Formato final del reporte
   - Almacena en memoria persistente
   - Notifica al usuario
   - Registra métricas
"""

print(INVESTIGATION_FLOW)
```

## Ejercicios Prácticos

### Ejercicio 1: Personaliza la Arquitectura
Adapta el diseño a tu caso de uso:
- Identifica qué agentes necesitas
- Define sus responsabilidades
- Dibuja el diagrama de comunicación

### Ejercicio 2: Evalúa Trade-offs
Para cada ADR, evalúa:
- ¿La decisión es correcta para tu escala?
- ¿Qué cambiarías para 10x más tráfico?
- ¿Qué cambiarías con presupuesto limitado?

### Ejercicio 3: Risk Analysis
Identifica riesgos:
- ¿Qué pasa si Gemini API está caído?
- ¿Qué pasa si un agente se queda en loop?
- ¿Cómo manejas datos sensibles?

## Resumen

| Componente | Tecnología | Responsabilidad |
|------------|-----------|-----------------|
| Orchestrator | Gemini Flash | Planificación y coordinación |
| Researcher | Gemini Flash + Tools | Búsqueda y recopilación |
| Analyst | Gemini Pro | Análisis profundo |
| Writer | Gemini Flash | Generación de reportes |
| Critic | Gemini Flash | Control de calidad |
| Message Broker | Redis Pub/Sub | Comunicación inter-agente |
| Vector Store | ChromaDB | Memoria semántica |
| State Store | PostgreSQL | Persistencia |

---

**Siguiente:** [11.1.2 Especificación de Agentes](./11.1.2-especificacion-agentes.md)
