# 11.3.2 Demo y Presentación

## Objetivo de Aprendizaje

Al finalizar este subtema, habrás preparado una demo funcional del proyecto y una presentación técnica que muestre el sistema en acción con métricas reales.

## Introducción

La demo transforma código en experiencia. Prepararemos un entorno de demostración controlado, un script de presentación con escenarios predefinidos, y visualizaciones en tiempo real del comportamiento multi-agente.

```
Flujo de la Demo
────────────────

  Presentador          Sistema              Audiencia
      │                   │                     │
      │  1. Introduce     │                     │
      │   tema ──────────►│                     │
      │                   │  2. Muestra          │
      │                   │   arquitectura ────►│
      │  3. Inicia        │                     │
      │   investigación──►│                     │
      │                   │  4. Agentes          │
      │                   │   trabajan ────────►│
      │                   │   (tiempo real)      │
      │  5. Muestra       │                     │
      │   métricas ──────►│                     │
      │                   │  6. Resultado        │
      │                   │   final ───────────►│
      │  7. Q&A           │                     │
      │◄──────────────────┼─────────────────────│
```

## Entorno de Demo

```python
# scripts/setup_demo.py
"""Prepara entorno controlado para la demo"""

import asyncio
import json
import logging
from pathlib import Path
from typing import Dict, Any, List

logger = logging.getLogger(__name__)


class DemoEnvironment:
    """Gestiona el entorno de demostración"""

    def __init__(self, config_path: str = "demo/config.json"):
        self.config = self._load_config(config_path)
        self.scenarios: List[Dict[str, Any]] = []
        self._pre_cached_results: Dict[str, Any] = {}

    def _load_config(self, path: str) -> Dict:
        """Carga configuración de demo"""
        config_file = Path(path)
        if config_file.exists():
            return json.loads(config_file.read_text())

        # Config por defecto
        return {
            "api_url": "http://localhost:8080",
            "timeout_seconds": 120,
            "use_cache": True,
            "show_agent_logs": True,
            "scenarios": [
                {
                    "name": "quick_research",
                    "topic": "Beneficios del open source en educación",
                    "depth": "quick",
                    "description": "Investigación rápida (~2 min)"
                },
                {
                    "name": "standard_research",
                    "topic": "Inteligencia Artificial en diagnóstico médico",
                    "depth": "standard",
                    "description": "Investigación estándar (~5 min)"
                },
                {
                    "name": "deep_research",
                    "topic": "Impacto del cambio climático en agricultura",
                    "depth": "deep",
                    "description": "Investigación profunda (~10 min)"
                }
            ]
        }

    async def pre_warm(self):
        """Pre-calienta el sistema antes de la demo"""
        import httpx

        async with httpx.AsyncClient(
            base_url=self.config["api_url"],
            timeout=10
        ) as client:
            # Verificar salud
            response = await client.get("/health")
            assert response.status_code == 200, "API no disponible"
            logger.info("API health check: OK")

            # Warm-up con request simple
            response = await client.post(
                "/api/v1/chat",
                json={"message": "Hola, ¿estás listo?"}
            )
            assert response.status_code == 200, "Chat endpoint falló"
            logger.info("Chat warm-up: OK")

        logger.info("Demo environment pre-warmed successfully")

    async def run_scenario(self, scenario_name: str) -> Dict[str, Any]:
        """Ejecuta un escenario de demo"""
        import httpx
        import time

        scenario = next(
            s for s in self.config["scenarios"]
            if s["name"] == scenario_name
        )

        # Verificar caché
        if self.config["use_cache"] and scenario_name in self._pre_cached_results:
            logger.info(f"Using cached result for {scenario_name}")
            return self._pre_cached_results[scenario_name]

        start_time = time.time()

        async with httpx.AsyncClient(
            base_url=self.config["api_url"],
            timeout=self.config["timeout_seconds"]
        ) as client:
            # Iniciar investigación
            response = await client.post(
                "/api/v1/research",
                json={
                    "topic": scenario["topic"],
                    "depth": scenario["depth"],
                    "max_subtopics": 3
                }
            )

            data = response.json()
            research_id = data["research_id"]

            # Polling con progreso
            while True:
                status_resp = await client.get(
                    f"/api/v1/research/{research_id}"
                )
                status = status_resp.json()

                if status["status"] in ["completed", "failed"]:
                    break

                await asyncio.sleep(2)

        elapsed = time.time() - start_time

        result = {
            "scenario": scenario_name,
            "topic": scenario["topic"],
            "status": status["status"],
            "duration_seconds": round(elapsed, 1),
            "result": status.get("result"),
        }

        # Cachear resultado
        self._pre_cached_results[scenario_name] = result

        return result


class DemoPresenter:
    """Controla la presentación de la demo"""

    def __init__(self, env: DemoEnvironment):
        self.env = env
        self.current_slide = 0
        self.slides = self._build_slides()

    def _build_slides(self) -> List[Dict[str, Any]]:
        """Construye la secuencia de slides"""
        return [
            {
                "title": "Research Agent: Sistema Multi-Agente",
                "type": "intro",
                "content": (
                    "Sistema de investigación automatizada\n"
                    "construido con Google Gemini 2.0\n\n"
                    "5 agentes especializados\n"
                    "Memoria semántica persistente\n"
                    "API REST con observabilidad completa"
                ),
                "duration": 60
            },
            {
                "title": "Arquitectura del Sistema",
                "type": "diagram",
                "content": "architecture_diagram",
                "duration": 120
            },
            {
                "title": "Demo en Vivo: Investigación Rápida",
                "type": "live_demo",
                "scenario": "quick_research",
                "duration": 180
            },
            {
                "title": "Métricas y Observabilidad",
                "type": "metrics",
                "content": "grafana_dashboard",
                "duration": 90
            },
            {
                "title": "Testing y Calidad",
                "type": "code",
                "content": "test_results",
                "duration": 60
            },
            {
                "title": "Lecciones Aprendidas",
                "type": "text",
                "content": "lessons_learned",
                "duration": 90
            },
            {
                "title": "Preguntas",
                "type": "qa",
                "duration": 300
            }
        ]

    def get_current_slide(self) -> Dict[str, Any]:
        """Obtiene el slide actual"""
        return self.slides[self.current_slide]

    def next_slide(self) -> Dict[str, Any]:
        """Avanza al siguiente slide"""
        if self.current_slide < len(self.slides) - 1:
            self.current_slide += 1
        return self.get_current_slide()

    def prev_slide(self) -> Dict[str, Any]:
        """Retrocede al slide anterior"""
        if self.current_slide > 0:
            self.current_slide -= 1
        return self.get_current_slide()
```

## Dashboard de Demo en Tiempo Real

```python
# scripts/demo_dashboard.py
"""Dashboard en terminal para la demo"""

import asyncio
import time
from typing import Dict, Optional


class TerminalDashboard:
    """Dashboard en terminal que muestra actividad de agentes"""

    def __init__(self):
        self.agent_status: Dict[str, str] = {
            "Orchestrator": "idle",
            "Researcher": "idle",
            "Analyst": "idle",
            "Writer": "idle",
            "Critic": "idle"
        }
        self.events: list = []
        self.metrics = {
            "total_tokens": 0,
            "total_steps": 0,
            "elapsed_seconds": 0,
            "sources_found": 0
        }
        self._start_time: Optional[float] = None

    def start(self):
        """Inicia el tracking"""
        self._start_time = time.time()

    def update_agent(self, agent: str, status: str, detail: str = ""):
        """Actualiza estado de un agente"""
        self.agent_status[agent] = status
        if detail:
            self.events.append({
                "time": time.time() - (self._start_time or time.time()),
                "agent": agent,
                "event": detail
            })

    def update_metrics(self, **kwargs):
        """Actualiza métricas"""
        self.metrics.update(kwargs)
        if self._start_time:
            self.metrics["elapsed_seconds"] = round(
                time.time() - self._start_time, 1
            )

    def render(self) -> str:
        """Renderiza el dashboard como texto"""
        lines = []
        lines.append("=" * 60)
        lines.append("  RESEARCH AGENT - LIVE DASHBOARD")
        lines.append("=" * 60)

        # Estado de agentes
        lines.append("")
        lines.append("  AGENTES")
        lines.append("  " + "-" * 40)

        status_icons = {
            "idle": "[ ]",
            "working": "[~]",
            "done": "[+]",
            "error": "[!]"
        }

        for agent, status in self.agent_status.items():
            icon = status_icons.get(status, "[?]")
            lines.append(f"  {icon} {agent:<15} {status}")

        # Métricas
        lines.append("")
        lines.append("  METRICAS")
        lines.append("  " + "-" * 40)
        lines.append(f"  Tiempo:     {self.metrics['elapsed_seconds']}s")
        lines.append(f"  Tokens:     {self.metrics['total_tokens']:,}")
        lines.append(f"  Pasos:      {self.metrics['total_steps']}")
        lines.append(f"  Fuentes:    {self.metrics['sources_found']}")

        # Eventos recientes
        lines.append("")
        lines.append("  EVENTOS RECIENTES")
        lines.append("  " + "-" * 40)

        for event in self.events[-5:]:
            t = f"{event['time']:.1f}s"
            lines.append(f"  [{t:>6}] {event['agent']}: {event['event']}")

        lines.append("")
        lines.append("=" * 60)

        return "\n".join(lines)


async def run_demo_with_dashboard():
    """Ejecuta demo con dashboard en tiempo real"""

    dashboard = TerminalDashboard()
    dashboard.start()

    # Simular flujo de agentes
    phases = [
        ("Orchestrator", "working", "Planificando investigación..."),
        ("Orchestrator", "working", "Descomponiendo en 3 subtemas"),
        ("Researcher", "working", "Buscando: subtema 1"),
        ("Researcher", "working", "Extrayendo contenido de 3 fuentes"),
        ("Researcher", "working", "Buscando: subtema 2"),
        ("Researcher", "done", "5 hallazgos almacenados"),
        ("Analyst", "working", "Analizando hallazgos"),
        ("Analyst", "working", "Detectando patrones y sesgos"),
        ("Analyst", "done", "Análisis completado: 3 insights"),
        ("Writer", "working", "Generando estructura del reporte"),
        ("Writer", "working", "Escribiendo secciones con citas"),
        ("Writer", "done", "Reporte generado: 1,200 palabras"),
        ("Critic", "working", "Evaluando calidad y coherencia"),
        ("Critic", "done", "Score: 8.5/10 - Aprobado"),
        ("Orchestrator", "done", "Investigación completada"),
    ]

    token_increments = [
        100, 200, 2000, 3000, 2500, 500,
        1500, 1000, 300, 2000, 3000, 500,
        1000, 200, 100
    ]

    for i, (agent, status, detail) in enumerate(phases):
        dashboard.update_agent(agent, status, detail)
        dashboard.update_metrics(
            total_tokens=sum(token_increments[:i + 1]),
            total_steps=i + 1,
            sources_found=min(i, 5)
        )

        # Limpiar pantalla y renderizar
        print("\033[2J\033[H")  # Clear screen
        print(dashboard.render())

        await asyncio.sleep(1.5)

    print("\nDemo completada.")


if __name__ == "__main__":
    asyncio.run(run_demo_with_dashboard())
```

## Script de Presentación

```python
# scripts/presentation_script.py
"""Script guiado para la presentación del proyecto"""

PRESENTATION_SCRIPT = """
╔══════════════════════════════════════════════════════════╗
║          GUIÓN DE PRESENTACIÓN - RESEARCH AGENT          ║
╠══════════════════════════════════════════════════════════╣
║                                                          ║
║  Duración total: 15-20 minutos                          ║
║  Audiencia: Técnica                                      ║
║                                                          ║
╠══════════════════════════════════════════════════════════╣
║                                                          ║
║  PARTE 1: CONTEXTO (2 min)                              ║
║  ─────────────────────                                   ║
║  • Problema: Investigar temas complejos toma horas       ║
║  • Solución: Agentes especializados que colaboran        ║
║  • Stack: Gemini 2.0 + FastAPI + Redis + Docker          ║
║                                                          ║
║  PARTE 2: ARQUITECTURA (3 min)                          ║
║  ──────────────────────────                              ║
║  • Mostrar diagrama de arquitectura                      ║
║  • Explicar patrón Supervisor                            ║
║  • Destacar: cada agente tiene tools propias,            ║
║    presupuesto de tokens, y system instruction única     ║
║                                                          ║
║  PARTE 3: DEMO EN VIVO (5 min)                          ║
║  ──────────────────────────                              ║
║  • Abrir terminal con dashboard                          ║
║  • Lanzar investigación: "IA en medicina"                ║
║  • Mostrar agentes trabajando en tiempo real             ║
║  • Mientras se ejecuta, explicar qué hace cada agente    ║
║  • Mostrar resultado final (reporte generado)            ║
║                                                          ║
║  PARTE 4: MÉTRICAS (2 min)                              ║
║  ─────────────────────                                   ║
║  • Abrir Grafana: dashboard de métricas                  ║
║  • Mostrar: tokens por agente, latencia, success rate    ║
║  • Destacar: el sistema se auto-optimiza                 ║
║                                                          ║
║  PARTE 5: CÓDIGO DESTACADO (3 min)                      ║
║  ─────────────────────────────                           ║
║  • BaseAgent: agent loop con tool registry               ║
║  • Orchestrator: delegación inteligente                  ║
║  • Tests: adversarial testing (prompt injection)         ║
║                                                          ║
║  PARTE 6: LECCIONES APRENDIDAS (2 min)                  ║
║  ─────────────────────────────────                       ║
║  • El presupuesto de tokens es esencial                  ║
║  • Los agentes necesitan system instructions claras      ║
║  • Testing adversarial encontró bugs reales              ║
║  • La observabilidad no es opcional                      ║
║                                                          ║
║  PARTE 7: Q&A (3-5 min)                                ║
║  ────────────────────                                    ║
║  • Preguntas frecuentes preparadas:                      ║
║    - ¿Por qué Gemini y no GPT-4?                        ║
║    - ¿Cómo manejas alucinaciones?                       ║
║    - ¿Cuánto cuesta ejecutar una investigación?          ║
║    - ¿Cómo escala el sistema?                            ║
║                                                          ║
╚══════════════════════════════════════════════════════════╝
"""


# Respuestas preparadas para Q&A
QA_RESPONSES = {
    "¿Por qué Gemini y no GPT-4?": (
        "Gemini 2.0 Flash ofrece un balance ideal: "
        "velocidad comparable a GPT-3.5 con calidad cercana a GPT-4, "
        "a menor costo. Además, la integración nativa con "
        "Google Cloud simplifica el despliegue. El sistema es "
        "agnóstico al modelo; cambiar a otro LLM requiere "
        "modificar solo la capa de modelo."
    ),
    "¿Cómo manejas alucinaciones?": (
        "Tres estrategias: (1) El Researcher verifica fuentes y "
        "asigna scores de confiabilidad. (2) El Analyst cruza "
        "información entre múltiples fuentes. (3) El Critic "
        "evalúa coherencia y detecta afirmaciones sin respaldo. "
        "Si el score es <7, el reporte se regenera."
    ),
    "¿Cuánto cuesta ejecutar una investigación?": (
        "Investigación quick: ~$0.01 (2K tokens). "
        "Standard: ~$0.05 (15K tokens). "
        "Deep: ~$0.15 (50K tokens). "
        "Con Gemini Flash a $0.075/1M input tokens, "
        "el costo es muy bajo comparado con GPT-4."
    ),
    "¿Cómo escala el sistema?": (
        "Horizontalmente con Kubernetes: HPA escala pods según "
        "CPU y métricas custom (cola de tareas). Redis maneja "
        "la comunicación entre instancias. Cada investigación "
        "es independiente, permitiendo paralelismo completo."
    )
}


def print_script():
    """Imprime el guión de presentación"""
    print(PRESENTATION_SCRIPT)

    print("\n\nRESPUESTAS PREPARADAS PARA Q&A")
    print("=" * 50)

    for question, answer in QA_RESPONSES.items():
        print(f"\nP: {question}")
        print(f"R: {answer}")


if __name__ == "__main__":
    print_script()
```

## Checklist Pre-Demo

```python
# scripts/demo_checklist.py
"""Verifica que todo esté listo para la demo"""

import asyncio
import httpx
import subprocess


async def run_checklist():
    """Ejecuta checklist completo pre-demo"""

    checks = []

    # 1. Docker running
    try:
        result = subprocess.run(
            ["docker", "ps"], capture_output=True, text=True
        )
        docker_ok = result.returncode == 0
        checks.append(("Docker running", docker_ok))
    except FileNotFoundError:
        checks.append(("Docker running", False))

    # 2. Services up
    services = ["api:8080", "redis:6379"]
    for service in services:
        name, port = service.split(":")
        try:
            reader, writer = await asyncio.open_connection(
                "localhost", int(port)
            )
            writer.close()
            await writer.wait_closed()
            checks.append((f"Service {name}", True))
        except (ConnectionRefusedError, OSError):
            checks.append((f"Service {name}", False))

    # 3. API health
    try:
        async with httpx.AsyncClient(timeout=5) as client:
            resp = await client.get("http://localhost:8080/health")
            checks.append(("API health", resp.status_code == 200))
    except Exception:
        checks.append(("API health", False))

    # 4. Tests passing
    try:
        result = subprocess.run(
            ["python", "-m", "pytest", "tests/unit/", "-q", "--tb=no"],
            capture_output=True, text=True, timeout=60
        )
        checks.append(("Unit tests", result.returncode == 0))
    except Exception:
        checks.append(("Unit tests", False))

    # 5. Demo scenarios configured
    from pathlib import Path
    demo_config = Path("demo/config.json")
    checks.append(("Demo config", demo_config.exists()))

    # Resultado
    print("=" * 50)
    print("  PRE-DEMO CHECKLIST")
    print("=" * 50)

    all_passed = True
    for name, passed in checks:
        icon = "[+]" if passed else "[!]"
        status = "OK" if passed else "FAIL"
        print(f"  {icon} {name:<25} {status}")
        if not passed:
            all_passed = False

    print("=" * 50)

    if all_passed:
        print("  Todo listo para la demo.")
    else:
        print("  HAY PROBLEMAS. Revisa los items marcados [!].")

    return all_passed


if __name__ == "__main__":
    asyncio.run(run_checklist())
```

## Ejercicios

### Ejercicio 1: Ejecuta la demo completa con el dashboard en terminal y graba un screencast de 5 minutos.
### Ejercicio 2: Añade un escenario de demo que muestre el manejo de errores (fuente no disponible, timeout de agente).
### Ejercicio 3: Prepara una presentación alternativa de 5 minutos para audiencia no técnica enfocada en el valor del producto.

## Resumen

| Componente | Propósito | Script |
|-----------|----------|--------|
| DemoEnvironment | Entorno controlado | setup_demo.py |
| TerminalDashboard | Visualización en vivo | demo_dashboard.py |
| DemoPresenter | Control de slides | setup_demo.py |
| Presentation Script | Guión estructurado | presentation_script.py |
| Pre-demo Checklist | Verificación pre-demo | demo_checklist.py |

---

**Siguiente:** [11.3.3 Retrospectiva y Mejoras](./11.3.3-retrospectiva-mejoras.md)
