# 11.3.1 DocumentaciÃ³n Final

## Objetivo de Aprendizaje

Al finalizar este subtema, habrÃ¡s creado documentaciÃ³n completa del proyecto: README profesional, documentaciÃ³n de API, guÃ­as de arquitectura, y manuales de operaciÃ³n.

## IntroducciÃ³n

La documentaciÃ³n es lo que transforma un proyecto personal en un producto profesional. Documentaremos a cuatro niveles: usuario (README/quickstart), desarrollador (arquitectura/API), operaciones (runbooks/troubleshooting), y decisiones (ADRs/changelog).

```
PirÃ¡mide de DocumentaciÃ³n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ README  â”‚  â† Primer contacto
         â”‚Quickstartâ”‚
        â”Œâ”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”
        â”‚   GuÃ­as   â”‚  â† Usuarios
        â”‚ de Uso    â”‚
       â”Œâ”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”
       â”‚ API Docs    â”‚  â† Desarrolladores
       â”‚ Arquitecturaâ”‚
      â”Œâ”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”
      â”‚  Runbooks      â”‚  â† Operaciones
      â”‚  Troubleshoot  â”‚
     â”Œâ”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”
     â”‚  ADRs / Changelog â”‚  â† Decisiones
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## README Profesional

```markdown
# docs/README.md

# ğŸ” Research Agent - Asistente de InvestigaciÃ³n Multi-Agente

Sistema multi-agente construido con Google Gemini para investigaciÃ³n
automatizada de temas complejos.

## CaracterÃ­sticas

- **InvestigaciÃ³n autÃ³noma** con mÃºltiples fuentes web
- **AnÃ¡lisis multi-perspectiva** con detecciÃ³n de sesgos
- **GeneraciÃ³n de reportes** estructurados y citados
- **RevisiÃ³n automÃ¡tica** con scoring de calidad
- **Memoria semÃ¡ntica** para contexto entre sesiones

## Arquitectura

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  API REST                    â”‚
â”‚              (FastAPI + Auth)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   Orchestrator     â”‚
         â”‚   (Supervisor)     â”‚
         â””â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚  â”‚  â”‚  â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”
   â–¼           â–¼  â–¼           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚Researâ”‚ â”‚Analysâ”‚ â”‚Writerâ”‚ â”‚Criticâ”‚
â”‚cher  â”‚ â”‚  t   â”‚ â”‚      â”‚ â”‚      â”‚
â””â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”€â”˜
   â”‚        â”‚        â”‚        â”‚
   â–¼        â–¼        â–¼        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Memory (Redis + Chroma)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Quickstart

### Prerrequisitos

- Python 3.11+
- Docker y Docker Compose
- API Key de Google Gemini

### InstalaciÃ³n

# 1. Clonar repositorio
git clone https://github.com/tu-usuario/research-agent.git
cd research-agent

# 2. Configurar variables de entorno
cp .env.example .env
# Editar .env con tu GOOGLE_API_KEY

# 3. Levantar servicios
docker compose up -d

# 4. Verificar salud
curl http://localhost:8080/health

### Uso RÃ¡pido

# Iniciar investigaciÃ³n
curl -X POST http://localhost:8080/api/v1/research \
  -H "Content-Type: application/json" \
  -d '{"topic": "EnergÃ­as renovables 2024", "depth": "standard"}'

# Consultar estado
curl http://localhost:8080/api/v1/research/{research_id}

## ConfiguraciÃ³n

| Variable | DescripciÃ³n | Default |
|----------|-------------|---------|
| GOOGLE_API_KEY | API key de Gemini | (requerido) |
| REDIS_URL | URL de Redis | redis://localhost:6379 |
| LOG_LEVEL | Nivel de logging | INFO |
| MAX_TOKENS_PER_AGENT | Presupuesto de tokens | 20000 |
| MAX_CONCURRENT_TASKS | Tareas simultÃ¡neas | 5 |

## Licencia

MIT License - ver [LICENSE](LICENSE) para detalles.
```

## DocumentaciÃ³n de API con OpenAPI

```python
# src/api/docs.py
"""DocumentaciÃ³n enriquecida de la API con ejemplos"""

from fastapi import FastAPI
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any

# === Schemas con documentaciÃ³n detallada ===

class ResearchRequest(BaseModel):
    """Solicitud para iniciar una investigaciÃ³n.

    El sistema descompondrÃ¡ el tema en subtemas,
    investigarÃ¡ cada uno, analizarÃ¡ hallazgos,
    generarÃ¡ un reporte y lo revisarÃ¡ automÃ¡ticamente.
    """
    topic: str = Field(
        ...,
        min_length=5,
        max_length=1000,
        description="Tema a investigar. Debe ser especÃ­fico y claro.",
        json_schema_extra={
            "examples": ["Impacto de la IA en educaciÃ³n superior en 2024"]
        }
    )
    depth: str = Field(
        default="standard",
        pattern="^(quick|standard|deep)$",
        description=(
            "Profundidad de investigaciÃ³n:\n"
            "- quick: 2-3 fuentes, ~2 min\n"
            "- standard: 5-8 fuentes, ~5 min\n"
            "- deep: 10+ fuentes, ~10 min"
        )
    )
    max_subtopics: int = Field(
        default=3,
        ge=1,
        le=10,
        description="NÃºmero mÃ¡ximo de subtemas a investigar"
    )
    language: str = Field(
        default="es",
        description="Idioma del reporte (es, en, pt)"
    )

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "topic": "Inteligencia Artificial en medicina",
                    "depth": "standard",
                    "max_subtopics": 3,
                    "language": "es"
                }
            ]
        }
    }


class ResearchStatus(BaseModel):
    """Estado actual de una investigaciÃ³n"""
    research_id: str = Field(description="ID Ãºnico de la investigaciÃ³n")
    status: str = Field(
        description="Estado: queued | running | completed | failed"
    )
    progress: Optional[float] = Field(
        default=None,
        description="Progreso estimado (0.0 a 1.0)"
    )
    current_phase: Optional[str] = Field(
        default=None,
        description="Fase actual: research | analysis | writing | review"
    )
    result: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Resultado completo (solo cuando status=completed)"
    )
    error: Optional[str] = Field(
        default=None,
        description="Mensaje de error (solo cuando status=failed)"
    )
    metrics: Optional[Dict[str, Any]] = Field(
        default=None,
        description="MÃ©tricas de ejecuciÃ³n"
    )


class AgentStatus(BaseModel):
    """Estado de un agente individual"""
    name: str
    role: str
    status: str = Field(description="idle | busy | error")
    current_task: Optional[str] = None
    total_tasks_completed: int = 0
    total_tokens_used: int = 0


# === ConfiguraciÃ³n de OpenAPI ===

def configure_api_docs(app: FastAPI):
    """Configura documentaciÃ³n OpenAPI enriquecida"""

    app.title = "Research Agent API"
    app.description = """
## DescripciÃ³n

API para el Asistente de InvestigaciÃ³n Multi-Agente.
Utiliza Google Gemini para investigar, analizar y generar
reportes sobre cualquier tema.

## Flujo de Uso

1. **POST /api/v1/research** - Inicia investigaciÃ³n
2. **GET /api/v1/research/{id}** - Consulta progreso
3. Cuando `status == "completed"`, el campo `result` contiene el reporte

## AutenticaciÃ³n

Todas las rutas requieren API Key en el header:
```
X-API-Key: tu-api-key
```

## Rate Limits

| Tier | Requests/min | Investigations/hour |
|------|-------------|-------------------|
| Free | 10 | 5 |
| Pro | 60 | 30 |
| Enterprise | 300 | Ilimitado |
"""

    app.version = "1.0.0"

    app.openapi_tags = [
        {
            "name": "research",
            "description": "Operaciones de investigaciÃ³n"
        },
        {
            "name": "agents",
            "description": "Estado y mÃ©tricas de agentes"
        },
        {
            "name": "system",
            "description": "Health checks y diagnÃ³stico"
        }
    ]
```

## GuÃ­a de Arquitectura

```markdown
# docs/architecture.md

# GuÃ­a de Arquitectura

## VisiÃ³n General

El sistema sigue el patrÃ³n **Supervisor** donde un Orchestrator
coordina agentes especializados para completar investigaciones.

## Principios de DiseÃ±o

1. **SeparaciÃ³n de responsabilidades**: Cada agente tiene un rol Ãºnico
2. **ComunicaciÃ³n asÃ­ncrona**: Redis Pub/Sub para mensajerÃ­a
3. **Observabilidad primero**: Tracing y mÃ©tricas desde el diseÃ±o
4. **Presupuesto de tokens**: Control de costos por agente
5. **Graceful degradation**: Fallos parciales no colapsan el sistema

## Componentes

### Orchestrator
- **Responsabilidad**: Planificar, delegar y sintetizar
- **Modelo**: gemini-2.0-flash (rÃ¡pido para coordinaciÃ³n)
- **Token Budget**: 30,000
- **Decisiones clave**: DescomposiciÃ³n de temas, asignaciÃ³n a agentes,
  manejo de reintentos

### Researcher
- **Responsabilidad**: BÃºsqueda web y extracciÃ³n de informaciÃ³n
- **Tools**: web_search, extract_content, store_finding, search_memory
- **Token Budget**: 20,000
- **Decisiones clave**: SelecciÃ³n de fuentes, evaluaciÃ³n de confiabilidad

### Analyst
- **Responsabilidad**: AnÃ¡lisis de hallazgos y sÃ­ntesis
- **Tools**: analyze_data, compare_sources, detect_bias
- **Token Budget**: 15,000

### Writer
- **Responsabilidad**: GeneraciÃ³n de reporte estructurado
- **Tools**: create_section, add_citation, format_report
- **Token Budget**: 20,000

### Critic
- **Responsabilidad**: EvaluaciÃ³n de calidad y coherencia
- **Tools**: evaluate_section, score_report
- **Token Budget**: 15,000

## Flujo de Datos

1. Usuario envÃ­a request â†’ API crea tarea
2. Orchestrator descompone en subtemas
3. Researcher investiga cada subtema (paralelo si es posible)
4. Analyst sintetiza hallazgos
5. Writer genera reporte
6. Critic evalÃºa â†’ aprueba o solicita revisiÃ³n
7. Resultado almacenado y devuelto al usuario

## Decisiones de Arquitectura (ADRs)

Ver [ADR-001](adrs/001-modelo-gemini-flash.md) a
[ADR-005](adrs/005-deployment-strategy.md) para detalles
de cada decisiÃ³n tÃ©cnica.
```

## Runbooks de OperaciÃ³n

```markdown
# docs/runbooks/operations.md

# Runbook de Operaciones

## Despliegue

### Despliegue Local (Desarrollo)

```bash
# Levantar todos los servicios
docker compose up -d

# Verificar logs
docker compose logs -f api

# Ejecutar tests
docker compose exec api pytest tests/ -v
```

### Despliegue en ProducciÃ³n

```bash
# Build de imagen
docker build -t research-agent:v1.0.0 -f docker/Dockerfile .

# Push a registry
docker push gcr.io/proyecto/research-agent:v1.0.0

# Aplicar manifiestos K8s
kubectl apply -k k8s/overlays/production/

# Verificar rollout
kubectl rollout status deployment/research-agent -n agents
```

## Troubleshooting

### Problema: API no responde

1. Verificar pods:
   kubectl get pods -n agents
2. Revisar logs:
   kubectl logs -l app=research-agent -n agents --tail=100
3. Verificar health:
   kubectl exec -it <pod> -- curl localhost:8080/health
4. Verificar Redis:
   kubectl exec -it <redis-pod> -- redis-cli ping

### Problema: InvestigaciÃ³n colgada (status=running > 10 min)

1. Verificar estado de la tarea:
   curl http://api/api/v1/research/{id}
2. Revisar logs del agente activo:
   kubectl logs <pod> | grep {research_id}
3. Si el agente estÃ¡ en loop, cancelar:
   curl -X DELETE http://api/api/v1/research/{id}
4. Verificar presupuesto de tokens consumidos

### Problema: Alto consumo de tokens

1. Revisar mÃ©tricas en Grafana:
   Dashboard "Agent Metrics" â†’ Panel "Token Usage"
2. Identificar agente con mayor consumo
3. Verificar si hay loops en el razonamiento
4. Ajustar token_budget en configuraciÃ³n
5. Considerar cambiar a modelo mÃ¡s eficiente

### Problema: Redis sin memoria

1. Verificar uso: redis-cli INFO memory
2. Limpiar historial antiguo:
   redis-cli KEYS "messages:*" | head -20
3. Ajustar polÃ­tica de evicciÃ³n en redis.conf
4. Aumentar memoria si es necesario
```

## GeneraciÃ³n AutomÃ¡tica de Docs

```python
# scripts/generate_docs.py
"""Genera documentaciÃ³n automÃ¡tica del proyecto"""

import inspect
import json
from pathlib import Path
from typing import get_type_hints
from src.agents.base import BaseAgent
from src.agents.researcher import ResearcherAgent
from src.agents.orchestrator import OrchestratorAgent


def generate_agent_docs(agent_class: type) -> str:
    """Genera documentaciÃ³n markdown de un agente"""
    doc = f"# {agent_class.__name__}\n\n"

    # Docstring
    if agent_class.__doc__:
        doc += f"{agent_class.__doc__}\n\n"

    # Atributos de clase
    doc += "## ConfiguraciÃ³n\n\n"
    doc += "| Atributo | Valor |\n"
    doc += "|----------|-------|\n"

    instance_attrs = {
        "name": getattr(agent_class, 'DEFAULT_NAME', 'N/A'),
        "role": getattr(agent_class, 'DEFAULT_ROLE', 'N/A'),
        "max_steps": getattr(agent_class, 'DEFAULT_MAX_STEPS', 'N/A'),
        "token_budget": getattr(agent_class, 'DEFAULT_TOKEN_BUDGET', 'N/A'),
    }

    for attr, value in instance_attrs.items():
        doc += f"| {attr} | {value} |\n"

    # Tools
    doc += "\n## Tools\n\n"
    for name, method in inspect.getmembers(agent_class, predicate=inspect.isfunction):
        if name.startswith('_') and not name.startswith('__'):
            # ConvenciÃ³n: mÃ©todos _tool_name son tools
            if hasattr(method, '__doc__') and method.__doc__:
                doc += f"### {name[1:]}\n\n"
                doc += f"{method.__doc__}\n\n"

                # ParÃ¡metros
                hints = get_type_hints(method)
                if hints:
                    doc += "**ParÃ¡metros:**\n\n"
                    for param, ptype in hints.items():
                        if param != 'return':
                            doc += f"- `{param}`: {ptype.__name__ if hasattr(ptype, '__name__') else str(ptype)}\n"
                    doc += "\n"

    return doc


def generate_api_docs() -> str:
    """Genera documentaciÃ³n de la API desde OpenAPI spec"""
    # En producciÃ³n, obtener de app.openapi()
    doc = "# API Reference\n\n"
    doc += "Base URL: `http://localhost:8080`\n\n"

    endpoints = [
        {
            "method": "GET",
            "path": "/health",
            "description": "Health check del sistema",
            "response": '{"status": "healthy", "version": "1.0.0"}'
        },
        {
            "method": "POST",
            "path": "/api/v1/research",
            "description": "Inicia nueva investigaciÃ³n",
            "body": '{"topic": "string", "depth": "standard", "max_subtopics": 3}',
            "response": '{"research_id": "uuid", "status": "queued"}'
        },
        {
            "method": "GET",
            "path": "/api/v1/research/{research_id}",
            "description": "Consulta estado de investigaciÃ³n",
            "response": '{"research_id": "uuid", "status": "completed", "result": {...}}'
        },
        {
            "method": "POST",
            "path": "/api/v1/chat",
            "description": "Chat directo con agente",
            "body": '{"message": "string", "session_id": "optional"}',
            "response": '{"response": "string", "tokens_used": 150}'
        }
    ]

    for ep in endpoints:
        doc += f"## {ep['method']} `{ep['path']}`\n\n"
        doc += f"{ep['description']}\n\n"

        if "body" in ep:
            doc += f"**Request Body:**\n```json\n{ep['body']}\n```\n\n"

        doc += f"**Response:**\n```json\n{ep['response']}\n```\n\n"
        doc += "---\n\n"

    return doc


def generate_all_docs():
    """Genera toda la documentaciÃ³n"""
    docs_dir = Path("docs/generated")
    docs_dir.mkdir(parents=True, exist_ok=True)

    # Docs de agentes
    agents = [ResearcherAgent, OrchestratorAgent]
    for agent_class in agents:
        doc = generate_agent_docs(agent_class)
        output = docs_dir / f"{agent_class.__name__.lower()}.md"
        output.write_text(doc)
        print(f"Generated: {output}")

    # Docs de API
    api_doc = generate_api_docs()
    (docs_dir / "api_reference.md").write_text(api_doc)
    print("Generated: docs/generated/api_reference.md")

    # Ãndice
    index = "# DocumentaciÃ³n Generada\n\n"
    for f in sorted(docs_dir.glob("*.md")):
        if f.name != "index.md":
            index += f"- [{f.stem}]({f.name})\n"

    (docs_dir / "index.md").write_text(index)
    print("Generated: docs/generated/index.md")


if __name__ == "__main__":
    generate_all_docs()
```

## Changelog y Versionado

```markdown
# CHANGELOG.md

# Changelog

Formato basado en [Keep a Changelog](https://keepachangelog.com/es/1.0.0/).
Este proyecto sigue [Semantic Versioning](https://semver.org/lang/es/).

## [1.0.0] - 2024-12-15

### AÃ±adido
- Sistema multi-agente con 5 roles especializados
- API REST con FastAPI (endpoints: research, chat, health)
- Message broker con Redis Pub/Sub
- Memoria semÃ¡ntica con ChromaDB
- MÃ©tricas con Prometheus y dashboards Grafana
- Tracing distribuido con OpenTelemetry
- Suite de tests (unit, integration, adversarial)
- DocumentaciÃ³n completa (README, API, arquitectura, runbooks)
- Docker Compose para desarrollo local
- Manifiestos Kubernetes para producciÃ³n

### Seguridad
- AutenticaciÃ³n con API Keys y JWT
- Rate limiting por tier (token bucket)
- Logging de auditorÃ­a
- SanitizaciÃ³n de inputs

## [0.2.0] - 2024-12-01

### AÃ±adido
- Agentes Analyst, Writer y Critic
- Flujo completo de investigaciÃ³n end-to-end
- Tests de integraciÃ³n

### Cambiado
- Migrado de polling a Redis Pub/Sub para comunicaciÃ³n

## [0.1.0] - 2024-11-15

### AÃ±adido
- BaseAgent con agent loop y tool registry
- ResearcherAgent con bÃºsqueda web
- OrchestratorAgent con delegaciÃ³n bÃ¡sica
- Tests unitarios iniciales
```

## Ejercicios

### Ejercicio 1: Genera documentaciÃ³n automÃ¡tica de todos los agentes ejecutando el script y verifica que refleja el cÃ³digo actual.
### Ejercicio 2: Crea un ADR para una decisiÃ³n tÃ©cnica que tomaste durante el desarrollo del proyecto.
### Ejercicio 3: Escribe un runbook para un escenario de fallo que descubriste durante el testing adversarial.

## Resumen

| Tipo de Doc | Audiencia | Herramienta | Formato |
|-------------|-----------|------------|---------|
| README | Todos | Manual | Markdown |
| API Docs | Desarrolladores | OpenAPI/FastAPI | JSON/HTML |
| Arquitectura | Equipo tÃ©cnico | Manual + diagramas | Markdown |
| Runbooks | Operaciones | Manual | Markdown |
| Changelog | Todos | Manual | Markdown |
| Agent Docs | Desarrolladores | Script automÃ¡tico | Markdown |

---

**Siguiente:** [11.3.2 Demo y PresentaciÃ³n](./11.3.2-demo-presentacion.md)
