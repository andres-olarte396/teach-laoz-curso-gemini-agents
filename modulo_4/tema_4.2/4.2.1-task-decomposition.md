# 4.2.1 Task Decomposition Autom√°tica

## Tiempo estimado: 75 minutos
## Nivel: Intermedio-Avanzado

## Prerrequisitos
- Bucle OTA y condiciones de terminaci√≥n (4.1)
- Chain of Thought (2.2.1)
- Prompts de planificaci√≥n (2.3.1)

## ¬øPor qu√© es importante?

La **descomposici√≥n de tareas** es fundamental para que los agentes puedan resolver problemas complejos. Permite:
- Dividir problemas grandes en subproblemas manejables
- Identificar dependencias entre subtareas
- Paralelizar trabajo cuando es posible
- Hacer seguimiento del progreso de manera granular

> "Un problema bien descompuesto est√° medio resuelto."

## Arquitectura de Task Decomposition

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SISTEMA DE DESCOMPOSICI√ìN DE TAREAS                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                     TAREA PRINCIPAL                              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   "Construir un sistema de recomendaciones para e-commerce"      ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    DESCOMPONEDOR (LLM)                           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Analiza la tarea                                              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Identifica componentes                                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Genera subtareas                                              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Define dependencias                                           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Estima complejidad                                            ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                       GRAFO DE TAREAS                            ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ     ‚îÇTask 1‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇTask 2‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇTask 4‚îÇ                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                   ‚îÇ                              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚ñº                              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ     ‚îÇTask 3‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇTask 5‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇFinal ‚îÇ                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Tipos de Descomposici√≥n

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ESTRATEGIAS DE DESCOMPOSICI√ìN                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                        ‚îÇ
‚îÇ  1. SECUENCIAL (Pipeline)                                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÄ‚ñ∂ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÄ‚ñ∂ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÄ‚ñ∂ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                            ‚îÇ
‚îÇ  ‚îÇ  A  ‚îÇ    ‚îÇ  B  ‚îÇ    ‚îÇ  C  ‚îÇ    ‚îÇ  D  ‚îÇ                            ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îÇ
‚îÇ  Uso: Cuando cada paso depende del anterior                           ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  2. PARALELA (Fork-Join)                                               ‚îÇ
‚îÇ                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                                 ‚îÇ
‚îÇ           ‚îå‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  B  ‚îÇ‚îÄ‚îÄ‚îÄ‚îê                                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÄ‚î§    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îú‚îÄ‚ñ∂ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                 ‚îÇ
‚îÇ  ‚îÇ  A  ‚îÇ  ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ   ‚îÇ  D  ‚îÇ                                 ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  C  ‚îÇ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚ñ∂‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
‚îÇ                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                                 ‚îÇ
‚îÇ  Uso: Cuando subtareas son independientes                             ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  3. JER√ÅRQUICA (√Årbol)                                                 ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                             ‚îÇ
‚îÇ                    ‚îÇ  A  ‚îÇ                                             ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò                                             ‚îÇ
‚îÇ            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                      ‚îÇ
‚îÇ         ‚îå‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îê                                  ‚îÇ
‚îÇ         ‚îÇ A.1 ‚îÇ   ‚îÇ A.2 ‚îÇ   ‚îÇ A.3 ‚îÇ                                  ‚îÇ
‚îÇ         ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò                                  ‚îÇ
‚îÇ         ‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îê             ‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îê                                  ‚îÇ
‚îÇ       ‚îå‚îÄ‚ñº‚îÄ‚îê‚îå‚îÄ‚ñº‚îÄ‚îê          ‚îå‚îÄ‚ñº‚îÄ‚îê‚îå‚îÄ‚ñº‚îÄ‚îê                                 ‚îÇ
‚îÇ       ‚îÇ1.1‚îÇ‚îÇ1.2‚îÇ          ‚îÇ3.1‚îÇ‚îÇ3.2‚îÇ                                 ‚îÇ
‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
‚îÇ  Uso: Problemas con estructura anidada                                ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  4. CONDICIONAL (DAG)                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                                   ‚îÇ
‚îÇ  ‚îÇ  A  ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  B  ‚îÇ‚îÄ‚îÄ‚îÄ‚îê                                              ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                   ‚îÇ
‚îÇ                       ‚îú‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  D  ‚îÇ                                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                   ‚îÇ
‚îÇ  ‚îÇ  C  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                              ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                                              ‚îÇ
‚îÇ  Uso: Cuando hay m√∫ltiples caminos posibles                          ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n del Sistema de Descomposici√≥n

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Optional, Callable, Any
from enum import Enum, auto
import json
import os
from collections import deque

class TaskStatus(Enum):
    """Estados posibles de una tarea."""
    PENDING = auto()
    READY = auto()      # Dependencias satisfechas
    IN_PROGRESS = auto()
    COMPLETED = auto()
    FAILED = auto()
    BLOCKED = auto()

@dataclass
class Task:
    """Representa una tarea o subtarea."""
    id: str
    description: str
    status: TaskStatus = TaskStatus.PENDING
    dependencies: list[str] = field(default_factory=list)
    subtasks: list['Task'] = field(default_factory=list)
    result: Optional[Any] = None
    estimated_complexity: int = 1  # 1-5
    actual_effort: Optional[int] = None
    metadata: dict = field(default_factory=dict)

    def is_atomic(self) -> bool:
        """Verifica si es una tarea at√≥mica (sin subtareas)."""
        return len(self.subtasks) == 0

    def all_dependencies_met(self, completed_tasks: set[str]) -> bool:
        """Verifica si todas las dependencias est√°n satisfechas."""
        return all(dep in completed_tasks for dep in self.dependencies)


@dataclass
class TaskGraph:
    """Grafo dirigido ac√≠clico de tareas."""
    root: Task
    all_tasks: dict[str, Task] = field(default_factory=dict)

    def __post_init__(self):
        self._index_tasks(self.root)

    def _index_tasks(self, task: Task):
        """Indexa todas las tareas recursivamente."""
        self.all_tasks[task.id] = task
        for subtask in task.subtasks:
            self._index_tasks(subtask)

    def get_ready_tasks(self, completed: set[str]) -> list[Task]:
        """Obtiene tareas listas para ejecutar."""
        ready = []
        for task in self.all_tasks.values():
            if (task.status == TaskStatus.PENDING and
                task.is_atomic() and
                task.all_dependencies_met(completed)):
                ready.append(task)
        return ready

    def topological_sort(self) -> list[Task]:
        """Ordena tareas respetando dependencias."""
        in_degree = {tid: 0 for tid in self.all_tasks}
        for task in self.all_tasks.values():
            for dep in task.dependencies:
                if dep in in_degree:
                    in_degree[task.id] += 1

        queue = deque([tid for tid, deg in in_degree.items() if deg == 0])
        result = []

        while queue:
            tid = queue.popleft()
            task = self.all_tasks[tid]
            result.append(task)

            # Encontrar tareas que dependen de esta
            for other in self.all_tasks.values():
                if tid in other.dependencies:
                    in_degree[other.id] -= 1
                    if in_degree[other.id] == 0:
                        queue.append(other.id)

        return result


class TaskDecomposer:
    """
    Descompone tareas complejas en subtareas manejables usando LLM.
    """

    DECOMPOSITION_PROMPT = """Eres un experto en descomposici√≥n de tareas.
Analiza la siguiente tarea y descomponla en subtareas m√°s peque√±as y manejables.

TAREA PRINCIPAL:
{task_description}

CONTEXTO ADICIONAL:
{context}

INSTRUCCIONES:
1. Identifica los componentes principales de la tarea
2. Crea subtareas espec√≠ficas y accionables
3. Define dependencias entre subtareas (qu√© debe completarse antes)
4. Estima la complejidad de cada subtarea (1-5)
5. Las subtareas deben ser lo suficientemente peque√±as para completarse en 1-3 pasos

Responde en formato JSON:
{{
    "analysis": "Breve an√°lisis de la tarea",
    "decomposition_strategy": "secuencial|paralela|jerarquica|mixta",
    "subtasks": [
        {{
            "id": "1",
            "description": "Descripci√≥n clara de la subtarea",
            "dependencies": [],
            "complexity": 1-5,
            "rationale": "Por qu√© esta subtarea es necesaria"
        }},
        {{
            "id": "2",
            "description": "Segunda subtarea...",
            "dependencies": ["1"],
            "complexity": 2,
            "rationale": "..."
        }}
    ],
    "execution_order": ["1", "2", ...],
    "parallelizable_groups": [["1"], ["2", "3"], ...]
}}

Responde SOLO con el JSON."""

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)
        self.min_complexity_to_decompose = 3
        self.max_depth = 3

    def decompose(
        self,
        task_description: str,
        context: str = "",
        depth: int = 0
    ) -> TaskGraph:
        """
        Descompone una tarea en un grafo de subtareas.

        Args:
            task_description: Descripci√≥n de la tarea principal
            context: Contexto adicional
            depth: Profundidad actual de recursi√≥n

        Returns:
            TaskGraph con la estructura de tareas
        """
        print(f"{'  '*depth}üìã Descomponiendo: {task_description[:50]}...")

        # Crear tarea ra√≠z
        root_task = Task(
            id="root",
            description=task_description,
            status=TaskStatus.PENDING
        )

        # Obtener descomposici√≥n del LLM
        decomposition = self._get_decomposition(task_description, context)

        if not decomposition or not decomposition.get("subtasks"):
            # No se pudo descomponer, es una tarea at√≥mica
            return TaskGraph(root=root_task)

        print(f"{'  '*depth}  Estrategia: {decomposition.get('decomposition_strategy')}")
        print(f"{'  '*depth}  Subtareas: {len(decomposition['subtasks'])}")

        # Crear subtareas
        for st_data in decomposition["subtasks"]:
            subtask = Task(
                id=st_data["id"],
                description=st_data["description"],
                dependencies=st_data.get("dependencies", []),
                estimated_complexity=st_data.get("complexity", 2),
                metadata={"rationale": st_data.get("rationale", "")}
            )

            # Descomposici√≥n recursiva si es compleja
            if (subtask.estimated_complexity >= self.min_complexity_to_decompose
                and depth < self.max_depth):

                sub_graph = self.decompose(
                    subtask.description,
                    context=f"Esta es parte de: {task_description}",
                    depth=depth + 1
                )

                if sub_graph.root.subtasks:
                    subtask.subtasks = sub_graph.root.subtasks

            root_task.subtasks.append(subtask)

        # Guardar metadatos de la descomposici√≥n
        root_task.metadata = {
            "analysis": decomposition.get("analysis", ""),
            "strategy": decomposition.get("decomposition_strategy", ""),
            "parallelizable_groups": decomposition.get("parallelizable_groups", [])
        }

        return TaskGraph(root=root_task)

    def _get_decomposition(self, task: str, context: str) -> Optional[dict]:
        """Obtiene la descomposici√≥n del LLM."""
        prompt = self.DECOMPOSITION_PROMPT.format(
            task_description=task,
            context=context or "Sin contexto adicional"
        )

        try:
            response = self.model.generate_content(prompt)
            text = response.text.strip()

            # Limpiar markdown si existe
            if text.startswith("```"):
                text = text.split("```")[1]
                if text.startswith("json"):
                    text = text[4:]

            return json.loads(text)
        except (json.JSONDecodeError, Exception) as e:
            print(f"  ‚ö†Ô∏è  Error en descomposici√≥n: {e}")
            return None


class TaskExecutor:
    """
    Ejecuta tareas respetando dependencias y orden.
    """

    def __init__(self):
        self.task_handlers: dict[str, Callable] = {}
        self.completed_tasks: set[str] = set()
        self.results: dict[str, Any] = {}

    def register_handler(self, pattern: str, handler: Callable):
        """Registra un handler para cierto tipo de tarea."""
        self.task_handlers[pattern] = handler

    def execute_graph(self, graph: TaskGraph) -> dict[str, Any]:
        """
        Ejecuta todas las tareas del grafo respetando dependencias.
        """
        print("\n" + "="*60)
        print("EJECUTANDO GRAFO DE TAREAS")
        print("="*60)

        # Obtener orden topol√≥gico
        ordered = graph.topological_sort()
        total = len([t for t in ordered if t.is_atomic()])

        print(f"Total tareas at√≥micas: {total}\n")

        for task in ordered:
            if not task.is_atomic():
                continue

            # Verificar dependencias
            if not task.all_dependencies_met(self.completed_tasks):
                task.status = TaskStatus.BLOCKED
                print(f"‚è∏Ô∏è  {task.id}: Bloqueada (dependencias: {task.dependencies})")
                continue

            # Ejecutar tarea
            print(f"‚ñ∂Ô∏è  {task.id}: {task.description[:50]}...")
            task.status = TaskStatus.IN_PROGRESS

            try:
                result = self._execute_task(task)
                task.result = result
                task.status = TaskStatus.COMPLETED
                self.completed_tasks.add(task.id)
                self.results[task.id] = result
                print(f"   ‚úÖ Completada")

            except Exception as e:
                task.status = TaskStatus.FAILED
                print(f"   ‚ùå Error: {e}")

        return self.results

    def _execute_task(self, task: Task) -> Any:
        """Ejecuta una tarea individual."""
        # Buscar handler por palabras clave
        for pattern, handler in self.task_handlers.items():
            if pattern.lower() in task.description.lower():
                return handler(task)

        # Handler por defecto
        return self._default_handler(task)

    def _default_handler(self, task: Task) -> str:
        """Handler por defecto que simula ejecuci√≥n."""
        import time
        time.sleep(0.5)  # Simular trabajo
        return f"Resultado de: {task.description[:30]}"

    async def execute_parallel(self, graph: TaskGraph) -> dict[str, Any]:
        """Ejecuta tareas paralelizables de forma concurrente."""
        import asyncio

        parallelizable = graph.root.metadata.get("parallelizable_groups", [])
        results = {}

        for group in parallelizable:
            tasks_in_group = [graph.all_tasks[tid] for tid in group
                           if tid in graph.all_tasks]

            # Ejecutar grupo en paralelo
            async_tasks = [
                self._async_execute(task)
                for task in tasks_in_group
            ]

            group_results = await asyncio.gather(*async_tasks)

            for task, result in zip(tasks_in_group, group_results):
                task.result = result
                task.status = TaskStatus.COMPLETED
                self.completed_tasks.add(task.id)
                results[task.id] = result

        return results

    async def _async_execute(self, task: Task) -> Any:
        """Versi√≥n as√≠ncrona de ejecuci√≥n de tarea."""
        import asyncio
        await asyncio.sleep(0.5)  # Simular trabajo async
        return self._execute_task(task)
```

## Ejemplo Pr√°ctico: Descomposici√≥n de Proyecto

```python
# Crear el descomponedor
decomposer = TaskDecomposer()

# Tarea compleja
complex_task = """
Desarrollar una API REST para un sistema de gesti√≥n de inventario que incluya:
- Autenticaci√≥n de usuarios con JWT
- CRUD de productos con categor√≠as
- Sistema de alertas de stock bajo
- Generaci√≥n de reportes en PDF
- Integraci√≥n con servicio de notificaciones por email
"""

# Descomponer
print("DESCOMPOSICI√ìN DE TAREA")
print("="*60)
graph = decomposer.decompose(complex_task)

# Mostrar estructura
def print_task_tree(task: Task, indent: int = 0):
    prefix = "  " * indent
    status_icon = {
        TaskStatus.PENDING: "‚¨ú",
        TaskStatus.READY: "üü°",
        TaskStatus.IN_PROGRESS: "üîµ",
        TaskStatus.COMPLETED: "‚úÖ",
        TaskStatus.FAILED: "‚ùå",
        TaskStatus.BLOCKED: "‚è∏Ô∏è"
    }

    icon = status_icon.get(task.status, "‚¨ú")
    deps = f" [deps: {task.dependencies}]" if task.dependencies else ""
    complexity = f" (C:{task.estimated_complexity})" if task.estimated_complexity else ""

    print(f"{prefix}{icon} {task.id}: {task.description[:50]}{deps}{complexity}")

    for subtask in task.subtasks:
        print_task_tree(subtask, indent + 1)

print("\nESTRUCTURA DE TAREAS:")
print("-"*60)
print_task_tree(graph.root)

# Ejecutar tareas
executor = TaskExecutor()

# Registrar handlers espec√≠ficos
def handle_auth_task(task):
    return {"jwt_secret": "generated_secret", "endpoints": ["/login", "/register"]}

def handle_crud_task(task):
    return {"models": ["Product", "Category"], "routes": "/api/products"}

def handle_report_task(task):
    return {"template": "inventory_report.html", "format": "PDF"}

executor.register_handler("autenticaci√≥n", handle_auth_task)
executor.register_handler("jwt", handle_auth_task)
executor.register_handler("crud", handle_crud_task)
executor.register_handler("reporte", handle_report_task)
executor.register_handler("pdf", handle_report_task)

# Ejecutar
results = executor.execute_graph(graph)

print("\n" + "="*60)
print("RESULTADOS")
print("="*60)
for task_id, result in results.items():
    print(f"{task_id}: {result}")
```

## Descomposici√≥n Adaptativa

```python
class AdaptiveDecomposer(TaskDecomposer):
    """
    Descomponedor que adapta su estrategia seg√∫n el contexto.
    """

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        super().__init__(model_name)
        self.history: list[dict] = []

    def decompose(self, task_description: str, context: str = "", depth: int = 0) -> TaskGraph:
        """Descompone con estrategia adaptativa."""

        # Analizar caracter√≠sticas de la tarea
        task_type = self._classify_task(task_description)
        optimal_strategy = self._select_strategy(task_type, depth)

        print(f"{'  '*depth}üìä Tipo detectado: {task_type}")
        print(f"{'  '*depth}üìê Estrategia: {optimal_strategy}")

        # Ajustar par√°metros seg√∫n la estrategia
        if optimal_strategy == "parallel":
            self.min_complexity_to_decompose = 2
        elif optimal_strategy == "deep":
            self.max_depth = 5
        else:
            self.min_complexity_to_decompose = 3
            self.max_depth = 3

        # Incluir contexto de estrategia en el prompt
        enhanced_context = f"""
Contexto: {context}
Estrategia recomendada: {optimal_strategy}
Tipo de tarea: {task_type}
Profundidad actual: {depth}
"""

        graph = super().decompose(task_description, enhanced_context, depth)

        # Guardar en historial para aprendizaje
        self.history.append({
            "task": task_description,
            "type": task_type,
            "strategy": optimal_strategy,
            "subtask_count": len(graph.all_tasks)
        })

        return graph

    def _classify_task(self, description: str) -> str:
        """Clasifica el tipo de tarea."""
        description_lower = description.lower()

        if any(kw in description_lower for kw in ["investigar", "buscar", "analizar"]):
            return "research"
        elif any(kw in description_lower for kw in ["desarrollar", "implementar", "crear"]):
            return "development"
        elif any(kw in description_lower for kw in ["optimizar", "mejorar", "refactorizar"]):
            return "optimization"
        elif any(kw in description_lower for kw in ["documentar", "escribir", "reportar"]):
            return "documentation"
        else:
            return "general"

    def _select_strategy(self, task_type: str, depth: int) -> str:
        """Selecciona la estrategia √≥ptima."""
        strategies = {
            "research": "parallel",      # Investigaci√≥n puede paralelizarse
            "development": "hierarchical",# Desarrollo suele ser jer√°rquico
            "optimization": "sequential", # Optimizaci√≥n requiere orden
            "documentation": "parallel",  # Documentaci√≥n es paralelizable
            "general": "mixed"
        }

        base_strategy = strategies.get(task_type, "mixed")

        # Ajustar por profundidad
        if depth >= 2:
            return "sequential"  # M√°s simple en niveles profundos

        return base_strategy


# Uso del descomponedor adaptativo
adaptive = AdaptiveDecomposer()

tasks = [
    "Investigar las mejores pr√°cticas de seguridad en APIs REST",
    "Implementar un sistema de cache con Redis",
    "Documentar la arquitectura del microservicio de pagos"
]

for task in tasks:
    print(f"\n{'='*60}")
    graph = adaptive.decompose(task)
    print(f"Subtareas generadas: {len(graph.all_tasks)}")
```

## Errores Comunes y Soluciones

### 1. Sobre-Descomposici√≥n

```python
# ‚ùå MAL: Descomponer demasiado
# Tarea: "Sumar 2 + 2" se descompone en 10 subtareas

# ‚úÖ BIEN: Umbral de complejidad
class SmartDecomposer(TaskDecomposer):
    def should_decompose(self, task_description: str) -> bool:
        """Determina si vale la pena descomponer."""
        # Tareas cortas no necesitan descomposici√≥n
        if len(task_description.split()) < 10:
            return False

        # Verificar complejidad aparente
        complexity_indicators = [
            "adem√°s", "tambi√©n", "y luego",
            "m√∫ltiple", "varios", "diferente"
        ]

        return any(ind in task_description.lower()
                  for ind in complexity_indicators)
```

### 2. Dependencias Circulares

```python
# ‚ùå MAL: A depende de B, B depende de A
task_a = Task(id="A", dependencies=["B"])
task_b = Task(id="B", dependencies=["A"])  # ¬°Ciclo!

# ‚úÖ BIEN: Validar dependencias
def validate_dependencies(graph: TaskGraph) -> bool:
    """Detecta ciclos en las dependencias."""
    visited = set()
    rec_stack = set()

    def has_cycle(task_id: str) -> bool:
        visited.add(task_id)
        rec_stack.add(task_id)

        task = graph.all_tasks.get(task_id)
        if task:
            for dep in task.dependencies:
                if dep not in visited:
                    if has_cycle(dep):
                        return True
                elif dep in rec_stack:
                    return True

        rec_stack.remove(task_id)
        return False

    for task_id in graph.all_tasks:
        if task_id not in visited:
            if has_cycle(task_id):
                return False

    return True
```

### 3. P√©rdida de Contexto

```python
# ‚ùå MAL: Subtareas sin contexto
subtask = Task(id="1", description="Implementar endpoint")
# ¬øQu√© endpoint? ¬øPara qu√©?

# ‚úÖ BIEN: Mantener contexto en la descripci√≥n
def create_contextual_subtask(
    parent_description: str,
    subtask_description: str
) -> Task:
    """Crea subtarea manteniendo contexto del padre."""
    full_description = f"{subtask_description} (parte de: {parent_description[:50]})"
    return Task(
        id=generate_id(),
        description=full_description,
        metadata={"parent_task": parent_description}
    )
```

## Aplicaciones de Task Decomposition

| Dominio | Tarea Principal | Subtareas T√≠picas |
|---------|-----------------|-------------------|
| Desarrollo | Crear app m√≥vil | UI, Backend, Auth, Deploy |
| Investigaci√≥n | Paper cient√≠fico | Revisi√≥n, Experimentos, An√°lisis |
| Marketing | Campa√±a digital | Contenido, Ads, Analytics, Reportes |
| DevOps | Migrar a cloud | Assess, Plan, Execute, Validate |
| QA | Testing completo | Unit, Integration, E2E, Performance |

## Resumen

La **Task Decomposition** permite manejar tareas complejas:

1. **An√°lisis**: El LLM analiza la tarea y sus componentes
2. **Descomposici√≥n**: Genera subtareas manejables
3. **Dependencias**: Identifica qu√© tareas dependen de otras
4. **Ejecuci√≥n**: Ejecuta respetando el orden de dependencias

**Estrategias**:
- **Secuencial**: Para tareas con orden estricto
- **Paralela**: Para tareas independientes
- **Jer√°rquica**: Para problemas con estructura anidada
- **Mixta**: Combinaci√≥n seg√∫n necesidad

**Mejores pr√°cticas**:
- Definir umbral de complejidad para evitar sobre-descomposici√≥n
- Validar dependencias para evitar ciclos
- Mantener contexto en subtareas
- Usar descomposici√≥n adaptativa seg√∫n el tipo de tarea

---

## Navegaci√≥n

- **Anterior**: [4.1.3 Condiciones de Terminaci√≥n](../tema_4.1/4.1.3-condiciones-terminacion.md)
- **Siguiente**: [4.2.2 Plan-and-Execute Pattern](./4.2.2-plan-execute-pattern.md)
- **√çndice**: [README del Curso](../../README.md)
