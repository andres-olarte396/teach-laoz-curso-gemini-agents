# 4.2.2 Plan-and-Execute Pattern

## Tiempo estimado: 75 minutos
## Nivel: Intermedio-Avanzado

## Prerrequisitos
- Task Decomposition (4.2.1)
- Modelo ReAct (4.1.1)
- Function Calling (M√≥dulo 3)

## ¬øPor qu√© es importante?

El patr√≥n **Plan-and-Execute** separa expl√≠citamente la fase de planificaci√≥n de la fase de ejecuci√≥n. Esta separaci√≥n ofrece ventajas cr√≠ticas:
- **Visibilidad**: El usuario puede aprobar el plan antes de la ejecuci√≥n
- **Eficiencia**: Evita re-planificaci√≥n innecesaria en cada paso
- **Control**: Permite intervenci√≥n humana entre fases
- **Debugging**: Facilita identificar si el problema est√° en el plan o la ejecuci√≥n

## Arquitectura Plan-and-Execute

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     PATR√ìN PLAN-AND-EXECUTE                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                         ‚îÇ
‚îÇ                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                              ‚îÇ
‚îÇ                        ‚îÇ   USER INPUT    ‚îÇ                              ‚îÇ
‚îÇ                        ‚îÇ   "Objetivo"    ‚îÇ                              ‚îÇ
‚îÇ                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                              ‚îÇ
‚îÇ                                 ‚îÇ                                       ‚îÇ
‚îÇ                                 ‚ñº                                       ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                      FASE 1: PLANIFICACI√ìN                       ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ  ANALIZAR  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  DESCOMPONER   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   ORDENAR    ‚îÇ    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ  Objetivo  ‚îÇ     ‚îÇ  en pasos      ‚îÇ     ‚îÇ   pasos      ‚îÇ    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                      ‚îÇ           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                      ‚ñº           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                              ‚îÇ    PLAN      ‚îÇ    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                              ‚îÇ  1. Paso A   ‚îÇ    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                              ‚îÇ  2. Paso B   ‚îÇ    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                              ‚îÇ  3. Paso C   ‚îÇ    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                 ‚îÇ                                       ‚îÇ
‚îÇ                                 ‚ñº                                       ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                          ‚îÇ
‚îÇ                    ‚îÇ   ¬øUsuario aprueba?    ‚îÇ                          ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                          ‚îÇ
‚îÇ                                ‚îÇ S√≠                                     ‚îÇ
‚îÇ                                ‚ñº                                       ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                      FASE 2: EJECUCI√ìN                           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ      ‚îÇ PASO 1  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ PASO 2  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ PASO 3  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ ...      ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ      ‚îÇEjecutar ‚îÇ     ‚îÇEjecutar ‚îÇ     ‚îÇEjecutar ‚îÇ                ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ           ‚îÇ               ‚îÇ               ‚îÇ                      ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ           ‚ñº               ‚ñº               ‚ñº                      ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ      [Resultado]    [Resultado]    [Resultado]                  ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                 ‚îÇ                                       ‚îÇ
‚îÇ                                 ‚ñº                                       ‚îÇ
‚îÇ                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                              ‚îÇ
‚îÇ                        ‚îÇ RESULTADO FINAL ‚îÇ                              ‚îÇ
‚îÇ                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                              ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Comparaci√≥n: ReAct vs Plan-and-Execute

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ReAct vs PLAN-AND-EXECUTE                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                        ‚îÇ
‚îÇ  ReAct (Intercalado)                                                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇThought ‚îÇ‚Üí‚îÇAction 1‚îÇ‚Üí‚îÇ Obs 1  ‚îÇ‚Üí‚îÇThought ‚îÇ‚Üí‚îÇAction 2‚îÇ‚Üí‚îÇ Obs 2  ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ  ‚úÖ Adaptativo        ‚ùå Re-planifica constantemente                   ‚îÇ
‚îÇ  ‚úÖ Flexible          ‚ùå Puede perder el objetivo                      ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  Plan-and-Execute (Separado)                                           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ         PLANIFICAR          ‚îÇ  ‚îÇ          EJECUTAR              ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ 1 ‚îÇ‚Üí‚îÇ 2 ‚îÇ‚Üí‚îÇ 3 ‚îÇ‚Üí‚îÇ 4 ‚îÇ   ‚îÇ  ‚îÇ  ‚îÇ 1 ‚îÇ‚Üí‚îÇ 2 ‚îÇ‚Üí‚îÇ 3 ‚îÇ‚Üí‚îÇ 4 ‚îÇ     ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ  ‚úÖ Plan coherente     ‚úÖ Ejecuci√≥n enfocada                          ‚îÇ
‚îÇ  ‚úÖ Revisable          ‚ùå Menos adaptativo                            ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n del Patr√≥n

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Optional, Callable, Any
from enum import Enum, auto
import json
import os

class PlanStatus(Enum):
    DRAFT = auto()
    APPROVED = auto()
    EXECUTING = auto()
    COMPLETED = auto()
    FAILED = auto()
    NEEDS_REVISION = auto()

@dataclass
class PlanStep:
    """Un paso individual del plan."""
    id: int
    description: str
    tool_to_use: Optional[str] = None
    expected_output: str = ""
    status: str = "pending"  # pending, executing, completed, failed
    result: Optional[Any] = None

@dataclass
class ExecutionPlan:
    """Plan completo de ejecuci√≥n."""
    goal: str
    steps: list[PlanStep] = field(default_factory=list)
    status: PlanStatus = PlanStatus.DRAFT
    current_step: int = 0
    context: dict = field(default_factory=dict)

    def get_progress(self) -> str:
        """Retorna progreso del plan."""
        completed = sum(1 for s in self.steps if s.status == "completed")
        return f"{completed}/{len(self.steps)} pasos completados"


class Planner:
    """
    Componente encargado de crear planes de ejecuci√≥n.
    """

    PLANNING_PROMPT = """Eres un planificador experto. Tu trabajo es crear planes de acci√≥n claros y ejecutables.

OBJETIVO DEL USUARIO:
{goal}

HERRAMIENTAS DISPONIBLES:
{tools_description}

CONTEXTO ADICIONAL:
{context}

Crea un plan paso a paso para lograr el objetivo. Cada paso debe ser:
- Espec√≠fico y accionable
- Usar una herramienta disponible cuando sea apropiado
- Tener un resultado esperado claro

Responde en formato JSON:
{{
    "analysis": "Breve an√°lisis del objetivo y enfoque",
    "steps": [
        {{
            "id": 1,
            "description": "Descripci√≥n clara del paso",
            "tool_to_use": "nombre_de_herramienta o null",
            "expected_output": "Qu√© se espera obtener"
        }},
        ...
    ],
    "estimated_steps": n√∫mero_total_de_pasos,
    "potential_challenges": ["desaf√≠o 1", "desaf√≠o 2"]
}}

IMPORTANTE:
- Mant√©n el plan conciso (5-10 pasos m√°ximo)
- Ordena los pasos l√≥gicamente
- Identifica qu√© herramienta usar en cada paso

Responde SOLO con el JSON."""

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)
        self.available_tools: dict[str, str] = {}

    def register_tool(self, name: str, description: str):
        """Registra una herramienta disponible."""
        self.available_tools[name] = description

    def create_plan(self, goal: str, context: dict = None) -> ExecutionPlan:
        """
        Crea un plan de ejecuci√≥n para el objetivo dado.
        """
        tools_desc = "\n".join([
            f"- {name}: {desc}" for name, desc in self.available_tools.items()
        ])

        prompt = self.PLANNING_PROMPT.format(
            goal=goal,
            tools_description=tools_desc or "No hay herramientas espec√≠ficas disponibles",
            context=json.dumps(context) if context else "Sin contexto adicional"
        )

        response = self.model.generate_content(prompt)
        plan_data = self._parse_plan(response.text)

        # Crear el plan
        plan = ExecutionPlan(goal=goal, context=context or {})

        for step_data in plan_data.get("steps", []):
            step = PlanStep(
                id=step_data.get("id", len(plan.steps) + 1),
                description=step_data.get("description", ""),
                tool_to_use=step_data.get("tool_to_use"),
                expected_output=step_data.get("expected_output", "")
            )
            plan.steps.append(step)

        return plan

    def _parse_plan(self, response: str) -> dict:
        """Parsea la respuesta del modelo."""
        try:
            text = response.strip()
            if text.startswith("```"):
                text = text.split("```")[1]
                if text.startswith("json"):
                    text = text[4:]
            return json.loads(text)
        except json.JSONDecodeError:
            return {"steps": []}


class Executor:
    """
    Componente encargado de ejecutar los planes.
    """

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)
        self.tools: dict[str, Callable] = {}

    def register_tool(self, name: str, func: Callable):
        """Registra una herramienta ejecutable."""
        self.tools[name] = func

    def execute_plan(self, plan: ExecutionPlan, on_step_complete: Callable = None) -> ExecutionPlan:
        """
        Ejecuta un plan aprobado paso a paso.
        """
        if plan.status != PlanStatus.APPROVED:
            raise ValueError("El plan debe estar aprobado antes de ejecutar")

        plan.status = PlanStatus.EXECUTING
        accumulated_context = dict(plan.context)

        print(f"\n{'='*60}")
        print(f"EJECUTANDO PLAN: {plan.goal}")
        print(f"{'='*60}\n")

        for i, step in enumerate(plan.steps):
            plan.current_step = i + 1
            step.status = "executing"

            print(f"[{i+1}/{len(plan.steps)}] {step.description}")

            try:
                # Ejecutar el paso
                result = self._execute_step(step, accumulated_context)
                step.result = result
                step.status = "completed"

                # Actualizar contexto
                accumulated_context[f"step_{step.id}_result"] = result

                print(f"    ‚úÖ Completado: {str(result)[:100]}...")

                # Callback opcional
                if on_step_complete:
                    on_step_complete(step, result)

            except Exception as e:
                step.status = "failed"
                step.result = f"Error: {str(e)}"
                print(f"    ‚ùå Error: {e}")

                # Decidir si continuar o abortar
                if not self._should_continue_after_error(plan, step, e):
                    plan.status = PlanStatus.FAILED
                    return plan

        plan.status = PlanStatus.COMPLETED
        print(f"\n‚úÖ Plan completado: {plan.get_progress()}")
        return plan

    def _execute_step(self, step: PlanStep, context: dict) -> Any:
        """Ejecuta un paso individual."""

        # Si hay una herramienta espec√≠fica, usarla
        if step.tool_to_use and step.tool_to_use in self.tools:
            tool_func = self.tools[step.tool_to_use]
            return tool_func(step.description, context)

        # Sino, usar el LLM para ejecutar
        return self._llm_execute(step, context)

    def _llm_execute(self, step: PlanStep, context: dict) -> str:
        """Ejecuta un paso usando el LLM."""
        prompt = f"""Ejecuta el siguiente paso:

PASO: {step.description}
RESULTADO ESPERADO: {step.expected_output}

CONTEXTO (resultados anteriores):
{json.dumps(context, indent=2)}

Proporciona el resultado de ejecutar este paso.
S√© conciso pero completo."""

        response = self.model.generate_content(prompt)
        return response.text

    def _should_continue_after_error(
        self,
        plan: ExecutionPlan,
        failed_step: PlanStep,
        error: Exception
    ) -> bool:
        """Decide si continuar despu√©s de un error."""
        # Por defecto, continuar si el paso no es cr√≠tico
        critical_keywords = ["inicial", "setup", "configurar", "autenticar"]
        return not any(kw in failed_step.description.lower()
                      for kw in critical_keywords)


class PlanAndExecuteAgent:
    """
    Agente completo que implementa el patr√≥n Plan-and-Execute.
    """

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        self.planner = Planner(model_name)
        self.executor = Executor(model_name)
        self.current_plan: Optional[ExecutionPlan] = None

    def register_tool(self, name: str, description: str, func: Callable):
        """Registra una herramienta en planner y executor."""
        self.planner.register_tool(name, description)
        self.executor.register_tool(name, func)

    def run(
        self,
        goal: str,
        context: dict = None,
        auto_approve: bool = False
    ) -> ExecutionPlan:
        """
        Ejecuta el flujo completo de plan-and-execute.
        """
        # Fase 1: Planificaci√≥n
        print("\n" + "="*60)
        print("FASE 1: PLANIFICACI√ìN")
        print("="*60)

        self.current_plan = self.planner.create_plan(goal, context)
        self._display_plan(self.current_plan)

        # Aprobaci√≥n
        if not auto_approve:
            if not self._get_approval():
                print("Plan rechazado por el usuario.")
                return self.current_plan
        else:
            print("\n[Auto-aprobaci√≥n activada]")

        self.current_plan.status = PlanStatus.APPROVED

        # Fase 2: Ejecuci√≥n
        print("\n" + "="*60)
        print("FASE 2: EJECUCI√ìN")
        print("="*60)

        self.current_plan = self.executor.execute_plan(
            self.current_plan,
            on_step_complete=self._on_step_complete
        )

        return self.current_plan

    def _display_plan(self, plan: ExecutionPlan):
        """Muestra el plan al usuario."""
        print(f"\nüìã PLAN PARA: {plan.goal}")
        print("-" * 50)
        for step in plan.steps:
            tool_info = f" [tool: {step.tool_to_use}]" if step.tool_to_use else ""
            print(f"  {step.id}. {step.description}{tool_info}")
            print(f"     ‚Üí Espera: {step.expected_output}")
        print("-" * 50)
        print(f"Total: {len(plan.steps)} pasos")

    def _get_approval(self) -> bool:
        """Solicita aprobaci√≥n del usuario."""
        print("\n¬øAprobar este plan? (s/n/modificar): ", end="")
        # En producci√≥n, esto ser√≠a input real
        # Por ahora, auto-aprobar
        return True

    def _on_step_complete(self, step: PlanStep, result: Any):
        """Callback cuando se completa un paso."""
        # Hook para logging, m√©tricas, etc.
        pass
```

## Ejemplo Completo: Agente de Investigaci√≥n

```python
import requests

# Crear el agente
agent = PlanAndExecuteAgent()

# Definir herramientas
def search_web(query: str, context: dict) -> str:
    """Busca informaci√≥n en la web."""
    # Simulado - en producci√≥n usar√≠as una API real
    url = f"https://es.wikipedia.org/api/rest_v1/page/summary/{query.replace(' ', '_')}"
    try:
        resp = requests.get(url, timeout=10)
        if resp.status_code == 200:
            return resp.json().get("extract", "No encontrado")[:500]
    except:
        pass
    return f"Informaci√≥n sobre {query}: [datos simulados]"

def analyze_data(description: str, context: dict) -> str:
    """Analiza datos del contexto."""
    relevant_data = [v for k, v in context.items() if "result" in k]
    return f"An√°lisis de {len(relevant_data)} fuentes: Encontrado contenido relevante"

def write_summary(description: str, context: dict) -> str:
    """Escribe un resumen de los hallazgos."""
    findings = [str(v)[:100] for k, v in context.items() if "result" in k]
    return f"RESUMEN: Basado en {len(findings)} hallazgos: {' | '.join(findings[:3])}"

# Registrar herramientas
agent.register_tool(
    "search_web",
    "Busca informaci√≥n en internet sobre un tema",
    search_web
)
agent.register_tool(
    "analyze_data",
    "Analiza y procesa datos recolectados",
    analyze_data
)
agent.register_tool(
    "write_summary",
    "Escribe un resumen de los hallazgos",
    write_summary
)

# Ejecutar
result = agent.run(
    goal="Investigar sobre los avances recientes en energ√≠a solar y crear un resumen ejecutivo",
    auto_approve=True
)

# Mostrar resultados
print("\n" + "="*60)
print("RESULTADOS FINALES")
print("="*60)
print(f"Estado: {result.status.name}")
print(f"Progreso: {result.get_progress()}")

print("\nResultados por paso:")
for step in result.steps:
    print(f"\n{step.id}. {step.description}")
    print(f"   Estado: {step.status}")
    if step.result:
        print(f"   Resultado: {str(step.result)[:200]}...")
```

## Variante: Plan-and-Execute con Revisi√≥n

```python
class AdaptivePlanAndExecute(PlanAndExecuteAgent):
    """
    Variante que permite revisar y adaptar el plan durante la ejecuci√≥n.
    """

    REVISION_PROMPT = """Analiza si el plan actual necesita ajustes.

PLAN ORIGINAL:
{plan_steps}

PROGRESO ACTUAL:
- Pasos completados: {completed}
- Paso actual: {current_step}
- Resultados hasta ahora: {results}

ERROR O SITUACI√ìN:
{situation}

¬øEl plan necesita ajustes?
Responde en JSON:
{{
    "needs_revision": true/false,
    "reason": "explicaci√≥n",
    "suggested_changes": [
        {{"action": "add|remove|modify", "step_id": N, "new_description": "..."}}
    ]
}}"""

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        super().__init__(model_name)
        self.revision_threshold = 2  # Revisar cada N errores

    def execute_with_revision(
        self,
        goal: str,
        context: dict = None
    ) -> ExecutionPlan:
        """Ejecuta con capacidad de revisi√≥n del plan."""
        error_count = 0

        # Planificaci√≥n inicial
        self.current_plan = self.planner.create_plan(goal, context)
        self._display_plan(self.current_plan)
        self.current_plan.status = PlanStatus.APPROVED

        accumulated_context = dict(context or {})

        for i, step in enumerate(self.current_plan.steps):
            print(f"\n[Paso {i+1}/{len(self.current_plan.steps)}] {step.description}")

            try:
                result = self.executor._execute_step(step, accumulated_context)
                step.result = result
                step.status = "completed"
                accumulated_context[f"step_{step.id}_result"] = result
                print(f"  ‚úÖ {str(result)[:100]}")

            except Exception as e:
                step.status = "failed"
                error_count += 1
                print(f"  ‚ùå Error: {e}")

                # Verificar si necesita revisi√≥n
                if error_count >= self.revision_threshold:
                    print("\nüîÑ Verificando si el plan necesita revisi√≥n...")
                    revised = self._maybe_revise_plan(
                        self.current_plan,
                        i,
                        accumulated_context,
                        str(e)
                    )
                    if revised:
                        print("  Plan actualizado, continuando...")
                        error_count = 0

        self.current_plan.status = PlanStatus.COMPLETED
        return self.current_plan

    def _maybe_revise_plan(
        self,
        plan: ExecutionPlan,
        current_idx: int,
        context: dict,
        error: str
    ) -> bool:
        """Eval√∫a y posiblemente revisa el plan."""

        plan_steps = "\n".join([
            f"{s.id}. {s.description} [{s.status}]"
            for s in plan.steps
        ])

        completed = sum(1 for s in plan.steps if s.status == "completed")
        results = {k: str(v)[:100] for k, v in context.items() if "result" in k}

        prompt = self.REVISION_PROMPT.format(
            plan_steps=plan_steps,
            completed=completed,
            current_step=current_idx + 1,
            results=json.dumps(results),
            situation=error
        )

        response = self.planner.model.generate_content(prompt)

        try:
            text = response.text.strip()
            if text.startswith("```"):
                text = text.split("```")[1]
                if text.startswith("json"):
                    text = text[4:]
            revision = json.loads(text)

            if revision.get("needs_revision"):
                self._apply_revision(plan, revision)
                return True

        except json.JSONDecodeError:
            pass

        return False

    def _apply_revision(self, plan: ExecutionPlan, revision: dict):
        """Aplica las revisiones sugeridas al plan."""
        for change in revision.get("suggested_changes", []):
            action = change.get("action")
            step_id = change.get("step_id")

            if action == "add":
                new_step = PlanStep(
                    id=len(plan.steps) + 1,
                    description=change.get("new_description", "")
                )
                plan.steps.append(new_step)
                print(f"  + Agregado paso: {new_step.description[:50]}")

            elif action == "remove" and step_id:
                plan.steps = [s for s in plan.steps if s.id != step_id]
                print(f"  - Eliminado paso {step_id}")

            elif action == "modify" and step_id:
                for step in plan.steps:
                    if step.id == step_id:
                        step.description = change.get("new_description", step.description)
                        print(f"  ~ Modificado paso {step_id}")
                        break


# Uso
adaptive_agent = AdaptivePlanAndExecute()
adaptive_agent.register_tool("search_web", "Busca en internet", search_web)
adaptive_agent.register_tool("analyze_data", "Analiza datos", analyze_data)

result = adaptive_agent.execute_with_revision(
    goal="Crear un an√°lisis comparativo de tres tecnolog√≠as de almacenamiento de energ√≠a"
)
```

## Errores Comunes y Soluciones

### 1. Planes Demasiado Abstractos

```python
# ‚ùå MAL: Pasos vagos
steps = [
    "Investigar el tema",  # ¬øQu√© aspecto? ¬øC√≥mo?
    "Analizar la informaci√≥n",  # ¬øQu√© informaci√≥n?
    "Concluir"  # ¬øQu√© tipo de conclusi√≥n?
]

# ‚úÖ BIEN: Pasos espec√≠ficos y accionables
steps = [
    "Buscar datos de mercado solar 2024 usando search_web",
    "Extraer cifras de crecimiento del resultado anterior",
    "Comparar con proyecciones de 2023 del contexto",
    "Generar tabla comparativa a√±o a a√±o",
    "Escribir conclusi√≥n con tendencias identificadas"
]
```

### 2. Sin Manejo de Errores

```python
# ‚ùå MAL: Asumir que todo funciona
for step in plan.steps:
    result = execute(step)  # ¬øQu√© si falla?

# ‚úÖ BIEN: Estrategias de manejo de errores
class ResilientExecutor(Executor):
    def execute_step_with_retry(self, step, context, max_retries=3):
        for attempt in range(max_retries):
            try:
                return self._execute_step(step, context)
            except Exception as e:
                if attempt == max_retries - 1:
                    # Intentar paso alternativo
                    return self._try_alternative(step, context, e)
                print(f"  Reintento {attempt + 1}...")
```

### 3. Plan Est√°tico Ante Cambios

```python
# ‚ùå MAL: Ignorar nueva informaci√≥n
# El paso 3 revel√≥ que el enfoque es incorrecto, pero se contin√∫a

# ‚úÖ BIEN: Checkpoints de validaci√≥n
def execute_with_checkpoints(self, plan):
    checkpoints = [len(plan.steps) // 2, len(plan.steps) - 1]

    for i, step in enumerate(plan.steps):
        result = self.execute_step(step)

        if i in checkpoints:
            if not self._validate_progress(plan, i):
                print("‚ö†Ô∏è  Progreso insuficiente, revisando plan...")
                return self._revise_and_continue(plan, i)

    return plan
```

## Aplicaciones del Patr√≥n

| Aplicaci√≥n | Fase de Plan | Fase de Ejecuci√≥n |
|------------|--------------|-------------------|
| CI/CD | Definir stages del pipeline | Ejecutar cada stage |
| Migraci√≥n de datos | Mapear esquemas, definir orden | Migrar tabla por tabla |
| Research | Definir preguntas, fuentes | Buscar, analizar, sintetizar |
| Onboarding | Lista de tareas de setup | Completar cada tarea |
| Testing | Definir casos de prueba | Ejecutar y validar |

## Resumen

El patr√≥n **Plan-and-Execute** separa planificaci√≥n de ejecuci√≥n:

**Fase 1: Planificaci√≥n**
1. Analizar el objetivo
2. Descomponer en pasos
3. Ordenar y asignar herramientas
4. Obtener aprobaci√≥n

**Fase 2: Ejecuci√≥n**
1. Ejecutar paso por paso
2. Acumular contexto
3. Manejar errores
4. Opcionalmente revisar el plan

**Ventajas**:
- Transparencia y control para el usuario
- Eficiencia al evitar re-planificaci√≥n constante
- Facilita debugging
- Permite revisi√≥n humana

**Cu√°ndo usar**:
- Tareas con m√∫ltiples pasos dependientes
- Cuando se necesita aprobaci√≥n del usuario
- Procesos que requieren trazabilidad
- Cuando los errores son costosos

---

## Navegaci√≥n

- **Anterior**: [4.2.1 Task Decomposition Autom√°tica](./4.2.1-task-decomposition.md)
- **Siguiente**: [4.2.3 Replanificaci√≥n Din√°mica](./4.2.3-replanificacion-dinamica.md)
- **√çndice**: [README del Curso](../../README.md)
