# 4.2.3 Replanificaci√≥n Din√°mica

## Tiempo estimado: 75 minutos
## Nivel: Avanzado

## Prerrequisitos
- Plan-and-Execute Pattern (4.2.2)
- Task Decomposition (4.2.1)
- Condiciones de Terminaci√≥n (4.1.3)

## ¬øPor qu√© es importante?

La **replanificaci√≥n din√°mica** permite a los agentes adaptarse cuando:
- El plan original ya no es viable
- Se descubre nueva informaci√≥n relevante
- Las condiciones del entorno cambian
- Ocurren errores inesperados

Un agente que no puede replanificar est√° condenado a fallar ante cualquier situaci√≥n imprevista.

## Arquitectura de Replanificaci√≥n

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SISTEMA DE REPLANIFICACI√ìN DIN√ÅMICA                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    EJECUCI√ìN DEL PLAN                            ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îÇPaso1‚îÇ‚îÄ‚îÄ‚ñ∂‚îÇPaso2‚îÇ‚îÄ‚îÄ‚ñ∂‚îÇPaso3‚îÇ‚îÄ‚îÄ‚ñ∂‚îÇPaso4‚îÇ‚îÄ‚îÄ‚ñ∂‚îÇPaso5‚îÇ              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ      ‚îÇ         ‚îÇ         ‚îÇ         ‚îÇ                            ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ      ‚ñº         ‚ñº         ‚ñº         ‚ñº                            ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   [OK]      [OK]     [ERROR]    [???]                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                          ‚îÇ                                       ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                              ‚îÇ                                          ‚îÇ
‚îÇ                              ‚ñº                                          ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    MONITOR DE EJECUCI√ìN                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   Detecta:                                                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Errores de ejecuci√≥n                                         ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Nueva informaci√≥n contradictoria                             ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Desviaci√≥n del objetivo                                      ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Oportunidades de optimizaci√≥n                                ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                    DECISOR DE REPLANIFICACI√ìN                    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                     ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ¬øReplanificar?‚îÇ‚îÄ‚îÄ‚ñ∂‚îÇ Tipo de cambio  ‚îÇ                     ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                     ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ            ‚îÇ                      ‚îÇ                              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                     ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ     ‚ñº      ‚ñº                      ‚ñº       ‚ñº                     ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   [NO]  [MINOR]              [MAJOR]  [ABORT]                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ    ‚îÇ    Ajustar              Nuevo     Detener                  ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ    ‚îÇ    paso                 plan      todo                     ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ    ‚îÇ    actual               completo                           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ    ‚ñº                                                             ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ Continuar                                                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Triggers de Replanificaci√≥n

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    EVENTOS QUE DISPARAN REPLANIFICACI√ìN                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                        ‚îÇ
‚îÇ  1. ERRORES DE EJECUCI√ìN                                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Herramienta no disponible o fallando                           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Timeout excedido                                                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Datos de entrada inv√°lidos                                      ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Resultado no esperado                                           ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  2. NUEVA INFORMACI√ìN                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Descubrimiento que invalida supuestos                          ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Cambio en los requisitos del usuario                           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Datos m√°s recientes disponibles                                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Feedback del usuario                                            ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  3. M√âTRICAS DE RENDIMIENTO                                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Progreso m√°s lento de lo esperado                              ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Consumo excesivo de recursos                                   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ M√∫ltiples reintentos fallidos                                  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Confianza decreciente                                          ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  4. OPORTUNIDADES                                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Camino m√°s corto descubierto                                   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Herramienta m√°s eficiente disponible                           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Pasos que se pueden paralelizar                                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Resultados parciales que permiten saltar pasos                 ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n del Sistema

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Optional, Callable, Any
from enum import Enum, auto
import json
import time
import os

class ReplanTrigger(Enum):
    """Razones para disparar replanificaci√≥n."""
    STEP_FAILED = auto()
    NEW_INFO = auto()
    GOAL_DRIFT = auto()
    RESOURCE_EXCEEDED = auto()
    OPPORTUNITY = auto()
    USER_REQUEST = auto()
    STUCK = auto()

class ReplanAction(Enum):
    """Acciones posibles de replanificaci√≥n."""
    CONTINUE = auto()      # No cambios
    RETRY = auto()         # Reintentar paso actual
    MODIFY_STEP = auto()   # Modificar paso actual
    SKIP_STEP = auto()     # Saltar al siguiente
    ADD_STEPS = auto()     # Agregar pasos
    REMOVE_STEPS = auto()  # Eliminar pasos
    FULL_REPLAN = auto()   # Replanificar completamente
    ABORT = auto()         # Abortar ejecuci√≥n

@dataclass
class ReplanDecision:
    """Decisi√≥n de replanificaci√≥n."""
    action: ReplanAction
    trigger: ReplanTrigger
    reasoning: str
    changes: list[dict] = field(default_factory=list)
    confidence: float = 0.5

@dataclass
class ExecutionState:
    """Estado actual de la ejecuci√≥n."""
    current_step: int
    completed_steps: list[dict]
    failed_steps: list[dict]
    context: dict
    elapsed_time: float
    tokens_used: int
    error_count: int

@dataclass
class PlanStep:
    """Paso del plan."""
    id: int
    description: str
    status: str = "pending"
    result: Any = None
    attempts: int = 0

@dataclass
class Plan:
    """Plan de ejecuci√≥n."""
    goal: str
    steps: list[PlanStep]
    version: int = 1


class ReplanningMonitor:
    """
    Monitorea la ejecuci√≥n y detecta necesidad de replanificaci√≥n.
    """

    def __init__(self):
        self.thresholds = {
            "max_retries": 3,
            "max_errors": 5,
            "max_time_per_step": 60,  # segundos
            "min_confidence": 0.3,
            "token_budget": 10000
        }
        self.history: list[ExecutionState] = []

    def should_replan(self, state: ExecutionState, error: Exception = None) -> Optional[ReplanTrigger]:
        """
        Eval√∫a si se debe replanificar basado en el estado actual.
        """
        self.history.append(state)

        # 1. Error de ejecuci√≥n
        if error:
            return ReplanTrigger.STEP_FAILED

        # 2. Demasiados errores acumulados
        if state.error_count >= self.thresholds["max_errors"]:
            return ReplanTrigger.STUCK

        # 3. Recursos excedidos
        if state.tokens_used >= self.thresholds["token_budget"]:
            return ReplanTrigger.RESOURCE_EXCEEDED

        # 4. Estancamiento (sin progreso)
        if self._detect_stagnation():
            return ReplanTrigger.STUCK

        return None

    def _detect_stagnation(self) -> bool:
        """Detecta si la ejecuci√≥n est√° estancada."""
        if len(self.history) < 3:
            return False

        # Verificar si el progreso est√° estancado
        recent = self.history[-3:]
        steps = [h.current_step for h in recent]
        return len(set(steps)) == 1  # Mismo paso 3 veces


class ReplanningDecider:
    """
    Decide qu√© tipo de replanificaci√≥n realizar.
    """

    DECISION_PROMPT = """Eres un experto en planificaci√≥n de agentes. Analiza la situaci√≥n y decide c√≥mo proceder.

OBJETIVO ORIGINAL:
{goal}

PLAN ACTUAL:
{plan_steps}

ESTADO DE EJECUCI√ìN:
- Paso actual: {current_step}
- Pasos completados: {completed}
- Pasos fallidos: {failed}
- Errores totales: {error_count}

TRIGGER DE REPLANIFICACI√ìN:
{trigger}

ERROR/SITUACI√ìN:
{situation}

CONTEXTO ACUMULADO:
{context}

Decide la mejor acci√≥n:
1. CONTINUE - Continuar sin cambios (el error es menor)
2. RETRY - Reintentar el paso actual con mismo enfoque
3. MODIFY_STEP - Modificar el paso actual
4. SKIP_STEP - Saltar este paso (no es cr√≠tico)
5. ADD_STEPS - Agregar pasos intermedios necesarios
6. REMOVE_STEPS - Eliminar pasos que ya no son necesarios
7. FULL_REPLAN - Crear un plan completamente nuevo
8. ABORT - Abortar la ejecuci√≥n (objetivo inalcanzable)

Responde en JSON:
{{
    "action": "CONTINUE|RETRY|MODIFY_STEP|SKIP_STEP|ADD_STEPS|REMOVE_STEPS|FULL_REPLAN|ABORT",
    "reasoning": "Explicaci√≥n de por qu√© elegiste esta acci√≥n",
    "confidence": 0.0-1.0,
    "changes": [
        {{"type": "modify|add|remove", "step_id": N, "new_description": "..."}}
    ]
}}

S√© conservador: prefiere CONTINUE o RETRY antes que cambios mayores."""

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)

    def decide(
        self,
        plan: Plan,
        state: ExecutionState,
        trigger: ReplanTrigger,
        error: str = ""
    ) -> ReplanDecision:
        """
        Decide qu√© acci√≥n de replanificaci√≥n tomar.
        """
        plan_steps = "\n".join([
            f"{s.id}. {s.description} [{s.status}]"
            for s in plan.steps
        ])

        completed = [d["step"] for d in state.completed_steps]
        failed = [d["step"] for d in state.failed_steps]

        prompt = self.DECISION_PROMPT.format(
            goal=plan.goal,
            plan_steps=plan_steps,
            current_step=state.current_step,
            completed=completed,
            failed=failed,
            error_count=state.error_count,
            trigger=trigger.name,
            situation=error or "Sin error espec√≠fico",
            context=json.dumps(state.context, indent=2)[:500]
        )

        response = self.model.generate_content(prompt)
        return self._parse_decision(response.text, trigger)

    def _parse_decision(self, response: str, trigger: ReplanTrigger) -> ReplanDecision:
        """Parsea la respuesta del modelo."""
        try:
            text = response.strip()
            if text.startswith("```"):
                text = text.split("```")[1]
                if text.startswith("json"):
                    text = text[4:]

            data = json.loads(text)

            action_map = {
                "CONTINUE": ReplanAction.CONTINUE,
                "RETRY": ReplanAction.RETRY,
                "MODIFY_STEP": ReplanAction.MODIFY_STEP,
                "SKIP_STEP": ReplanAction.SKIP_STEP,
                "ADD_STEPS": ReplanAction.ADD_STEPS,
                "REMOVE_STEPS": ReplanAction.REMOVE_STEPS,
                "FULL_REPLAN": ReplanAction.FULL_REPLAN,
                "ABORT": ReplanAction.ABORT
            }

            return ReplanDecision(
                action=action_map.get(data.get("action", "CONTINUE"), ReplanAction.CONTINUE),
                trigger=trigger,
                reasoning=data.get("reasoning", ""),
                changes=data.get("changes", []),
                confidence=float(data.get("confidence", 0.5))
            )

        except (json.JSONDecodeError, KeyError):
            # Fallback conservador
            return ReplanDecision(
                action=ReplanAction.RETRY,
                trigger=trigger,
                reasoning="Error parseando decisi√≥n, reintentando",
                confidence=0.3
            )


class DynamicReplanningAgent:
    """
    Agente con capacidad de replanificaci√≥n din√°mica.
    """

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)
        self.monitor = ReplanningMonitor()
        self.decider = ReplanningDecider(model_name)
        self.tools: dict[str, Callable] = {}
        self.replan_history: list[ReplanDecision] = []

    def register_tool(self, name: str, func: Callable):
        """Registra una herramienta."""
        self.tools[name] = func

    def create_initial_plan(self, goal: str) -> Plan:
        """Crea el plan inicial."""
        prompt = f"""Crea un plan paso a paso para: {goal}

Responde en JSON:
{{"steps": [{{"id": 1, "description": "..."}}]}}"""

        response = self.model.generate_content(prompt)
        try:
            text = response.text
            if "```" in text:
                text = text.split("```")[1]
                if text.startswith("json"):
                    text = text[4:]
            data = json.loads(text)
            steps = [PlanStep(id=s["id"], description=s["description"])
                    for s in data.get("steps", [])]
        except:
            steps = [PlanStep(id=1, description=goal)]

        return Plan(goal=goal, steps=steps)

    def run(self, goal: str, max_replans: int = 3) -> dict:
        """
        Ejecuta el objetivo con replanificaci√≥n din√°mica.
        """
        plan = self.create_initial_plan(goal)
        replan_count = 0
        start_time = time.time()

        state = ExecutionState(
            current_step=0,
            completed_steps=[],
            failed_steps=[],
            context={},
            elapsed_time=0,
            tokens_used=0,
            error_count=0
        )

        print(f"\n{'='*60}")
        print(f"üéØ OBJETIVO: {goal}")
        print(f"{'='*60}")
        self._print_plan(plan)

        step_idx = 0
        while step_idx < len(plan.steps):
            step = plan.steps[step_idx]
            state.current_step = step_idx + 1
            state.elapsed_time = time.time() - start_time

            print(f"\n[Paso {step.id}] {step.description}")
            step.attempts += 1

            try:
                # Ejecutar paso
                result = self._execute_step(step, state.context)
                step.result = result
                step.status = "completed"

                state.completed_steps.append({"step": step.id, "result": result})
                state.context[f"step_{step.id}"] = result

                print(f"  ‚úÖ Completado: {str(result)[:100]}")
                step_idx += 1

            except Exception as e:
                step.status = "failed"
                state.error_count += 1
                state.failed_steps.append({"step": step.id, "error": str(e)})

                print(f"  ‚ùå Error: {e}")

                # Verificar si necesita replanificaci√≥n
                trigger = self.monitor.should_replan(state, e)

                if trigger and replan_count < max_replans:
                    print(f"\nüîÑ REPLANIFICACI√ìN #{replan_count + 1}")
                    print(f"   Trigger: {trigger.name}")

                    decision = self.decider.decide(plan, state, trigger, str(e))
                    self.replan_history.append(decision)

                    print(f"   Acci√≥n: {decision.action.name}")
                    print(f"   Raz√≥n: {decision.reasoning}")

                    # Aplicar decisi√≥n
                    plan, step_idx = self._apply_decision(plan, step_idx, decision)
                    replan_count += 1

                    if decision.action == ReplanAction.ABORT:
                        print("\nüõë Ejecuci√≥n abortada")
                        break

                else:
                    # Sin replanificaci√≥n, saltar paso
                    step_idx += 1

        return {
            "goal": goal,
            "final_plan": plan,
            "state": state,
            "replans": replan_count,
            "replan_history": self.replan_history,
            "success": all(s.status == "completed" for s in plan.steps)
        }

    def _execute_step(self, step: PlanStep, context: dict) -> str:
        """Ejecuta un paso."""
        # Buscar herramienta relevante
        for tool_name, tool_func in self.tools.items():
            if tool_name.lower() in step.description.lower():
                return tool_func(step.description, context)

        # Ejecuci√≥n por defecto con LLM
        prompt = f"""Ejecuta: {step.description}
Contexto: {json.dumps(context, indent=2)[:500]}
S√© conciso."""

        response = self.model.generate_content(prompt)
        return response.text

    def _apply_decision(
        self,
        plan: Plan,
        current_idx: int,
        decision: ReplanDecision
    ) -> tuple[Plan, int]:
        """Aplica la decisi√≥n de replanificaci√≥n."""

        if decision.action == ReplanAction.CONTINUE:
            return plan, current_idx + 1

        elif decision.action == ReplanAction.RETRY:
            # Resetear el paso para reintentar
            plan.steps[current_idx].status = "pending"
            return plan, current_idx

        elif decision.action == ReplanAction.SKIP_STEP:
            plan.steps[current_idx].status = "skipped"
            return plan, current_idx + 1

        elif decision.action == ReplanAction.MODIFY_STEP:
            for change in decision.changes:
                if change.get("type") == "modify":
                    step_id = change.get("step_id")
                    for step in plan.steps:
                        if step.id == step_id:
                            step.description = change.get("new_description", step.description)
                            step.status = "pending"
            return plan, current_idx

        elif decision.action == ReplanAction.ADD_STEPS:
            new_steps = []
            for change in decision.changes:
                if change.get("type") == "add":
                    new_step = PlanStep(
                        id=len(plan.steps) + len(new_steps) + 1,
                        description=change.get("new_description", "")
                    )
                    new_steps.append(new_step)

            # Insertar despu√©s del paso actual
            plan.steps = (plan.steps[:current_idx + 1] +
                         new_steps +
                         plan.steps[current_idx + 1:])
            plan.version += 1
            return plan, current_idx + 1

        elif decision.action == ReplanAction.REMOVE_STEPS:
            ids_to_remove = {c.get("step_id") for c in decision.changes
                           if c.get("type") == "remove"}
            plan.steps = [s for s in plan.steps if s.id not in ids_to_remove]
            plan.version += 1
            return plan, min(current_idx, len(plan.steps) - 1)

        elif decision.action == ReplanAction.FULL_REPLAN:
            new_plan = self.create_initial_plan(plan.goal)
            new_plan.version = plan.version + 1
            self._print_plan(new_plan)
            return new_plan, 0

        elif decision.action == ReplanAction.ABORT:
            return plan, len(plan.steps)  # Terminar

        return plan, current_idx + 1

    def _print_plan(self, plan: Plan):
        """Imprime el plan actual."""
        print(f"\nüìã Plan v{plan.version}:")
        for step in plan.steps:
            status_icon = {"pending": "‚¨ú", "completed": "‚úÖ",
                          "failed": "‚ùå", "skipped": "‚è≠Ô∏è"}.get(step.status, "‚¨ú")
            print(f"   {status_icon} {step.id}. {step.description[:60]}")
```

## Ejemplo Pr√°ctico

```python
import random

# Crear el agente
agent = DynamicReplanningAgent()

# Simular herramientas con posibles fallos
def unreliable_search(description: str, context: dict) -> str:
    """B√∫squeda que a veces falla."""
    if random.random() < 0.3:  # 30% de fallo
        raise Exception("API de b√∫squeda no disponible temporalmente")
    return f"Resultados de b√∫squeda para: {description[:30]}"

def unreliable_analysis(description: str, context: dict) -> str:
    """An√°lisis que a veces falla."""
    if random.random() < 0.2:  # 20% de fallo
        raise Exception("Datos insuficientes para an√°lisis")
    return f"An√°lisis completado: {len(context)} fuentes procesadas"

agent.register_tool("search", unreliable_search)
agent.register_tool("buscar", unreliable_search)
agent.register_tool("analyze", unreliable_analysis)
agent.register_tool("analizar", unreliable_analysis)

# Ejecutar con replanificaci√≥n
result = agent.run(
    goal="Investigar tendencias de IA en 2024 y crear un informe resumido",
    max_replans=5
)

# Mostrar resultados
print("\n" + "="*60)
print("RESUMEN DE EJECUCI√ìN")
print("="*60)
print(f"√âxito: {'‚úÖ' if result['success'] else '‚ùå'}")
print(f"Replanificaciones: {result['replans']}")
print(f"Errores totales: {result['state'].error_count}")

if result['replan_history']:
    print("\nHistorial de replanificaciones:")
    for i, replan in enumerate(result['replan_history'], 1):
        print(f"  {i}. {replan.action.name} - {replan.reasoning[:50]}...")
```

## Estrategias Avanzadas de Replanificaci√≥n

```python
class StrategicReplanner(DynamicReplanningAgent):
    """
    Agente con estrategias avanzadas de replanificaci√≥n.
    """

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        super().__init__(model_name)
        self.strategy = "conservative"  # conservative, aggressive, adaptive

    def set_strategy(self, strategy: str):
        """Configura la estrategia de replanificaci√≥n."""
        self.strategy = strategy
        self._configure_thresholds()

    def _configure_thresholds(self):
        """Ajusta umbrales seg√∫n la estrategia."""
        if self.strategy == "conservative":
            self.monitor.thresholds["max_retries"] = 5
            self.monitor.thresholds["max_errors"] = 10
        elif self.strategy == "aggressive":
            self.monitor.thresholds["max_retries"] = 2
            self.monitor.thresholds["max_errors"] = 3
        elif self.strategy == "adaptive":
            # Se ajusta din√°micamente
            pass

    def _adaptive_adjust(self, state: ExecutionState):
        """Ajusta umbrales adaptativamente."""
        if self.strategy != "adaptive":
            return

        success_rate = (len(state.completed_steps) /
                       max(1, len(state.completed_steps) + len(state.failed_steps)))

        if success_rate > 0.8:
            # Alto √©xito: ser m√°s conservador
            self.monitor.thresholds["max_retries"] = 4
        elif success_rate < 0.5:
            # Bajo √©xito: ser m√°s agresivo
            self.monitor.thresholds["max_retries"] = 2

    def run_with_strategy(self, goal: str, strategy: str = "adaptive") -> dict:
        """Ejecuta con una estrategia espec√≠fica."""
        self.set_strategy(strategy)
        print(f"üéöÔ∏è  Estrategia: {strategy}")
        return self.run(goal)
```

## Errores Comunes y Soluciones

### 1. Replanificaci√≥n Excesiva

```python
# ‚ùå MAL: Replanificar ante cualquier error
if error:
    replan()  # Muy agresivo

# ‚úÖ BIEN: Cooldown y umbral de severidad
class CooldownReplanner:
    def __init__(self):
        self.last_replan_time = 0
        self.cooldown_seconds = 10

    def should_replan(self, error):
        now = time.time()
        if now - self.last_replan_time < self.cooldown_seconds:
            return False  # Esperar cooldown

        if self.is_minor_error(error):
            return False  # Errores menores: reintentar

        self.last_replan_time = now
        return True
```

### 2. P√©rdida de Progreso

```python
# ‚ùå MAL: FULL_REPLAN que pierde todo el trabajo
decision = ReplanDecision(action=ReplanAction.FULL_REPLAN)
# Se pierden los resultados de pasos completados

# ‚úÖ BIEN: Preservar resultados √∫tiles
def full_replan_with_preservation(self, plan, state):
    # Guardar resultados de pasos exitosos
    preserved_context = {
        k: v for k, v in state.context.items()
        if "step_" in k
    }

    # Crear nuevo plan
    new_plan = self.create_initial_plan(plan.goal)

    # Marcar pasos ya completados si son similares
    for new_step in new_plan.steps:
        for completed in state.completed_steps:
            if self._steps_similar(new_step.description, completed):
                new_step.status = "completed"
                new_step.result = state.context.get(f"step_{completed['step']}")

    return new_plan
```

### 3. Oscilaci√≥n de Decisiones

```python
# ‚ùå MAL: ADD_STEPS ‚Üí REMOVE_STEPS ‚Üí ADD_STEPS...
# Causa: decisiones inconsistentes

# ‚úÖ BIEN: Tracking de decisiones para evitar oscilaci√≥n
class OscillationDetector:
    def __init__(self, window_size=5):
        self.recent_decisions = []
        self.window_size = window_size

    def is_oscillating(self, new_decision: ReplanDecision) -> bool:
        self.recent_decisions.append(new_decision.action)
        if len(self.recent_decisions) > self.window_size:
            self.recent_decisions.pop(0)

        # Detectar patr√≥n A-B-A-B
        if len(self.recent_decisions) >= 4:
            last_four = self.recent_decisions[-4:]
            if (last_four[0] == last_four[2] and
                last_four[1] == last_four[3] and
                last_four[0] != last_four[1]):
                return True

        return False
```

## Resumen

La **replanificaci√≥n din√°mica** permite a los agentes adaptarse a situaciones cambiantes:

**Triggers**:
- Errores de ejecuci√≥n
- Nueva informaci√≥n
- Desviaci√≥n del objetivo
- Oportunidades de optimizaci√≥n

**Acciones**:
1. **CONTINUE**: Sin cambios
2. **RETRY**: Reintentar paso
3. **MODIFY_STEP**: Ajustar paso actual
4. **SKIP_STEP**: Saltar paso no cr√≠tico
5. **ADD_STEPS**: Agregar pasos intermedios
6. **REMOVE_STEPS**: Eliminar pasos innecesarios
7. **FULL_REPLAN**: Nuevo plan completo
8. **ABORT**: Detener ejecuci√≥n

**Mejores pr√°cticas**:
- Usar cooldowns para evitar replanificaci√≥n excesiva
- Preservar progreso √∫til al replanificar
- Detectar y evitar oscilaciones
- Adaptar estrategia seg√∫n el contexto

---

## Navegaci√≥n

- **Anterior**: [4.2.2 Plan-and-Execute Pattern](./4.2.2-plan-execute-pattern.md)
- **Siguiente**: [4.3.1 Agente de Investigaci√≥n Web](../tema_4.3/4.3.1-agente-investigacion-web.md)
- **√çndice**: [README del Curso](../../README.md)
