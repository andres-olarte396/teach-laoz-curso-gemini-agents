# 4.1.1 Modelo ReAct (Reasoning + Acting)

## Tiempo estimado: 90 minutos
## Nivel: Intermedio-Avanzado

## Prerrequisitos
- M√≥dulo 3 completo (Function Calling)
- Comprensi√≥n de prompts de razonamiento (Chain of Thought)
- Familiaridad con async/await en Python

## ¬øPor qu√© es importante?

El modelo **ReAct** (Reasoning and Acting) representa un cambio paradigm√°tico en el dise√±o de agentes de IA. A diferencia de los enfoques tradicionales que separan el razonamiento de la acci√≥n, ReAct **intercala pensamientos y acciones** en un √∫nico flujo coherente.

> "ReAct permite que los agentes razonen sobre sus acciones y act√∫en bas√°ndose en su razonamiento, creando un ciclo virtuoso de mejora continua."

## Arquitectura del Modelo ReAct

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      MODELO ReAct                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                    PROMPT TEMPLATE                        ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ Contexto + Pregunta + Herramientas Disponibles      ‚îÇ ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                           ‚îÇ                                     ‚îÇ
‚îÇ                           ‚ñº                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                    CICLO ReAct                            ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                                                           ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   ‚îÇ  THOUGHT    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   ACTION    ‚îÇ                   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   ‚îÇ (Razonar)   ‚îÇ      ‚îÇ  (Actuar)   ‚îÇ                   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ          ‚ñ≤                    ‚îÇ                          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ          ‚îÇ                    ‚ñº                          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ          ‚îÇ             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ OBSERVATION ‚îÇ                   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                        ‚îÇ (Observar)  ‚îÇ                   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                   ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                           ‚îÇ                                     ‚îÇ
‚îÇ                           ‚ñº                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                  RESPUESTA FINAL                          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  Cuando el agente determina que tiene suficiente info    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Comparaci√≥n: ReAct vs Enfoques Tradicionales

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              COMPARACI√ìN DE PARADIGMAS DE AGENTES                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                    ‚îÇ
‚îÇ  CHAIN OF THOUGHT (Solo Razonamiento)                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ
‚îÇ  ‚îÇThought1‚îÇ‚Üí‚îÇThought2‚îÇ‚Üí‚îÇThought3‚îÇ‚Üí‚îÇThought4‚îÇ‚Üí‚îÇ Answer ‚îÇ           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ
‚îÇ  ‚ùå Sin acceso a informaci√≥n externa                               ‚îÇ
‚îÇ                                                                    ‚îÇ
‚îÇ  ACTION-ONLY (Solo Acci√≥n)                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îÇ
‚îÇ  ‚îÇAction 1‚îÇ‚Üí‚îÇ Obs 1  ‚îÇ‚Üí‚îÇAction 2‚îÇ‚Üí‚îÇ Obs 2  ‚îÇ‚Üí ...                 ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ
‚îÇ  ‚ùå Sin razonamiento expl√≠cito                                     ‚îÇ
‚îÇ                                                                    ‚îÇ
‚îÇ  ReAct (Razonamiento + Acci√≥n)                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇThought1‚îÇ‚Üí‚îÇAction 1‚îÇ‚Üí‚îÇ Obs 1  ‚îÇ‚Üí‚îÇThought2‚îÇ‚Üí‚îÇAction 2‚îÇ‚Üí‚îÇAnswer‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ  ‚úÖ Razonamiento informado por observaciones                       ‚îÇ
‚îÇ                                                                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n Base de ReAct con Gemini

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Callable, Any, Optional
from enum import Enum
import json
import re

class StepType(Enum):
    THOUGHT = "thought"
    ACTION = "action"
    OBSERVATION = "observation"
    FINAL_ANSWER = "final_answer"

@dataclass
class ReActStep:
    """Representa un paso en el ciclo ReAct."""
    step_type: StepType
    content: str
    tool_name: Optional[str] = None
    tool_args: Optional[dict] = None

@dataclass
class ReActTrace:
    """Traza completa de ejecuci√≥n del agente."""
    question: str
    steps: list[ReActStep] = field(default_factory=list)
    final_answer: Optional[str] = None

    def add_step(self, step: ReActStep):
        self.steps.append(step)
        if step.step_type == StepType.FINAL_ANSWER:
            self.final_answer = step.content

    def to_string(self) -> str:
        """Convierte la traza a formato de texto para el prompt."""
        lines = []
        for i, step in enumerate(self.steps, 1):
            if step.step_type == StepType.THOUGHT:
                lines.append(f"Thought {i}: {step.content}")
            elif step.step_type == StepType.ACTION:
                lines.append(f"Action {i}: {step.tool_name}[{json.dumps(step.tool_args)}]")
            elif step.step_type == StepType.OBSERVATION:
                lines.append(f"Observation {i}: {step.content}")
        return "\n".join(lines)


class ReActAgent:
    """
    Implementaci√≥n del modelo ReAct con Google Gemini.

    El agente intercala pasos de razonamiento (Thought) con acciones (Action)
    y observaciones (Observation) hasta llegar a una respuesta final.
    """

    REACT_PROMPT = """Eres un agente de razonamiento que usa el framework ReAct.
Para responder preguntas, debes intercalar Thoughts (pensamientos), Actions (acciones) y Observations (observaciones).

HERRAMIENTAS DISPONIBLES:
{tools_description}

FORMATO DE RESPUESTA:
- Thought: Razona sobre qu√© hacer a continuaci√≥n
- Action: nombre_herramienta[{{"param": "valor"}}]
- Observation: (ser√° proporcionada por el sistema)
- ... (repite el ciclo seg√∫n sea necesario)
- Final Answer: tu respuesta final al usuario

REGLAS:
1. Siempre comienza con un Thought
2. Despu√©s de cada Action, espera la Observation
3. Usa la informaci√≥n de las Observations para informar tus siguientes Thoughts
4. Cuando tengas suficiente informaci√≥n, proporciona Final Answer
5. S√© conciso pero completo en tus razonamientos

PREGUNTA: {question}

{trace}"""

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)
        self.tools: dict[str, Callable] = {}
        self.tools_description: dict[str, str] = {}
        self.max_iterations = 10

    def register_tool(
        self,
        name: str,
        func: Callable,
        description: str,
        parameters: dict
    ):
        """Registra una herramienta disponible para el agente."""
        self.tools[name] = func
        self.tools_description[name] = f"""
- {name}: {description}
  Par√°metros: {json.dumps(parameters, indent=2)}"""

    def _get_tools_description(self) -> str:
        """Genera la descripci√≥n de todas las herramientas."""
        return "\n".join(self.tools_description.values())

    def _parse_response(self, response: str) -> ReActStep:
        """Parsea la respuesta del modelo para extraer el paso."""
        response = response.strip()

        # Buscar Final Answer
        if "Final Answer:" in response:
            answer = response.split("Final Answer:")[-1].strip()
            return ReActStep(StepType.FINAL_ANSWER, answer)

        # Buscar Thought
        thought_match = re.search(r"Thought(?:\s*\d*)?:\s*(.+?)(?=Action|$)", response, re.DOTALL)
        if thought_match:
            thought = thought_match.group(1).strip()

            # Buscar Action despu√©s del Thought
            action_match = re.search(
                r"Action(?:\s*\d*)?:\s*(\w+)\[(.+?)\]",
                response
            )
            if action_match:
                tool_name = action_match.group(1)
                try:
                    tool_args = json.loads(action_match.group(2))
                except json.JSONDecodeError:
                    tool_args = {"query": action_match.group(2)}

                return ReActStep(
                    StepType.ACTION,
                    thought,
                    tool_name=tool_name,
                    tool_args=tool_args
                )

            return ReActStep(StepType.THOUGHT, thought)

        # Si no se puede parsear, tratar como pensamiento
        return ReActStep(StepType.THOUGHT, response)

    def _execute_action(self, step: ReActStep) -> str:
        """Ejecuta la acci√≥n y retorna la observaci√≥n."""
        if step.tool_name not in self.tools:
            return f"Error: Herramienta '{step.tool_name}' no encontrada"

        try:
            tool_func = self.tools[step.tool_name]
            result = tool_func(**step.tool_args)
            return str(result)
        except Exception as e:
            return f"Error ejecutando {step.tool_name}: {str(e)}"

    def run(self, question: str) -> ReActTrace:
        """
        Ejecuta el agente ReAct para responder una pregunta.

        Args:
            question: La pregunta o tarea a resolver

        Returns:
            ReActTrace con todos los pasos y la respuesta final
        """
        trace = ReActTrace(question=question)

        for iteration in range(self.max_iterations):
            # Construir el prompt con la traza actual
            prompt = self.REACT_PROMPT.format(
                tools_description=self._get_tools_description(),
                question=question,
                trace=trace.to_string() if trace.steps else "Comienza tu razonamiento:"
            )

            # Obtener respuesta del modelo
            response = self.model.generate_content(prompt)
            step = self._parse_response(response.text)

            # Procesar seg√∫n el tipo de paso
            if step.step_type == StepType.FINAL_ANSWER:
                trace.add_step(step)
                break

            elif step.step_type == StepType.ACTION:
                # Primero agregar el pensamiento
                trace.add_step(ReActStep(StepType.THOUGHT, step.content))
                # Luego la acci√≥n
                trace.add_step(step)
                # Ejecutar y agregar observaci√≥n
                observation = self._execute_action(step)
                trace.add_step(ReActStep(StepType.OBSERVATION, observation))

            else:
                trace.add_step(step)

        return trace
```

## Ejemplo Pr√°ctico: Agente de B√∫squeda

```python
import os
import requests
from datetime import datetime

# Herramientas para el agente
def search_wikipedia(query: str) -> str:
    """Busca informaci√≥n en Wikipedia."""
    url = "https://es.wikipedia.org/api/rest_v1/page/summary/"
    try:
        response = requests.get(url + query.replace(" ", "_"), timeout=10)
        if response.status_code == 200:
            data = response.json()
            return data.get("extract", "No se encontr√≥ informaci√≥n")[:500]
        return "Art√≠culo no encontrado"
    except Exception as e:
        return f"Error de b√∫squeda: {e}"

def calculate(expression: str) -> str:
    """Eval√∫a una expresi√≥n matem√°tica."""
    try:
        # Evaluaci√≥n segura de expresiones
        allowed_names = {"abs": abs, "round": round, "min": min, "max": max}
        result = eval(expression, {"__builtins__": {}}, allowed_names)
        return str(result)
    except Exception as e:
        return f"Error de c√°lculo: {e}"

def get_current_date() -> str:
    """Obtiene la fecha actual."""
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")


# Configurar el agente
agent = ReActAgent()

# Registrar herramientas
agent.register_tool(
    name="search",
    func=search_wikipedia,
    description="Busca informaci√≥n en Wikipedia",
    parameters={"query": "t√©rmino de b√∫squeda"}
)

agent.register_tool(
    name="calculate",
    func=calculate,
    description="Eval√∫a expresiones matem√°ticas",
    parameters={"expression": "expresi√≥n matem√°tica"}
)

agent.register_tool(
    name="date",
    func=get_current_date,
    description="Obtiene la fecha y hora actual",
    parameters={}
)


# Ejecutar una consulta
trace = agent.run(
    "¬øCu√°ntos a√±os han pasado desde que se fund√≥ Google hasta hoy?"
)

# Mostrar la traza
print("=" * 60)
print("TRAZA DE EJECUCI√ìN ReAct")
print("=" * 60)
for step in trace.steps:
    print(f"\n[{step.step_type.value.upper()}]")
    print(step.content)
    if step.tool_name:
        print(f"  Tool: {step.tool_name}")
        print(f"  Args: {step.tool_args}")

print("\n" + "=" * 60)
print(f"RESPUESTA FINAL: {trace.final_answer}")
```

**Salida esperada:**
```
============================================================
TRAZA DE EJECUCI√ìN ReAct
============================================================

[THOUGHT]
Necesito saber cu√°ndo se fund√≥ Google y la fecha actual para calcular los a√±os transcurridos.

[ACTION]
Voy a buscar informaci√≥n sobre Google
  Tool: search
  Args: {'query': 'Google empresa'}

[OBSERVATION]
Google es una compa√±√≠a estadounidense fundada el 4 de septiembre de 1998...

[THOUGHT]
Google fue fundada el 4 de septiembre de 1998. Ahora necesito la fecha actual.

[ACTION]
Obtengo la fecha actual
  Tool: date
  Args: {}

[OBSERVATION]
2024-11-15 14:30:00

[THOUGHT]
Con la fecha de fundaci√≥n (1998) y la actual (2024), puedo calcular la diferencia.

[ACTION]
Calculo los a√±os transcurridos
  Tool: calculate
  Args: {'expression': '2024 - 1998'}

[OBSERVATION]
26

[FINAL_ANSWER]
Han pasado 26 a√±os desde la fundaci√≥n de Google (4 de septiembre de 1998) hasta hoy.

============================================================
RESPUESTA FINAL: Han pasado 26 a√±os desde la fundaci√≥n de Google...
```

## ReAct con Streaming

```python
class StreamingReActAgent(ReActAgent):
    """
    Versi√≥n de ReAct que transmite los pasos en tiempo real.
    """

    def run_streaming(self, question: str):
        """Ejecuta el agente con streaming de pasos."""
        trace = ReActTrace(question=question)

        print(f"\n{'='*60}")
        print(f"PREGUNTA: {question}")
        print(f"{'='*60}\n")

        for iteration in range(self.max_iterations):
            prompt = self.REACT_PROMPT.format(
                tools_description=self._get_tools_description(),
                question=question,
                trace=trace.to_string() if trace.steps else "Comienza tu razonamiento:"
            )

            # Streaming de la respuesta
            print(f"[Iteraci√≥n {iteration + 1}] ", end="", flush=True)

            full_response = ""
            response = self.model.generate_content(prompt, stream=True)

            for chunk in response:
                if chunk.text:
                    print(chunk.text, end="", flush=True)
                    full_response += chunk.text

            print("\n")

            step = self._parse_response(full_response)

            if step.step_type == StepType.FINAL_ANSWER:
                trace.add_step(step)
                print(f"\n‚úÖ RESPUESTA: {step.content}")
                break

            elif step.step_type == StepType.ACTION:
                trace.add_step(ReActStep(StepType.THOUGHT, step.content))
                trace.add_step(step)

                print(f"‚öôÔ∏è  Ejecutando: {step.tool_name}...")
                observation = self._execute_action(step)
                trace.add_step(ReActStep(StepType.OBSERVATION, observation))
                print(f"üìù Observaci√≥n: {observation[:200]}...")
                print()

            else:
                trace.add_step(step)

        return trace


# Uso del agente con streaming
streaming_agent = StreamingReActAgent()
streaming_agent.tools = agent.tools
streaming_agent.tools_description = agent.tools_description

trace = streaming_agent.run_streaming(
    "¬øCu√°l es la capital de Francia y cu√°ntos habitantes tiene aproximadamente?"
)
```

## Patrones Avanzados de ReAct

### 1. ReAct con Reflexi√≥n

```python
class ReflectiveReActAgent(ReActAgent):
    """
    Agente ReAct que incluye pasos de reflexi√≥n para auto-correcci√≥n.
    """

    REFLECTION_PROMPT = """Analiza tu proceso de razonamiento hasta ahora:

Pregunta original: {question}
Pasos realizados:
{trace}

Reflexiona:
1. ¬øEst√°s avanzando hacia la respuesta?
2. ¬øHas cometido alg√∫n error de razonamiento?
3. ¬øNecesitas cambiar de estrategia?

Responde con:
- CONTINUE: si el enfoque es correcto
- REVISE: si necesitas corregir algo (explica qu√©)
- STUCK: si est√°s en un callej√≥n sin salida"""

    def _should_reflect(self, trace: ReActTrace) -> bool:
        """Determina si es momento de reflexionar."""
        # Reflexionar cada 3 pasos o si hay errores
        action_count = sum(1 for s in trace.steps if s.step_type == StepType.ACTION)
        return action_count > 0 and action_count % 3 == 0

    def _reflect(self, trace: ReActTrace) -> str:
        """Ejecuta un paso de reflexi√≥n."""
        prompt = self.REFLECTION_PROMPT.format(
            question=trace.question,
            trace=trace.to_string()
        )
        response = self.model.generate_content(prompt)
        return response.text

    def run(self, question: str) -> ReActTrace:
        """Ejecuta con reflexi√≥n peri√≥dica."""
        trace = ReActTrace(question=question)

        for iteration in range(self.max_iterations):
            # Reflexi√≥n peri√≥dica
            if self._should_reflect(trace):
                reflection = self._reflect(trace)
                print(f"üîç Reflexi√≥n: {reflection[:200]}...")

                if "STUCK" in reflection:
                    # Reiniciar con nueva estrategia
                    trace.steps = []
                    print("‚Ü©Ô∏è  Reiniciando con nueva estrategia...")

            # Continuar con el ciclo normal de ReAct
            prompt = self.REACT_PROMPT.format(
                tools_description=self._get_tools_description(),
                question=question,
                trace=trace.to_string() if trace.steps else "Comienza:"
            )

            response = self.model.generate_content(prompt)
            step = self._parse_response(response.text)

            if step.step_type == StepType.FINAL_ANSWER:
                trace.add_step(step)
                break
            elif step.step_type == StepType.ACTION:
                trace.add_step(ReActStep(StepType.THOUGHT, step.content))
                trace.add_step(step)
                observation = self._execute_action(step)
                trace.add_step(ReActStep(StepType.OBSERVATION, observation))
            else:
                trace.add_step(step)

        return trace
```

### 2. ReAct con Memoria de Ejemplos

```python
@dataclass
class ReActExample:
    """Ejemplo de traza ReAct exitosa."""
    question: str
    trace: str
    answer: str

class FewShotReActAgent(ReActAgent):
    """
    Agente ReAct que aprende de ejemplos previos.
    """

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        super().__init__(model_name)
        self.examples: list[ReActExample] = []

    def add_example(self, example: ReActExample):
        """Agrega un ejemplo de traza exitosa."""
        self.examples.append(example)

    def _format_examples(self) -> str:
        """Formatea los ejemplos para el prompt."""
        if not self.examples:
            return ""

        formatted = "\n\nEJEMPLOS DE RAZONAMIENTO:\n"
        for i, ex in enumerate(self.examples[-3:], 1):  # √öltimos 3 ejemplos
            formatted += f"""
--- Ejemplo {i} ---
Pregunta: {ex.question}
{ex.trace}
Final Answer: {ex.answer}
"""
        return formatted

    def run(self, question: str) -> ReActTrace:
        """Ejecuta incluyendo ejemplos en el prompt."""
        # Modificar el prompt base para incluir ejemplos
        original_prompt = self.REACT_PROMPT
        self.REACT_PROMPT = original_prompt.replace(
            "PREGUNTA: {question}",
            self._format_examples() + "\nPREGUNTA: {question}"
        )

        result = super().run(question)

        # Restaurar prompt original
        self.REACT_PROMPT = original_prompt

        # Guardar ejemplo exitoso si complet√≥
        if result.final_answer:
            self.add_example(ReActExample(
                question=question,
                trace=result.to_string(),
                answer=result.final_answer
            ))

        return result
```

## Errores Comunes y Soluciones

### 1. Bucles Infinitos

```python
# ‚ùå MAL: Sin control de iteraciones
while True:
    response = model.generate_content(prompt)
    # Puede nunca terminar

# ‚úÖ BIEN: L√≠mite de iteraciones y detecci√≥n de bucles
def run_with_loop_detection(self, question: str) -> ReActTrace:
    trace = ReActTrace(question=question)
    seen_states = set()

    for iteration in range(self.max_iterations):
        # Crear hash del estado actual
        state_hash = hash(trace.to_string())

        if state_hash in seen_states:
            print("‚ö†Ô∏è  Bucle detectado, forzando respuesta...")
            # Forzar una respuesta final
            force_prompt = f"""
            Bas√°ndote en lo que has descubierto hasta ahora:
            {trace.to_string()}

            Proporciona tu mejor respuesta a: {question}
            """
            response = self.model.generate_content(force_prompt)
            trace.add_step(ReActStep(StepType.FINAL_ANSWER, response.text))
            break

        seen_states.add(state_hash)
        # Continuar con el ciclo normal...
```

### 2. Herramientas No Encontradas

```python
# ‚ùå MAL: Fallo silencioso
def _execute_action(self, step):
    return self.tools.get(step.tool_name, lambda: "")()

# ‚úÖ BIEN: Retroalimentaci√≥n clara al agente
def _execute_action(self, step: ReActStep) -> str:
    if step.tool_name not in self.tools:
        available = ", ".join(self.tools.keys())
        return f"""Error: Herramienta '{step.tool_name}' no existe.
Herramientas disponibles: {available}
Usa una de las herramientas listadas."""

    try:
        return str(self.tools[step.tool_name](**step.tool_args))
    except TypeError as e:
        return f"Error: Argumentos incorrectos para {step.tool_name}: {e}"
```

### 3. Parsing Fr√°gil

```python
# ‚ùå MAL: Regex demasiado estricto
action_match = re.match(r"^Action: (\w+)\[(.+)\]$", line)

# ‚úÖ BIEN: Parsing flexible con fallbacks
def _parse_response_robust(self, response: str) -> ReActStep:
    response = response.strip()

    # Intentar m√∫ltiples patrones
    patterns = [
        r"Action(?:\s*\d*)?:\s*(\w+)\[(.+?)\]",  # Action: tool[args]
        r"Action(?:\s*\d*)?:\s*(\w+)\((.+?)\)",  # Action: tool(args)
        r"Usar(?:√©)?\s+(\w+):\s*(.+)",           # Usar√© tool: args
    ]

    for pattern in patterns:
        match = re.search(pattern, response, re.IGNORECASE | re.DOTALL)
        if match:
            tool_name = match.group(1)
            args_str = match.group(2)

            # Intentar parsear argumentos
            try:
                args = json.loads(args_str)
            except:
                args = {"query": args_str.strip('"\')}

            return ReActStep(StepType.ACTION, response, tool_name, args)

    # Fallback a pensamiento
    return ReActStep(StepType.THOUGHT, response)
```

## Aplicaciones Pr√°cticas

| Dominio | Caso de Uso | Herramientas T√≠picas |
|---------|-------------|---------------------|
| Investigaci√≥n | Responder preguntas complejas | search, wikipedia, arxiv |
| E-commerce | Comparar productos | search_products, get_reviews, compare_prices |
| Soporte | Resolver tickets | search_docs, check_status, create_ticket |
| Finanzas | An√°lisis de inversiones | get_stock_price, get_news, calculate |
| DevOps | Diagn√≥stico de sistemas | check_logs, run_query, get_metrics |

## Resumen

El modelo **ReAct** combina razonamiento expl√≠cito con ejecuci√≥n de acciones:

1. **Thought**: El agente razona sobre el estado actual y planifica
2. **Action**: Ejecuta herramientas para obtener informaci√≥n
3. **Observation**: Procesa los resultados de las acciones
4. **Final Answer**: Sintetiza una respuesta cuando tiene suficiente informaci√≥n

**Ventajas clave**:
- Razonamiento trazable y explicable
- Capacidad de auto-correcci√≥n basada en observaciones
- Uso eficiente de herramientas externas
- Reducci√≥n de alucinaciones mediante grounding

---

## Navegaci√≥n

- **Anterior**: [3.3.3 Rate Limiting y Retry](../../modulo_3/tema_3.3/3.3.3-rate-limiting-retry.md)
- **Siguiente**: [4.1.2 Bucle de Agente: Observe-Think-Act](./4.1.2-bucle-observe-think-act.md)
- **√çndice**: [README del Curso](../../README.md)
