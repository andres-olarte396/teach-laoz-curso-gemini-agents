# 4.1.2 Bucle de Agente: Observe-Think-Act

## Tiempo estimado: 75 minutos
## Nivel: Intermedio-Avanzado

## Prerrequisitos
- Modelo ReAct (4.1.1)
- Comprensi√≥n de m√°quinas de estado
- Async/await en Python

## ¬øPor qu√© es importante?

El bucle **Observe-Think-Act** (OTA) es el coraz√≥n de todo agente aut√≥nomo. Este patr√≥n arquitect√≥nico define c√≥mo un agente:
1. **Percibe** su entorno (Observe)
2. **Razona** sobre qu√© hacer (Think)
3. **Ejecuta** acciones (Act)

Dominar este bucle te permite construir agentes robustos que pueden operar de forma continua y adaptarse a situaciones cambiantes.

## Arquitectura del Bucle OTA

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      BUCLE OBSERVE-THINK-ACT                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                         ‚îÇ
‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ    ‚îÇ                    ESTADO DEL AGENTE                        ‚îÇ     ‚îÇ
‚îÇ    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ     ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  Goals   ‚îÇ  ‚îÇ Memory   ‚îÇ  ‚îÇ    Working Context       ‚îÇ  ‚îÇ     ‚îÇ
‚îÇ    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ     ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                                    ‚îÇ                                    ‚îÇ
‚îÇ                                    ‚ñº                                    ‚îÇ
‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ    ‚îÇ                                                               ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                             ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ   OBSERVE   ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ             ‚îÇ                                     ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ ‚Ä¢ Percepci√≥n‚îÇ                                     ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ ‚Ä¢ Sensores  ‚îÇ                                     ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ ‚Ä¢ Entorno   ‚îÇ                                     ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                     ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ          ‚îÇ                                            ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ          ‚îÇ Observaciones                              ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ          ‚ñº                                            ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                     ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ    THINK    ‚îÇ                                     ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ             ‚îÇ                                     ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ ‚Ä¢ An√°lisis  ‚îÇ                                     ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ ‚Ä¢ Decisi√≥n  ‚îÇ                                     ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ ‚Ä¢ Plan      ‚îÇ                                     ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                     ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ          ‚îÇ                                            ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ          ‚îÇ Decisi√≥n                                   ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ          ‚ñº                                            ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                              Feedback‚îÇ      ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ     ACT     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ             ‚îÇ                                             ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ ‚Ä¢ Ejecutar  ‚îÇ                                             ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ ‚Ä¢ Tools     ‚îÇ                                             ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îÇ ‚Ä¢ Responder ‚îÇ                                             ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                             ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ                                                               ‚îÇ   ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Componentes del Bucle

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   COMPONENTES DETALLADOS                                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                        ‚îÇ
‚îÇ  OBSERVE (Percepci√≥n)                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ User Input       ‚Üí Mensajes del usuario                        ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Tool Results     ‚Üí Resultados de herramientas ejecutadas       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Environment      ‚Üí Estado del sistema, APIs, bases de datos    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Time/Events      ‚Üí Triggers temporales, webhooks               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Memory Recall    ‚Üí Recuperaci√≥n de informaci√≥n pasada          ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  THINK (Razonamiento)                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Context Analysis ‚Üí Analizar observaciones vs objetivos         ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Option Generation‚Üí Generar posibles acciones                   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Evaluation       ‚Üí Evaluar pros/contras de cada opci√≥n         ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Decision         ‚Üí Seleccionar la mejor acci√≥n                 ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Planning         ‚Üí Secuenciar pasos si es necesario            ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  ACT (Ejecuci√≥n)                                                       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Tool Execution   ‚Üí Llamar herramientas externas                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Response         ‚Üí Generar respuesta al usuario                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ State Update     ‚Üí Actualizar memoria y estado                 ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Side Effects     ‚Üí APIs externas, archivos, etc.               ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n del Bucle OTA

```python
import google.generativeai as genai
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Optional, Callable
from enum import Enum, auto
import json
import time
import os

class AgentState(Enum):
    """Estados posibles del agente."""
    IDLE = auto()
    OBSERVING = auto()
    THINKING = auto()
    ACTING = auto()
    COMPLETED = auto()
    ERROR = auto()

@dataclass
class Observation:
    """Representa una observaci√≥n del entorno."""
    source: str  # user, tool, environment, memory
    content: Any
    timestamp: float = field(default_factory=time.time)
    metadata: dict = field(default_factory=dict)

@dataclass
class Thought:
    """Representa el razonamiento del agente."""
    analysis: str
    options: list[str]
    decision: str
    confidence: float  # 0.0 a 1.0
    reasoning: str

@dataclass
class Action:
    """Representa una acci√≥n a ejecutar."""
    action_type: str  # tool_call, response, state_update, terminate
    payload: dict
    priority: int = 0

@dataclass
class AgentContext:
    """Contexto completo del agente."""
    goal: str
    observations: list[Observation] = field(default_factory=list)
    thoughts: list[Thought] = field(default_factory=list)
    actions_taken: list[Action] = field(default_factory=list)
    memory: dict = field(default_factory=dict)
    iteration: int = 0


class OTAAgent:
    """
    Implementaci√≥n del bucle Observe-Think-Act con Gemini.
    """

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)
        self.tools: dict[str, Callable] = {}
        self.state = AgentState.IDLE
        self.max_iterations = 15
        self.observers: list[Callable] = []  # Para logging/debugging

    def register_tool(self, name: str, func: Callable, description: str):
        """Registra una herramienta."""
        self.tools[name] = {
            "function": func,
            "description": description
        }

    def add_observer(self, callback: Callable):
        """Agrega un observador para el bucle."""
        self.observers.append(callback)

    def _notify_observers(self, event: str, data: Any):
        """Notifica a los observadores."""
        for observer in self.observers:
            observer(event, data)

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # OBSERVE: Recolectar informaci√≥n del entorno
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def observe(self, context: AgentContext, new_input: Optional[str] = None) -> list[Observation]:
        """
        Fase de observaci√≥n: recolecta informaci√≥n relevante.
        """
        self.state = AgentState.OBSERVING
        observations = []

        # 1. Input del usuario (si hay)
        if new_input:
            observations.append(Observation(
                source="user",
                content=new_input,
                metadata={"type": "user_message"}
            ))

        # 2. Resultados de acciones previas
        if context.actions_taken:
            last_action = context.actions_taken[-1]
            if "result" in last_action.payload:
                observations.append(Observation(
                    source="tool",
                    content=last_action.payload["result"],
                    metadata={
                        "action_type": last_action.action_type,
                        "tool_name": last_action.payload.get("tool_name")
                    }
                ))

        # 3. Recuperaci√≥n de memoria relevante
        memory_obs = self._recall_relevant_memory(context)
        if memory_obs:
            observations.append(memory_obs)

        # 4. Estado del entorno (ejemplo: hora actual)
        observations.append(Observation(
            source="environment",
            content={"current_time": time.strftime("%Y-%m-%d %H:%M:%S")},
            metadata={"type": "system_state"}
        ))

        self._notify_observers("observe", observations)
        return observations

    def _recall_relevant_memory(self, context: AgentContext) -> Optional[Observation]:
        """Recupera informaci√≥n relevante de la memoria."""
        if not context.memory:
            return None

        # Simplificado: en producci√≥n usar√≠as embeddings
        relevant = {k: v for k, v in context.memory.items()
                   if any(word in context.goal.lower() for word in k.lower().split("_"))}

        if relevant:
            return Observation(
                source="memory",
                content=relevant,
                metadata={"type": "memory_recall"}
            )
        return None

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # THINK: Analizar y decidir la siguiente acci√≥n
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def think(self, context: AgentContext, observations: list[Observation]) -> Thought:
        """
        Fase de pensamiento: analiza observaciones y decide qu√© hacer.
        """
        self.state = AgentState.THINKING

        # Construir prompt para el razonamiento
        prompt = self._build_thinking_prompt(context, observations)

        response = self.model.generate_content(prompt)
        thought = self._parse_thought(response.text)

        self._notify_observers("think", thought)
        return thought

    def _build_thinking_prompt(
        self,
        context: AgentContext,
        observations: list[Observation]
    ) -> str:
        """Construye el prompt para la fase de pensamiento."""

        tools_desc = "\n".join([
            f"- {name}: {info['description']}"
            for name, info in self.tools.items()
        ])

        obs_text = "\n".join([
            f"[{obs.source}] {obs.content}"
            for obs in observations
        ])

        history = ""
        if context.thoughts:
            history = "Pensamientos previos:\n" + "\n".join([
                f"- {t.decision}" for t in context.thoughts[-3:]
            ])

        return f"""Eres un agente inteligente que debe decidir la siguiente acci√≥n.

OBJETIVO: {context.goal}

ITERACI√ìN ACTUAL: {context.iteration}/{self.max_iterations}

HERRAMIENTAS DISPONIBLES:
{tools_desc}
- respond: Dar una respuesta final al usuario
- terminate: Finalizar la tarea (cuando el objetivo se ha cumplido)

OBSERVACIONES ACTUALES:
{obs_text}

{history}

INSTRUCCIONES:
Analiza las observaciones y decide qu√© hacer. Responde en formato JSON:
{{
    "analysis": "Tu an√°lisis de la situaci√≥n actual",
    "options": ["opci√≥n 1", "opci√≥n 2", "opci√≥n 3"],
    "decision": "La acci√≥n que tomar√°s",
    "confidence": 0.0-1.0,
    "reasoning": "Por qu√© elegiste esta acci√≥n",
    "action": {{
        "type": "tool_call|respond|terminate",
        "tool_name": "nombre_si_es_tool_call",
        "arguments": {{}},
        "response": "texto_si_es_respond"
    }}
}}

Responde SOLO con el JSON, sin texto adicional."""

    def _parse_thought(self, response: str) -> Thought:
        """Parsea la respuesta del modelo a un objeto Thought."""
        try:
            # Limpiar el response de markdown code blocks
            clean = response.strip()
            if clean.startswith("```"):
                clean = clean.split("```")[1]
                if clean.startswith("json"):
                    clean = clean[4:]

            data = json.loads(clean)
            return Thought(
                analysis=data.get("analysis", ""),
                options=data.get("options", []),
                decision=data.get("decision", ""),
                confidence=float(data.get("confidence", 0.5)),
                reasoning=data.get("reasoning", "")
            )
        except json.JSONDecodeError:
            return Thought(
                analysis=response,
                options=[],
                decision="respond",
                confidence=0.3,
                reasoning="No se pudo parsear la respuesta"
            )

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ACT: Ejecutar la acci√≥n decidida
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def act(self, context: AgentContext, thought: Thought) -> Action:
        """
        Fase de acci√≥n: ejecuta la decisi√≥n tomada.
        """
        self.state = AgentState.ACTING

        # Extraer la acci√≥n del pensamiento
        action_data = self._extract_action(thought)
        action = Action(
            action_type=action_data.get("type", "respond"),
            payload=action_data
        )

        # Ejecutar seg√∫n el tipo de acci√≥n
        if action.action_type == "tool_call":
            result = self._execute_tool(action.payload)
            action.payload["result"] = result

        elif action.action_type == "terminate":
            self.state = AgentState.COMPLETED

        elif action.action_type == "respond":
            # La respuesta ya est√° en el payload
            pass

        self._notify_observers("act", action)
        return action

    def _extract_action(self, thought: Thought) -> dict:
        """Extrae la acci√≥n del pensamiento."""
        # Intentar extraer del JSON original si est√° disponible
        try:
            if hasattr(thought, '_raw_data'):
                return thought._raw_data.get("action", {})
        except:
            pass

        # Inferir de la decisi√≥n textual
        decision = thought.decision.lower()

        if "terminate" in decision or "completado" in decision:
            return {"type": "terminate"}

        for tool_name in self.tools.keys():
            if tool_name.lower() in decision:
                return {
                    "type": "tool_call",
                    "tool_name": tool_name,
                    "arguments": {}
                }

        return {
            "type": "respond",
            "response": thought.decision
        }

    def _execute_tool(self, payload: dict) -> str:
        """Ejecuta una herramienta."""
        tool_name = payload.get("tool_name")
        arguments = payload.get("arguments", {})

        if tool_name not in self.tools:
            return f"Error: Herramienta '{tool_name}' no encontrada"

        try:
            tool_func = self.tools[tool_name]["function"]
            result = tool_func(**arguments)
            return str(result)
        except Exception as e:
            return f"Error ejecutando {tool_name}: {str(e)}"

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # BUCLE PRINCIPAL
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def run(self, goal: str, initial_input: Optional[str] = None) -> AgentContext:
        """
        Ejecuta el bucle OTA hasta completar el objetivo.

        Args:
            goal: El objetivo a cumplir
            initial_input: Input inicial del usuario (opcional)

        Returns:
            AgentContext con toda la traza de ejecuci√≥n
        """
        context = AgentContext(goal=goal)
        current_input = initial_input

        print(f"\n{'‚ïê'*60}")
        print(f"üéØ OBJETIVO: {goal}")
        print(f"{'‚ïê'*60}\n")

        while context.iteration < self.max_iterations:
            context.iteration += 1
            print(f"\n--- Iteraci√≥n {context.iteration} ---")

            # 1. OBSERVE
            print("üëÅÔ∏è  OBSERVE...")
            observations = self.observe(context, current_input)
            context.observations.extend(observations)
            current_input = None  # Solo usar en primera iteraci√≥n

            for obs in observations:
                print(f"   [{obs.source}] {str(obs.content)[:100]}...")

            # 2. THINK
            print("üß† THINK...")
            thought = self.think(context, observations)
            context.thoughts.append(thought)

            print(f"   An√°lisis: {thought.analysis[:100]}...")
            print(f"   Decisi√≥n: {thought.decision}")
            print(f"   Confianza: {thought.confidence:.0%}")

            # 3. ACT
            print("‚ö° ACT...")
            action = self.act(context, thought)
            context.actions_taken.append(action)

            print(f"   Tipo: {action.action_type}")
            if action.action_type == "tool_call":
                print(f"   Tool: {action.payload.get('tool_name')}")
                print(f"   Result: {action.payload.get('result', '')[:100]}...")

            # Verificar terminaci√≥n
            if self.state == AgentState.COMPLETED:
                print(f"\n‚úÖ Tarea completada en {context.iteration} iteraciones")
                break

            # Peque√±a pausa para evitar rate limiting
            time.sleep(0.5)

        return context
```

## Ejemplo Pr√°ctico: Agente de An√°lisis

```python
import requests

# Crear el agente
agent = OTAAgent()

# Registrar herramientas
def search_info(query: str) -> str:
    """Busca informaci√≥n general."""
    url = f"https://es.wikipedia.org/api/rest_v1/page/summary/{query.replace(' ', '_')}"
    try:
        resp = requests.get(url, timeout=10)
        if resp.status_code == 200:
            return resp.json().get("extract", "No encontrado")[:400]
        return "No se encontr√≥ informaci√≥n"
    except:
        return "Error de conexi√≥n"

def analyze_sentiment(text: str) -> str:
    """Analiza el sentimiento de un texto."""
    # Simplificado - en producci√≥n usar√≠as Gemini
    positive_words = ["bueno", "excelente", "positivo", "√©xito", "beneficio"]
    negative_words = ["malo", "problema", "negativo", "fracaso", "peligro"]

    text_lower = text.lower()
    pos_count = sum(1 for w in positive_words if w in text_lower)
    neg_count = sum(1 for w in negative_words if w in text_lower)

    if pos_count > neg_count:
        return f"Sentimiento POSITIVO (palabras positivas: {pos_count})"
    elif neg_count > pos_count:
        return f"Sentimiento NEGATIVO (palabras negativas: {neg_count})"
    return "Sentimiento NEUTRAL"

def summarize(text: str) -> str:
    """Resume un texto."""
    sentences = text.split(". ")
    if len(sentences) <= 2:
        return text
    return ". ".join(sentences[:2]) + "..."

# Registrar herramientas
agent.register_tool("search", search_info, "Busca informaci√≥n sobre un tema")
agent.register_tool("sentiment", analyze_sentiment, "Analiza el sentimiento de un texto")
agent.register_tool("summarize", summarize, "Resume un texto largo")

# Agregar un observador para logging
def logger(event: str, data):
    print(f"  üìã LOG [{event}]: {type(data).__name__}")

agent.add_observer(logger)

# Ejecutar
context = agent.run(
    goal="Investigar sobre la inteligencia artificial y analizar si la informaci√≥n es positiva o negativa",
    initial_input="Quiero saber sobre IA y machine learning"
)

# Mostrar resumen
print("\n" + "=" * 60)
print("RESUMEN DE EJECUCI√ìN")
print("=" * 60)
print(f"Iteraciones: {context.iteration}")
print(f"Observaciones: {len(context.observations)}")
print(f"Pensamientos: {len(context.thoughts)}")
print(f"Acciones: {len(context.actions_taken)}")
```

## Variante: Bucle con M√∫ltiples Agentes

```python
@dataclass
class AgentMessage:
    """Mensaje entre agentes."""
    sender: str
    receiver: str
    content: str
    message_type: str  # query, response, broadcast

class MultiAgentOTA:
    """
    Sistema de m√∫ltiples agentes OTA que pueden comunicarse.
    """

    def __init__(self):
        self.agents: dict[str, OTAAgent] = {}
        self.message_queue: list[AgentMessage] = []

    def add_agent(self, name: str, agent: OTAAgent):
        """Agrega un agente al sistema."""
        self.agents[name] = agent

    def send_message(self, msg: AgentMessage):
        """Env√≠a un mensaje entre agentes."""
        self.message_queue.append(msg)

    def broadcast(self, sender: str, content: str):
        """Env√≠a mensaje a todos los agentes."""
        for name in self.agents.keys():
            if name != sender:
                self.send_message(AgentMessage(
                    sender=sender,
                    receiver=name,
                    content=content,
                    message_type="broadcast"
                ))

    def run_round(self) -> dict[str, Action]:
        """Ejecuta una ronda de todos los agentes."""
        actions = {}

        for name, agent in self.agents.items():
            # Recolectar mensajes para este agente
            messages = [m for m in self.message_queue if m.receiver == name]

            # Crear observaci√≥n con mensajes
            if messages:
                agent_input = "\n".join([
                    f"[De {m.sender}]: {m.content}" for m in messages
                ])
            else:
                agent_input = None

            # Ejecutar una iteraci√≥n
            if hasattr(agent, '_current_context'):
                ctx = agent._current_context
            else:
                ctx = AgentContext(goal=f"Agente {name}")
                agent._current_context = ctx

            obs = agent.observe(ctx, agent_input)
            thought = agent.think(ctx, obs)
            action = agent.act(ctx, thought)

            actions[name] = action

            # Limpiar mensajes procesados
            self.message_queue = [
                m for m in self.message_queue if m.receiver != name
            ]

        return actions


# Ejemplo: Sistema de dos agentes
multi_system = MultiAgentOTA()

investigator = OTAAgent()
investigator.register_tool("search", search_info, "Busca informaci√≥n")

analyst = OTAAgent()
analyst.register_tool("sentiment", analyze_sentiment, "Analiza sentimiento")

multi_system.add_agent("investigador", investigator)
multi_system.add_agent("analista", analyst)

# Simular interacci√≥n
multi_system.send_message(AgentMessage(
    sender="user",
    receiver="investigador",
    content="Investiga sobre energ√≠as renovables",
    message_type="query"
))

# Ejecutar varias rondas
for round_num in range(3):
    print(f"\n=== Ronda {round_num + 1} ===")
    actions = multi_system.run_round()
    for agent_name, action in actions.items():
        print(f"{agent_name}: {action.action_type}")
```

## Errores Comunes y Soluciones

### 1. Estado Inconsistente

```python
# ‚ùå MAL: Estado mutable compartido
class BadAgent:
    def __init__(self):
        self.observations = []  # ¬°Persiste entre ejecuciones!

    def run(self, goal):
        # Las observaciones de ejecuciones anteriores contaminan

# ‚úÖ BIEN: Estado aislado por ejecuci√≥n
class GoodAgent:
    def run(self, goal):
        context = AgentContext(goal=goal)  # Nuevo contexto cada vez
        # Todo el estado est√° en context
```

### 2. Observaciones Stale

```python
# ‚ùå MAL: No verificar frescura de datos
def observe_old(self, context):
    return context.observations  # Datos viejos

# ‚úÖ BIEN: Marcar y filtrar por tiempo
def observe(self, context):
    fresh_observations = []
    cutoff = time.time() - 60  # Solo √∫ltimos 60 segundos

    for obs in context.observations:
        if obs.timestamp > cutoff:
            fresh_observations.append(obs)

    # Agregar nuevas observaciones
    fresh_observations.extend(self._collect_new_observations())
    return fresh_observations
```

### 3. Bucle Sin Progreso

```python
# ‚úÖ Detectar falta de progreso
def detect_stall(self, context: AgentContext) -> bool:
    """Detecta si el agente est√° estancado."""
    if len(context.thoughts) < 3:
        return False

    # Verificar si las √∫ltimas decisiones son iguales
    recent_decisions = [t.decision for t in context.thoughts[-3:]]
    if len(set(recent_decisions)) == 1:
        return True

    # Verificar confianza decreciente
    recent_confidence = [t.confidence for t in context.thoughts[-3:]]
    if all(c < 0.3 for c in recent_confidence):
        return True

    return False
```

## Aplicaciones del Bucle OTA

| Aplicaci√≥n | Observe | Think | Act |
|------------|---------|-------|-----|
| Chatbot | User input, context | Intent classification | Generate response |
| Trading Bot | Market data, news | Analyze trends | Buy/Sell |
| DevOps Agent | Logs, metrics | Diagnose issues | Execute fixes |
| Game AI | Game state, player | Strategy planning | Move/Attack |
| Research Agent | Papers, web search | Synthesize findings | Write report |

## Resumen

El bucle **Observe-Think-Act** estructura el comportamiento del agente:

1. **Observe**: Recolectar informaci√≥n del entorno
   - Input del usuario
   - Resultados de herramientas
   - Estado del sistema
   - Memoria relevante

2. **Think**: Analizar y decidir
   - Contextualizar observaciones
   - Generar opciones
   - Evaluar y seleccionar

3. **Act**: Ejecutar la decisi√≥n
   - Llamar herramientas
   - Generar respuestas
   - Actualizar estado

**Caracter√≠sticas clave**:
- Estado encapsulado en `AgentContext`
- Observadores para debugging/logging
- Detecci√≥n de bucles y estancamiento
- Soporte para m√∫ltiples agentes

---

## Navegaci√≥n

- **Anterior**: [4.1.1 Modelo ReAct](./4.1.1-modelo-react.md)
- **Siguiente**: [4.1.2 Condiciones de Terminaci√≥n](./4.1.3-condiciones-terminacion.md)
- **√çndice**: [README del Curso](../../README.md)
