# 4.1.3 Condiciones de TerminaciÃ³n

## Tiempo estimado: 60 minutos
## Nivel: Intermedio

## Prerrequisitos
- Bucle Observe-Think-Act (4.1.2)
- Modelo ReAct (4.1.1)
- ComprensiÃ³n de mÃ¡quinas de estado

## Â¿Por quÃ© es importante?

Las **condiciones de terminaciÃ³n** determinan cuÃ¡ndo un agente debe detenerse. Un agente que no termina correctamente puede:
- Consumir recursos innecesarios (tokens, tiempo, dinero)
- Generar respuestas redundantes o incoherentes
- Quedar atrapado en bucles infinitos
- No entregar resultados al usuario

DiseÃ±ar condiciones de terminaciÃ³n robustas es crÃ­tico para agentes confiables en producciÃ³n.

## TaxonomÃ­a de Condiciones de TerminaciÃ³n

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  CONDICIONES DE TERMINACIÃ“N                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    EXPLÃCITAS                                    â”‚   â”‚
â”‚  â”‚                                                                   â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚   â”‚
â”‚  â”‚  â”‚   OBJETIVO   â”‚  â”‚  RESPUESTA   â”‚  â”‚   COMANDO    â”‚           â”‚   â”‚
â”‚  â”‚  â”‚  COMPLETADO  â”‚  â”‚    FINAL     â”‚  â”‚   TERMINAR   â”‚           â”‚   â”‚
â”‚  â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚           â”‚   â”‚
â”‚  â”‚  â”‚ El agente    â”‚  â”‚ "Final      â”‚  â”‚ Tool:        â”‚           â”‚   â”‚
â”‚  â”‚  â”‚ determina    â”‚  â”‚  Answer:"   â”‚  â”‚ terminate()  â”‚           â”‚   â”‚
â”‚  â”‚  â”‚ que cumpliÃ³  â”‚  â”‚              â”‚  â”‚              â”‚           â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    IMPLÃCITAS                                    â”‚   â”‚
â”‚  â”‚                                                                   â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚   â”‚
â”‚  â”‚  â”‚   LÃMITE DE  â”‚  â”‚  TIMEOUT     â”‚  â”‚   BUDGET     â”‚           â”‚   â”‚
â”‚  â”‚  â”‚ ITERACIONES  â”‚  â”‚  TEMPORAL    â”‚  â”‚   AGOTADO    â”‚           â”‚   â”‚
â”‚  â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚           â”‚   â”‚
â”‚  â”‚  â”‚ Max N loops  â”‚  â”‚ > T segundos â”‚  â”‚ > $ tokens   â”‚           â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    EMERGENTES                                    â”‚   â”‚
â”‚  â”‚                                                                   â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚   â”‚
â”‚  â”‚  â”‚   BUCLE      â”‚  â”‚   ERROR      â”‚  â”‚  CONFIANZA   â”‚           â”‚   â”‚
â”‚  â”‚  â”‚  DETECTADO   â”‚  â”‚ IRRECUPERABLEâ”‚  â”‚    BAJA      â”‚           â”‚   â”‚
â”‚  â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚           â”‚   â”‚
â”‚  â”‚  â”‚ RepeticiÃ³n   â”‚  â”‚ Fallo crÃ­ticoâ”‚  â”‚ < threshold  â”‚           â”‚   â”‚
â”‚  â”‚  â”‚ de estados   â”‚  â”‚ de tool      â”‚  â”‚              â”‚           â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Diagrama de Flujo de TerminaciÃ³n

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FLUJO DE VERIFICACIÃ“N DE TERMINACIÃ“N                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                        â”‚
â”‚                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚                         â”‚   START     â”‚                                â”‚
â”‚                         â”‚  (despuÃ©s   â”‚                                â”‚
â”‚                         â”‚  de ACT)    â”‚                                â”‚
â”‚                         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚                                â”‚                                       â”‚
â”‚                                â–¼                                       â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚                    â”‚ Â¿Respuesta Final      â”‚                          â”‚
â”‚                    â”‚  detectada?           â”‚â”€â”€â”€â”€â”€â”€Yesâ”€â”€â”€â”€â”€â”€â”          â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚          â”‚
â”‚                                â”‚No                         â”‚          â”‚
â”‚                                â–¼                           â”‚          â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚          â”‚
â”‚                    â”‚ Â¿LÃ­mite de iteracionesâ”‚               â”‚          â”‚
â”‚                    â”‚  alcanzado?           â”‚â”€â”€â”€â”€â”€â”€Yesâ”€â”€â”€â”€â”€â”€â”¤          â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚          â”‚
â”‚                                â”‚No                         â”‚          â”‚
â”‚                                â–¼                           â”‚          â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚          â”‚
â”‚                    â”‚ Â¿Timeout excedido?    â”‚               â”‚          â”‚
â”‚                    â”‚                       â”‚â”€â”€â”€â”€â”€â”€Yesâ”€â”€â”€â”€â”€â”€â”¤          â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚          â”‚
â”‚                                â”‚No                         â”‚          â”‚
â”‚                                â–¼                           â”‚          â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚          â”‚
â”‚                    â”‚ Â¿Budget agotado?      â”‚               â”‚          â”‚
â”‚                    â”‚                       â”‚â”€â”€â”€â”€â”€â”€Yesâ”€â”€â”€â”€â”€â”€â”¤          â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚          â”‚
â”‚                                â”‚No                         â”‚          â”‚
â”‚                                â–¼                           â”‚          â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚          â”‚
â”‚                    â”‚ Â¿Bucle detectado?     â”‚               â”‚          â”‚
â”‚                    â”‚                       â”‚â”€â”€â”€â”€â”€â”€Yesâ”€â”€â”€â”€â”€â”€â”¤          â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚          â”‚
â”‚                                â”‚No                         â”‚          â”‚
â”‚                                â–¼                           â”‚          â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚          â”‚
â”‚                    â”‚ Â¿Error irrecuperable? â”‚               â”‚          â”‚
â”‚                    â”‚                       â”‚â”€â”€â”€â”€â”€â”€Yesâ”€â”€â”€â”€â”€â”€â”¤          â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚          â”‚
â”‚                                â”‚No                         â–¼          â”‚
â”‚                                â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚                                â–¼                    â”‚  TERMINAR   â”‚   â”‚
â”‚                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚  + Generar  â”‚   â”‚
â”‚                         â”‚  CONTINUAR  â”‚            â”‚  resumen    â”‚   â”‚
â”‚                         â”‚  bucle OTA  â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â”‚
â”‚                                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ImplementaciÃ³n del Sistema de TerminaciÃ³n

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Optional, Callable
from enum import Enum, auto
from abc import ABC, abstractmethod
import time
import hashlib
import os

class TerminationReason(Enum):
    """Razones por las que un agente puede terminar."""
    GOAL_COMPLETED = auto()      # Objetivo cumplido
    FINAL_ANSWER = auto()        # Respuesta final generada
    MAX_ITERATIONS = auto()      # LÃ­mite de iteraciones
    TIMEOUT = auto()             # Tiempo agotado
    BUDGET_EXCEEDED = auto()     # Presupuesto excedido
    LOOP_DETECTED = auto()       # Bucle detectado
    ERROR = auto()               # Error irrecuperable
    LOW_CONFIDENCE = auto()      # Confianza muy baja
    USER_INTERRUPT = auto()      # InterrupciÃ³n del usuario
    NO_PROGRESS = auto()         # Sin progreso

@dataclass
class TerminationResult:
    """Resultado de la verificaciÃ³n de terminaciÃ³n."""
    should_terminate: bool
    reason: Optional[TerminationReason] = None
    message: str = ""
    partial_result: Optional[str] = None


class TerminationCondition(ABC):
    """Interfaz base para condiciones de terminaciÃ³n."""

    @abstractmethod
    def check(self, context: 'AgentContext') -> TerminationResult:
        """Verifica si se debe terminar."""
        pass

    @property
    @abstractmethod
    def priority(self) -> int:
        """Prioridad de esta condiciÃ³n (mayor = se verifica primero)."""
        pass


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONDICIONES EXPLÃCITAS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class FinalAnswerCondition(TerminationCondition):
    """Termina cuando el modelo genera una respuesta final."""

    FINAL_MARKERS = [
        "Final Answer:",
        "Respuesta Final:",
        "FINAL:",
        "[DONE]",
        "[COMPLETE]"
    ]

    @property
    def priority(self) -> int:
        return 100  # Alta prioridad

    def check(self, context: 'AgentContext') -> TerminationResult:
        if not context.thoughts:
            return TerminationResult(False)

        last_thought = context.thoughts[-1]
        content = str(last_thought.decision) + str(last_thought.analysis)

        for marker in self.FINAL_MARKERS:
            if marker.lower() in content.lower():
                # Extraer la respuesta final
                for marker in self.FINAL_MARKERS:
                    if marker.lower() in content.lower():
                        idx = content.lower().find(marker.lower())
                        answer = content[idx + len(marker):].strip()
                        break

                return TerminationResult(
                    should_terminate=True,
                    reason=TerminationReason.FINAL_ANSWER,
                    message="El agente proporcionÃ³ una respuesta final",
                    partial_result=answer
                )

        return TerminationResult(False)


class GoalCompletedCondition(TerminationCondition):
    """Termina cuando el objetivo estÃ¡ explÃ­citamente completado."""

    def __init__(self, model: genai.GenerativeModel):
        self.model = model

    @property
    def priority(self) -> int:
        return 95

    def check(self, context: 'AgentContext') -> TerminationResult:
        if context.iteration < 2:
            return TerminationResult(False)

        # Usar el modelo para verificar si el objetivo se cumpliÃ³
        prompt = f"""Analiza si el objetivo ha sido cumplido.

OBJETIVO: {context.goal}

ACCIONES REALIZADAS:
{self._format_actions(context)}

Â¿El objetivo se ha cumplido completamente?
Responde SOLO con: YES o NO seguido de una breve explicaciÃ³n."""

        response = self.model.generate_content(prompt)

        if response.text.strip().upper().startswith("YES"):
            return TerminationResult(
                should_terminate=True,
                reason=TerminationReason.GOAL_COMPLETED,
                message=response.text
            )

        return TerminationResult(False)

    def _format_actions(self, context: 'AgentContext') -> str:
        actions = []
        for i, action in enumerate(context.actions_taken[-5:], 1):
            actions.append(f"{i}. {action.action_type}: {action.payload}")
        return "\n".join(actions)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONDICIONES IMPLÃCITAS (LÃMITES)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MaxIterationsCondition(TerminationCondition):
    """Termina despuÃ©s de N iteraciones."""

    def __init__(self, max_iterations: int = 10):
        self.max_iterations = max_iterations

    @property
    def priority(self) -> int:
        return 80

    def check(self, context: 'AgentContext') -> TerminationResult:
        if context.iteration >= self.max_iterations:
            return TerminationResult(
                should_terminate=True,
                reason=TerminationReason.MAX_ITERATIONS,
                message=f"Alcanzado lÃ­mite de {self.max_iterations} iteraciones"
            )
        return TerminationResult(False)


class TimeoutCondition(TerminationCondition):
    """Termina despuÃ©s de T segundos."""

    def __init__(self, timeout_seconds: float = 300):
        self.timeout_seconds = timeout_seconds
        self.start_time: Optional[float] = None

    @property
    def priority(self) -> int:
        return 85

    def start(self):
        """Inicia el temporizador."""
        self.start_time = time.time()

    def check(self, context: 'AgentContext') -> TerminationResult:
        if self.start_time is None:
            self.start()

        elapsed = time.time() - self.start_time

        if elapsed >= self.timeout_seconds:
            return TerminationResult(
                should_terminate=True,
                reason=TerminationReason.TIMEOUT,
                message=f"Tiempo agotado ({elapsed:.1f}s >= {self.timeout_seconds}s)"
            )
        return TerminationResult(False)


class BudgetCondition(TerminationCondition):
    """Termina cuando se excede el presupuesto de tokens."""

    def __init__(self, max_tokens: int = 50000):
        self.max_tokens = max_tokens
        self.tokens_used = 0

    @property
    def priority(self) -> int:
        return 90

    def add_tokens(self, count: int):
        """Registra tokens utilizados."""
        self.tokens_used += count

    def check(self, context: 'AgentContext') -> TerminationResult:
        if self.tokens_used >= self.max_tokens:
            return TerminationResult(
                should_terminate=True,
                reason=TerminationReason.BUDGET_EXCEEDED,
                message=f"Presupuesto excedido ({self.tokens_used} >= {self.max_tokens} tokens)"
            )
        return TerminationResult(False)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONDICIONES EMERGENTES (DETECCIÃ“N DE PROBLEMAS)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class LoopDetectionCondition(TerminationCondition):
    """Detecta y termina en caso de bucles."""

    def __init__(self, window_size: int = 5, threshold: float = 0.8):
        self.window_size = window_size
        self.threshold = threshold
        self.state_hashes: list[str] = []

    @property
    def priority(self) -> int:
        return 75

    def check(self, context: 'AgentContext') -> TerminationResult:
        # Calcular hash del estado actual
        current_state = self._get_state_hash(context)
        self.state_hashes.append(current_state)

        # Mantener solo la ventana
        if len(self.state_hashes) > self.window_size * 2:
            self.state_hashes = self.state_hashes[-self.window_size * 2:]

        # Verificar repeticiones en la ventana
        if len(self.state_hashes) >= self.window_size:
            recent = self.state_hashes[-self.window_size:]
            unique_ratio = len(set(recent)) / len(recent)

            if unique_ratio < (1 - self.threshold):
                return TerminationResult(
                    should_terminate=True,
                    reason=TerminationReason.LOOP_DETECTED,
                    message=f"Bucle detectado: {unique_ratio:.0%} estados Ãºnicos"
                )

        return TerminationResult(False)

    def _get_state_hash(self, context: 'AgentContext') -> str:
        """Genera un hash del estado actual."""
        if context.thoughts:
            last = context.thoughts[-1]
            state_str = f"{last.decision}:{last.analysis[:100]}"
        else:
            state_str = str(context.iteration)

        return hashlib.md5(state_str.encode()).hexdigest()[:8]


class NoProgressCondition(TerminationCondition):
    """Detecta cuando no hay progreso significativo."""

    def __init__(self, patience: int = 3):
        self.patience = patience

    @property
    def priority(self) -> int:
        return 70

    def check(self, context: 'AgentContext') -> TerminationResult:
        if len(context.thoughts) < self.patience:
            return TerminationResult(False)

        recent = context.thoughts[-self.patience:]

        # Verificar si todas las confianzas son bajas
        low_confidence = all(t.confidence < 0.3 for t in recent)

        # Verificar si las decisiones son similares
        decisions = [t.decision.lower().strip() for t in recent]
        similar_decisions = len(set(decisions)) == 1

        if low_confidence or similar_decisions:
            return TerminationResult(
                should_terminate=True,
                reason=TerminationReason.NO_PROGRESS,
                message="No hay progreso significativo"
            )

        return TerminationResult(False)


class LowConfidenceCondition(TerminationCondition):
    """Termina si la confianza cae consistentemente."""

    def __init__(self, threshold: float = 0.2, consecutive: int = 3):
        self.threshold = threshold
        self.consecutive = consecutive

    @property
    def priority(self) -> int:
        return 65

    def check(self, context: 'AgentContext') -> TerminationResult:
        if len(context.thoughts) < self.consecutive:
            return TerminationResult(False)

        recent = context.thoughts[-self.consecutive:]
        all_low = all(t.confidence < self.threshold for t in recent)

        if all_low:
            avg_confidence = sum(t.confidence for t in recent) / len(recent)
            return TerminationResult(
                should_terminate=True,
                reason=TerminationReason.LOW_CONFIDENCE,
                message=f"Confianza consistentemente baja ({avg_confidence:.0%})"
            )

        return TerminationResult(False)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MANAGER DE TERMINACIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class TerminationManager:
    """
    Gestiona mÃºltiples condiciones de terminaciÃ³n.
    """

    def __init__(self):
        self.conditions: list[TerminationCondition] = []

    def add_condition(self, condition: TerminationCondition):
        """Agrega una condiciÃ³n y ordena por prioridad."""
        self.conditions.append(condition)
        self.conditions.sort(key=lambda c: c.priority, reverse=True)

    def add_default_conditions(self, model: genai.GenerativeModel):
        """Agrega un conjunto de condiciones por defecto."""
        self.add_condition(FinalAnswerCondition())
        self.add_condition(GoalCompletedCondition(model))
        self.add_condition(MaxIterationsCondition(10))
        self.add_condition(TimeoutCondition(300))
        self.add_condition(LoopDetectionCondition())
        self.add_condition(NoProgressCondition())

    def check_all(self, context: 'AgentContext') -> TerminationResult:
        """Verifica todas las condiciones en orden de prioridad."""
        for condition in self.conditions:
            result = condition.check(context)
            if result.should_terminate:
                return result

        return TerminationResult(should_terminate=False)

    def get_status(self, context: 'AgentContext') -> dict:
        """Obtiene el estado de todas las condiciones."""
        return {
            type(cond).__name__: cond.check(context).should_terminate
            for cond in self.conditions
        }
```

## IntegraciÃ³n con el Agente

```python
@dataclass
class AgentContext:
    """Contexto del agente (simplificado)."""
    goal: str
    thoughts: list = field(default_factory=list)
    actions_taken: list = field(default_factory=list)
    observations: list = field(default_factory=list)
    iteration: int = 0

@dataclass
class Thought:
    decision: str
    analysis: str
    confidence: float

@dataclass
class Action:
    action_type: str
    payload: dict


class AgentWithTermination:
    """
    Agente con sistema de terminaciÃ³n integrado.
    """

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)

        # Configurar manager de terminaciÃ³n
        self.termination = TerminationManager()
        self.termination.add_default_conditions(self.model)

    def run(self, goal: str) -> tuple['AgentContext', TerminationResult]:
        """Ejecuta el agente con verificaciÃ³n de terminaciÃ³n."""
        context = AgentContext(goal=goal)

        print(f"\nğŸ¯ Objetivo: {goal}\n")

        while True:
            context.iteration += 1
            print(f"--- IteraciÃ³n {context.iteration} ---")

            # Ejecutar ciclo OTA (simplificado)
            thought = self._think(context)
            context.thoughts.append(thought)

            action = self._act(thought)
            context.actions_taken.append(action)

            print(f"  DecisiÃ³n: {thought.decision[:50]}...")
            print(f"  Confianza: {thought.confidence:.0%}")

            # â•â•â• VERIFICAR TERMINACIÃ“N â•â•â•
            term_result = self.termination.check_all(context)

            if term_result.should_terminate:
                print(f"\nğŸ›‘ TERMINACIÃ“N: {term_result.reason.name}")
                print(f"   Mensaje: {term_result.message}")

                # Generar respuesta final si no hay
                if not term_result.partial_result:
                    term_result.partial_result = self._generate_final_response(
                        context, term_result.reason
                    )

                return context, term_result

            # Mostrar estado de condiciones
            status = self.termination.get_status(context)
            warnings = [k for k, v in status.items() if "Loop" in k or "Progress" in k]
            if warnings:
                print(f"  âš ï¸  Warnings: {warnings}")

    def _think(self, context: 'AgentContext') -> Thought:
        """Fase de pensamiento (simplificada)."""
        prompt = f"""Objetivo: {context.goal}
IteraciÃ³n: {context.iteration}

Decide la siguiente acciÃ³n. Si tienes suficiente informaciÃ³n,
usa "Final Answer:" seguido de tu respuesta.

Responde con:
- Tu anÃ¡lisis breve
- Tu decisiÃ³n
- Confianza (0-100)"""

        response = self.model.generate_content(prompt)

        # Parsear respuesta (simplificado)
        text = response.text
        confidence = 0.5

        # Intentar extraer confianza
        import re
        conf_match = re.search(r'(\d{1,3})%?', text)
        if conf_match:
            confidence = min(int(conf_match.group(1)), 100) / 100

        return Thought(
            decision=text[:200],
            analysis=text,
            confidence=confidence
        )

    def _act(self, thought: Thought) -> Action:
        """Fase de acciÃ³n (simplificada)."""
        return Action(
            action_type="think",
            payload={"thought": thought.decision}
        )

    def _generate_final_response(
        self,
        context: 'AgentContext',
        reason: TerminationReason
    ) -> str:
        """Genera una respuesta final basada en la razÃ³n de terminaciÃ³n."""

        if reason == TerminationReason.MAX_ITERATIONS:
            prefix = "AlcancÃ© el lÃ­mite de iteraciones. BasÃ¡ndome en lo investigado: "
        elif reason == TerminationReason.TIMEOUT:
            prefix = "El tiempo se agotÃ³. Con la informaciÃ³n disponible: "
        elif reason == TerminationReason.LOOP_DETECTED:
            prefix = "DetectÃ© que estaba en un bucle. Mi mejor respuesta es: "
        else:
            prefix = "BasÃ¡ndome en mi anÃ¡lisis: "

        # Resumir los pensamientos
        thoughts_summary = "\n".join([
            f"- {t.decision[:100]}" for t in context.thoughts[-3:]
        ])

        prompt = f"""Genera una respuesta final concisa.

Objetivo original: {context.goal}
Contexto de terminaciÃ³n: {prefix}

Pensamientos recientes:
{thoughts_summary}

Proporciona la mejor respuesta posible en 2-3 oraciones."""

        response = self.model.generate_content(prompt)
        return prefix + response.text


# Uso
agent = AgentWithTermination()
context, result = agent.run("Â¿CuÃ¡l es la capital de Francia y su poblaciÃ³n aproximada?")

print("\n" + "="*50)
print("RESULTADO FINAL")
print("="*50)
print(f"RazÃ³n: {result.reason.name}")
print(f"Respuesta: {result.partial_result}")
print(f"Iteraciones: {context.iteration}")
```

## PatrÃ³n: Graceful Degradation

```python
class GracefulTermination:
    """
    Maneja terminaciÃ³n con degradaciÃ³n elegante.
    Intenta dar una respuesta Ãºtil incluso en terminaciÃ³n forzada.
    """

    def __init__(self, model: genai.GenerativeModel):
        self.model = model

    def handle_termination(
        self,
        context: 'AgentContext',
        reason: TerminationReason
    ) -> str:
        """
        Genera la mejor respuesta posible dada la razÃ³n de terminaciÃ³n.
        """

        # Recolectar informaciÃ³n disponible
        info = self._collect_information(context)

        # Estrategia segÃºn la razÃ³n
        strategies = {
            TerminationReason.GOAL_COMPLETED: self._complete_response,
            TerminationReason.FINAL_ANSWER: self._extract_answer,
            TerminationReason.MAX_ITERATIONS: self._best_effort_response,
            TerminationReason.TIMEOUT: self._quick_summary,
            TerminationReason.LOOP_DETECTED: self._break_loop_response,
            TerminationReason.LOW_CONFIDENCE: self._uncertain_response,
            TerminationReason.NO_PROGRESS: self._no_progress_response,
        }

        handler = strategies.get(reason, self._default_response)
        return handler(context, info)

    def _collect_information(self, context: 'AgentContext') -> dict:
        """Recolecta toda la informaciÃ³n Ãºtil del contexto."""
        return {
            "goal": context.goal,
            "iterations": context.iteration,
            "thoughts": [t.decision for t in context.thoughts],
            "actions": [a.action_type for a in context.actions_taken],
            "last_confidence": context.thoughts[-1].confidence if context.thoughts else 0
        }

    def _complete_response(self, context, info) -> str:
        """Respuesta cuando el objetivo estÃ¡ completo."""
        return f"âœ… Objetivo completado: {info['thoughts'][-1]}"

    def _extract_answer(self, context, info) -> str:
        """Extrae la respuesta final del Ãºltimo pensamiento."""
        last = context.thoughts[-1].analysis
        if "Final Answer:" in last:
            return last.split("Final Answer:")[-1].strip()
        return last

    def _best_effort_response(self, context, info) -> str:
        """Mejor respuesta posible con la informaciÃ³n disponible."""
        prompt = f"""BasÃ¡ndote en esta informaciÃ³n parcial, genera la mejor respuesta posible.

Objetivo: {info['goal']}
InformaciÃ³n recolectada: {info['thoughts'][-3:]}

Genera una respuesta Ãºtil, indicando claramente quÃ© partes son inciertas."""

        response = self.model.generate_content(prompt)
        return f"âš ï¸ Respuesta parcial (lÃ­mite de iteraciones): {response.text}"

    def _quick_summary(self, context, info) -> str:
        """Resumen rÃ¡pido por timeout."""
        key_points = info['thoughts'][-2:] if info['thoughts'] else ["Sin informaciÃ³n"]
        return f"â±ï¸ Tiempo agotado. Puntos clave: {'; '.join(key_points)}"

    def _break_loop_response(self, context, info) -> str:
        """Respuesta cuando se detecta un bucle."""
        unique_thoughts = list(set(info['thoughts']))
        return f"ğŸ”„ Proceso en bucle detectado. Ideas principales: {unique_thoughts[:3]}"

    def _uncertain_response(self, context, info) -> str:
        """Respuesta cuando hay baja confianza."""
        return f"â“ No tengo suficiente certeza. Mi mejor estimaciÃ³n: {info['thoughts'][-1]}"

    def _no_progress_response(self, context, info) -> str:
        """Respuesta cuando no hay progreso."""
        return f"âš¡ No pude avanzar mÃ¡s. Ãšltima observaciÃ³n: {info['thoughts'][-1] if info['thoughts'] else 'N/A'}"

    def _default_response(self, context, info) -> str:
        """Respuesta por defecto."""
        return f"Proceso terminado. InformaciÃ³n disponible: {info['thoughts'][-1] if info['thoughts'] else 'Ninguna'}"
```

## Errores Comunes y Soluciones

### 1. TerminaciÃ³n Prematura

```python
# âŒ MAL: Terminar demasiado pronto
class TooEagerTermination(TerminationCondition):
    def check(self, context):
        if context.iteration > 1:  # Â¡Muy pronto!
            return TerminationResult(True, TerminationReason.MAX_ITERATIONS)

# âœ… BIEN: Dar suficiente oportunidad
class BalancedTermination(TerminationCondition):
    def check(self, context):
        min_iterations = 3  # MÃ­nimo antes de considerar terminar

        if context.iteration < min_iterations:
            return TerminationResult(False)

        # Verificar si realmente hay progreso o no
        if self._has_meaningful_progress(context):
            return TerminationResult(False)

        return TerminationResult(True, ...)
```

### 2. Nunca Terminar

```python
# âŒ MAL: Condiciones imposibles
class NeverEndsCondition(TerminationCondition):
    def check(self, context):
        # Esto nunca serÃ¡ True si el modelo es creativo
        if context.thoughts[-1].confidence == 1.0:
            return TerminationResult(True, ...)
        return TerminationResult(False)

# âœ… BIEN: Siempre tener fallback
class SafeTermination:
    def check_with_fallback(self, context):
        # Verificar condiciones normales
        for cond in self.conditions:
            result = cond.check(context)
            if result.should_terminate:
                return result

        # FALLBACK: LÃ­mite absoluto
        if context.iteration >= 100:  # Nunca mÃ¡s de 100
            return TerminationResult(
                True,
                TerminationReason.MAX_ITERATIONS,
                "Fallback de seguridad activado"
            )

        return TerminationResult(False)
```

### 3. Ignorar el Contexto

```python
# âŒ MAL: Misma condiciÃ³n para todo
max_iterations = 10  # Fijo para todas las tareas

# âœ… BIEN: Adaptar segÃºn la complejidad
def get_dynamic_limit(goal: str, context: dict) -> int:
    """Calcula lÃ­mite dinÃ¡mico basado en la tarea."""
    base = 5

    # Tareas complejas necesitan mÃ¡s iteraciones
    complexity_keywords = ["analiza", "compara", "investiga", "diseÃ±a"]
    for keyword in complexity_keywords:
        if keyword in goal.lower():
            base += 5

    # Si hay herramientas disponibles, dar mÃ¡s margen
    if context.get("tools_count", 0) > 3:
        base += 3

    return min(base, 20)  # MÃ¡ximo 20
```

## Resumen

Las **condiciones de terminaciÃ³n** controlan cuÃ¡ndo un agente debe detenerse:

| Tipo | Ejemplos | Prioridad |
|------|----------|-----------|
| ExplÃ­citas | Final Answer, Goal Completed | Alta |
| ImplÃ­citas | Max Iterations, Timeout, Budget | Media |
| Emergentes | Loop Detection, No Progress | Variable |

**Mejores prÃ¡cticas**:
1. Siempre tener mÃºltiples condiciones como red de seguridad
2. Ordenar por prioridad (condiciones de Ã©xito primero)
3. Implementar "graceful degradation" para terminaciones forzadas
4. Adaptar lÃ­mites segÃºn la complejidad de la tarea
5. Monitorear y alertar en terminaciones anÃ³malas

---

## NavegaciÃ³n

- **Anterior**: [4.1.2 Bucle Observe-Think-Act](./4.1.2-bucle-observe-think-act.md)
- **Siguiente**: [4.2.1 Task Decomposition AutomÃ¡tica](../tema_4.2/4.2.1-task-decomposition.md)
- **Ãndice**: [README del Curso](../../README.md)
