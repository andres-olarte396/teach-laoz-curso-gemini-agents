# 4.3.2 Agente de An√°lisis de Datos

## Tiempo estimado: 90 minutos
## Nivel: Intermedio-Avanzado

## Prerrequisitos
- Modelo ReAct (4.1.1)
- Function Calling (M√≥dulo 3)
- Conocimientos b√°sicos de pandas y an√°lisis de datos

## ¬øPor qu√© es importante?

Un **agente de an√°lisis de datos** puede democratizar el acceso a insights:
- Permite a no-t√©cnicos hacer an√°lisis complejos con lenguaje natural
- Automatiza tareas repetitivas de an√°lisis
- Genera visualizaciones y reportes autom√°ticamente
- Identifica patrones y anomal√≠as en datasets

Este tipo de agente es fundamental para business intelligence y toma de decisiones basada en datos.

## Arquitectura del Agente de An√°lisis

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    AGENTE DE AN√ÅLISIS DE DATOS                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                     QUERY EN LENGUAJE NATURAL                    ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   "¬øCu√°les fueron las ventas por regi√≥n el √∫ltimo trimestre?"   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                   INT√âRPRETE DE CONSULTAS                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Analizar intenci√≥n del usuario                               ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Identificar m√©tricas requeridas                              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Determinar filtros y agrupaciones                           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Seleccionar tipo de an√°lisis                                ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                   GENERADOR DE C√ìDIGO                            ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   Query Natural ‚îÄ‚îÄ‚ñ∂ C√≥digo Python/Pandas                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   "ventas por regi√≥n" ‚îÄ‚îÄ‚ñ∂ df.groupby('region')['ventas'].sum()  ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                   EJECUTOR SEGURO                                ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ  Validar    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Ejecutar   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Capturar   ‚îÇ       ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ  C√≥digo     ‚îÇ     ‚îÇ  Sandbox    ‚îÇ     ‚îÇ  Resultado  ‚îÇ       ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                   GENERADOR DE INSIGHTS                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Interpretar resultados num√©ricos                            ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Generar visualizaciones                                      ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Identificar tendencias y anomal√≠as                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Crear narrativa explicativa                                 ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                     RESPUESTA AL USUARIO                         ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   üìä Visualizaci√≥n + üìù Insights + üìà Recomendaciones           ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n Completa

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Optional, Any, Union
import json
import pandas as pd
import numpy as np
from io import StringIO
import ast
import os

@dataclass
class AnalysisResult:
    """Resultado de un an√°lisis."""
    query: str
    code_generated: str
    result_data: Any
    result_type: str  # dataframe, series, scalar, error
    execution_time: float
    insights: list[str] = field(default_factory=list)
    visualization_code: Optional[str] = None

@dataclass
class DatasetInfo:
    """Informaci√≥n sobre un dataset."""
    name: str
    columns: list[str]
    dtypes: dict[str, str]
    shape: tuple[int, int]
    sample_values: dict[str, list]


class QueryInterpreter:
    """
    Interpreta consultas en lenguaje natural y genera planes de an√°lisis.
    """

    def __init__(self, model: genai.GenerativeModel):
        self.model = model

    def interpret(self, query: str, dataset_info: DatasetInfo) -> dict:
        """Interpreta una consulta y genera un plan de an√°lisis."""

        prompt = f"""Analiza esta consulta de an√°lisis de datos:

CONSULTA: {query}

DATASET DISPONIBLE: {dataset_info.name}
COLUMNAS: {dataset_info.columns}
TIPOS DE DATOS: {dataset_info.dtypes}
FILAS: {dataset_info.shape[0]}
VALORES DE EJEMPLO: {json.dumps(dataset_info.sample_values, indent=2)}

Genera un plan de an√°lisis en JSON:
{{
    "intent": "aggregation|filtering|comparison|trend|correlation|distribution",
    "metrics": ["columna1", "columna2"],
    "groupby": ["columna_agrupacion"] o null,
    "filters": {{"columna": "condici√≥n"}} o null,
    "aggregations": ["sum", "mean", "count", etc.],
    "time_range": "especificar si aplica" o null,
    "visualization_type": "bar|line|scatter|pie|histogram|heatmap|none",
    "complexity": "simple|medium|complex"
}}

Responde SOLO con el JSON."""

        response = self.model.generate_content(prompt)

        try:
            text = response.text.strip()
            if text.startswith("```"):
                text = text.split("```")[1]
                if text.startswith("json"):
                    text = text[4:]
            return json.loads(text)
        except:
            return {
                "intent": "unknown",
                "metrics": dataset_info.columns[:2],
                "groupby": None,
                "filters": None,
                "aggregations": ["count"],
                "visualization_type": "bar",
                "complexity": "simple"
            }


class CodeGenerator:
    """
    Genera c√≥digo Python/Pandas a partir de planes de an√°lisis.
    """

    def __init__(self, model: genai.GenerativeModel):
        self.model = model

    def generate_code(
        self,
        query: str,
        plan: dict,
        dataset_info: DatasetInfo
    ) -> str:
        """Genera c√≥digo pandas para el an√°lisis."""

        prompt = f"""Genera c√≥digo Python/Pandas para este an√°lisis:

CONSULTA ORIGINAL: {query}

PLAN DE AN√ÅLISIS:
{json.dumps(plan, indent=2)}

INFORMACI√ìN DEL DATASET:
- Variable: df
- Columnas: {dataset_info.columns}
- Tipos: {dataset_info.dtypes}

REGLAS:
1. Usa SOLO pandas y numpy (ya importados como pd y np)
2. El DataFrame se llama 'df'
3. Guarda el resultado final en una variable llamada 'result'
4. NO uses print() - solo asigna a 'result'
5. Maneja posibles valores nulos con .fillna() o .dropna() si es necesario
6. Para fechas, usa pd.to_datetime() si es necesario

Genera SOLO el c√≥digo Python, sin explicaciones ni markdown."""

        response = self.model.generate_content(prompt)
        code = response.text.strip()

        # Limpiar c√≥digo de markdown
        if code.startswith("```"):
            code = code.split("```")[1]
            if code.startswith("python"):
                code = code[6:]
            code = code.strip()

        return code

    def generate_visualization_code(
        self,
        result_data: Any,
        viz_type: str,
        title: str
    ) -> str:
        """Genera c√≥digo para visualizaci√≥n."""

        if viz_type == "none":
            return ""

        viz_templates = {
            "bar": """
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(10, 6))
result.plot(kind='bar', ax=ax)
ax.set_title('{title}')
ax.set_xlabel('Categor√≠a')
ax.set_ylabel('Valor')
plt.tight_layout()
plt.savefig('analysis_chart.png', dpi=100)
plt.close()
""",
            "line": """
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(10, 6))
result.plot(kind='line', ax=ax, marker='o')
ax.set_title('{title}')
plt.tight_layout()
plt.savefig('analysis_chart.png', dpi=100)
plt.close()
""",
            "pie": """
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(8, 8))
result.plot(kind='pie', ax=ax, autopct='%1.1f%%')
ax.set_title('{title}')
ax.set_ylabel('')
plt.tight_layout()
plt.savefig('analysis_chart.png', dpi=100)
plt.close()
""",
            "histogram": """
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(10, 6))
result.hist(bins=20, ax=ax)
ax.set_title('{title}')
ax.set_xlabel('Valor')
ax.set_ylabel('Frecuencia')
plt.tight_layout()
plt.savefig('analysis_chart.png', dpi=100)
plt.close()
""",
            "scatter": """
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(10, 6))
ax.scatter(result.iloc[:, 0], result.iloc[:, 1])
ax.set_title('{title}')
plt.tight_layout()
plt.savefig('analysis_chart.png', dpi=100)
plt.close()
"""
        }

        template = viz_templates.get(viz_type, viz_templates["bar"])
        return template.format(title=title)


class SafeExecutor:
    """
    Ejecuta c√≥digo de an√°lisis de forma segura.
    """

    # Funciones permitidas
    ALLOWED_MODULES = {'pd', 'np', 'pandas', 'numpy'}
    FORBIDDEN_PATTERNS = [
        'import os', 'import sys', 'import subprocess',
        'exec(', 'eval(', '__import__', 'open(',
        'os.', 'sys.', 'subprocess.'
    ]

    def __init__(self):
        self.execution_context = {}

    def validate_code(self, code: str) -> tuple[bool, str]:
        """Valida que el c√≥digo sea seguro."""
        # Verificar patrones prohibidos
        for pattern in self.FORBIDDEN_PATTERNS:
            if pattern in code:
                return False, f"Patr√≥n prohibido encontrado: {pattern}"

        # Verificar sintaxis
        try:
            ast.parse(code)
        except SyntaxError as e:
            return False, f"Error de sintaxis: {e}"

        return True, "OK"

    def execute(self, code: str, df: pd.DataFrame) -> tuple[Any, float]:
        """Ejecuta c√≥digo de forma segura."""
        import time

        # Validar primero
        is_valid, message = self.validate_code(code)
        if not is_valid:
            raise ValueError(f"C√≥digo inv√°lido: {message}")

        # Preparar contexto de ejecuci√≥n
        exec_globals = {
            'pd': pd,
            'np': np,
            'df': df.copy(),  # Copia para no modificar original
            '__builtins__': {
                'len': len,
                'range': range,
                'list': list,
                'dict': dict,
                'str': str,
                'int': int,
                'float': float,
                'bool': bool,
                'sum': sum,
                'min': min,
                'max': max,
                'sorted': sorted,
                'round': round,
                'abs': abs,
                'True': True,
                'False': False,
                'None': None
            }
        }
        exec_locals = {}

        # Ejecutar con timeout simulado
        start_time = time.time()

        try:
            exec(code, exec_globals, exec_locals)
            execution_time = time.time() - start_time

            # Obtener resultado
            result = exec_locals.get('result', None)
            if result is None:
                # Buscar √∫ltima variable asignada
                for var_name in reversed(list(exec_locals.keys())):
                    if not var_name.startswith('_'):
                        result = exec_locals[var_name]
                        break

            return result, execution_time

        except Exception as e:
            execution_time = time.time() - start_time
            raise RuntimeError(f"Error de ejecuci√≥n: {e}")


class InsightGenerator:
    """
    Genera insights a partir de resultados de an√°lisis.
    """

    def __init__(self, model: genai.GenerativeModel):
        self.model = model

    def generate_insights(
        self,
        query: str,
        result: Any,
        result_type: str
    ) -> list[str]:
        """Genera insights a partir de los resultados."""

        # Formatear resultado para el prompt
        if isinstance(result, pd.DataFrame):
            result_str = result.to_string(max_rows=20)
            stats = result.describe().to_string()
        elif isinstance(result, pd.Series):
            result_str = result.to_string(max_rows=20)
            stats = f"Media: {result.mean():.2f}, Mediana: {result.median():.2f}"
        else:
            result_str = str(result)
            stats = ""

        prompt = f"""Analiza estos resultados y genera insights:

CONSULTA ORIGINAL: {query}

TIPO DE RESULTADO: {result_type}

RESULTADOS:
{result_str}

{f'ESTAD√çSTICAS: {stats}' if stats else ''}

Genera 3-5 insights clave en formato lista:
- Insight 1: [observaci√≥n importante]
- Insight 2: [tendencia o patr√≥n]
- Insight 3: [recomendaci√≥n o acci√≥n]
...

S√© espec√≠fico y menciona n√∫meros concretos de los datos."""

        response = self.model.generate_content(prompt)
        text = response.text.strip()

        insights = []
        for line in text.split("\n"):
            line = line.strip()
            if line.startswith("-") or line.startswith("‚Ä¢") or line.startswith("*"):
                insight = line.lstrip("-‚Ä¢* ").strip()
                if insight:
                    insights.append(insight)

        return insights[:5]  # M√°ximo 5 insights


class DataAnalysisAgent:
    """
    Agente completo de an√°lisis de datos.
    """

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)

        self.interpreter = QueryInterpreter(self.model)
        self.code_generator = CodeGenerator(self.model)
        self.executor = SafeExecutor()
        self.insight_generator = InsightGenerator(self.model)

        self.current_df: Optional[pd.DataFrame] = None
        self.current_info: Optional[DatasetInfo] = None
        self.history: list[AnalysisResult] = []

    def load_data(self, data: Union[pd.DataFrame, str, dict]) -> DatasetInfo:
        """Carga datos en el agente."""
        if isinstance(data, pd.DataFrame):
            self.current_df = data
        elif isinstance(data, str):
            # Intentar cargar como CSV
            if data.endswith('.csv'):
                self.current_df = pd.read_csv(data)
            elif data.endswith('.json'):
                self.current_df = pd.read_json(data)
            else:
                # Intentar parsear como CSV string
                self.current_df = pd.read_csv(StringIO(data))
        elif isinstance(data, dict):
            self.current_df = pd.DataFrame(data)
        else:
            raise ValueError(f"Tipo de datos no soportado: {type(data)}")

        # Generar info del dataset
        self.current_info = DatasetInfo(
            name="df",
            columns=list(self.current_df.columns),
            dtypes={col: str(dtype) for col, dtype in self.current_df.dtypes.items()},
            shape=self.current_df.shape,
            sample_values={
                col: self.current_df[col].dropna().head(3).tolist()
                for col in self.current_df.columns[:10]
            }
        )

        return self.current_info

    def analyze(self, query: str) -> AnalysisResult:
        """
        Analiza datos bas√°ndose en una consulta en lenguaje natural.

        Args:
            query: Consulta en lenguaje natural

        Returns:
            AnalysisResult con todos los detalles del an√°lisis
        """
        if self.current_df is None:
            raise ValueError("No hay datos cargados. Usa load_data() primero.")

        print(f"\n{'='*60}")
        print(f"üìä AN√ÅLISIS: {query}")
        print(f"{'='*60}\n")

        # 1. Interpretar consulta
        print("üîç Interpretando consulta...")
        plan = self.interpreter.interpret(query, self.current_info)
        print(f"   Intent: {plan.get('intent')}")
        print(f"   M√©tricas: {plan.get('metrics')}")
        print(f"   Agrupaci√≥n: {plan.get('groupby')}")

        # 2. Generar c√≥digo
        print("\nüíª Generando c√≥digo...")
        code = self.code_generator.generate_code(query, plan, self.current_info)
        print(f"   {code[:100]}...")

        # 3. Ejecutar
        print("\n‚öôÔ∏è  Ejecutando an√°lisis...")
        try:
            result, exec_time = self.executor.execute(code, self.current_df)
            print(f"   ‚úÖ Completado en {exec_time:.3f}s")

            # Determinar tipo de resultado
            if isinstance(result, pd.DataFrame):
                result_type = "dataframe"
            elif isinstance(result, pd.Series):
                result_type = "series"
            elif isinstance(result, (int, float)):
                result_type = "scalar"
            else:
                result_type = "other"

        except Exception as e:
            print(f"   ‚ùå Error: {e}")
            return AnalysisResult(
                query=query,
                code_generated=code,
                result_data=None,
                result_type="error",
                execution_time=0,
                insights=[f"Error en an√°lisis: {str(e)}"]
            )

        # 4. Generar insights
        print("\nüí° Generando insights...")
        insights = self.insight_generator.generate_insights(query, result, result_type)
        for insight in insights:
            print(f"   ‚Ä¢ {insight[:80]}...")

        # 5. C√≥digo de visualizaci√≥n
        viz_code = None
        if plan.get("visualization_type") != "none":
            viz_code = self.code_generator.generate_visualization_code(
                result,
                plan.get("visualization_type", "bar"),
                query
            )

        # Crear resultado
        analysis_result = AnalysisResult(
            query=query,
            code_generated=code,
            result_data=result,
            result_type=result_type,
            execution_time=exec_time,
            insights=insights,
            visualization_code=viz_code
        )

        self.history.append(analysis_result)
        return analysis_result

    def show_result(self, result: AnalysisResult) -> str:
        """Formatea el resultado para mostrar."""
        output = []
        output.append(f"\nüìã RESULTADO DEL AN√ÅLISIS")
        output.append("="*50)
        output.append(f"Query: {result.query}")
        output.append(f"Tipo: {result.result_type}")
        output.append(f"Tiempo: {result.execution_time:.3f}s")
        output.append("")

        if result.result_type == "dataframe":
            output.append("DATOS:")
            output.append(str(result.result_data.head(10)))
        elif result.result_type == "series":
            output.append("DATOS:")
            output.append(str(result.result_data.head(10)))
        elif result.result_type == "scalar":
            output.append(f"VALOR: {result.result_data}")
        elif result.result_type == "error":
            output.append("ERROR EN AN√ÅLISIS")

        output.append("")
        output.append("üí° INSIGHTS:")
        for i, insight in enumerate(result.insights, 1):
            output.append(f"   {i}. {insight}")

        return "\n".join(output)

    def chat(self, message: str) -> str:
        """Interfaz de chat para an√°lisis interactivo."""
        # Detectar si es una consulta de an√°lisis o pregunta general
        analysis_keywords = [
            "cu√°nto", "cu√°ntos", "cu√°les", "qu√©", "muestra",
            "agrupa", "suma", "promedio", "total", "compara",
            "tendencia", "distribuci√≥n", "correlaci√≥n"
        ]

        is_analysis = any(kw in message.lower() for kw in analysis_keywords)

        if is_analysis:
            result = self.analyze(message)
            return self.show_result(result)
        else:
            # Responder pregunta general sobre los datos
            prompt = f"""El usuario pregunta sobre un dataset con estas caracter√≠sticas:
{self.current_info}

Pregunta: {message}

Responde de forma concisa y √∫til."""

            response = self.model.generate_content(prompt)
            return response.text
```

## Ejemplo de Uso

```python
# Crear datos de ejemplo
import pandas as pd
import numpy as np

# Generar dataset de ventas
np.random.seed(42)
n_rows = 1000

data = {
    'fecha': pd.date_range('2024-01-01', periods=n_rows, freq='D'),
    'region': np.random.choice(['Norte', 'Sur', 'Este', 'Oeste'], n_rows),
    'producto': np.random.choice(['A', 'B', 'C', 'D'], n_rows),
    'vendedor': np.random.choice(['Juan', 'Mar√≠a', 'Carlos', 'Ana'], n_rows),
    'cantidad': np.random.randint(1, 100, n_rows),
    'precio_unitario': np.random.uniform(10, 100, n_rows).round(2),
    'descuento': np.random.uniform(0, 0.3, n_rows).round(2)
}
data['total'] = (data['cantidad'] * data['precio_unitario'] *
                 (1 - data['descuento'])).round(2)

df = pd.DataFrame(data)

# Crear el agente
agent = DataAnalysisAgent()

# Cargar datos
info = agent.load_data(df)
print(f"Dataset cargado: {info.shape[0]} filas, {info.shape[1]} columnas")
print(f"Columnas: {info.columns}")

# An√°lisis interactivo
queries = [
    "¬øCu√°l es el total de ventas por regi√≥n?",
    "Muestra el promedio de ventas por producto",
    "¬øCu√°les son los 5 vendedores con m√°s ventas?",
    "¬øCu√°l es la tendencia de ventas mensuales?",
    "Compara las ventas del Norte vs Sur"
]

for query in queries:
    result = agent.analyze(query)
    print(agent.show_result(result))
    print("\n" + "-"*60 + "\n")
```

## Variante: Agente con Memoria de An√°lisis

```python
class MemoryDataAnalysisAgent(DataAnalysisAgent):
    """
    Agente que recuerda an√°lisis previos y puede referenciarlos.
    """

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        super().__init__(model_name)
        self.analysis_memory: dict[str, AnalysisResult] = {}

    def analyze_with_memory(self, query: str) -> AnalysisResult:
        """Analiza considerando an√°lisis previos."""

        # Verificar si hay referencia a an√°lisis previo
        if "anterior" in query.lower() or "previo" in query.lower():
            context = self._get_relevant_history(query)
            query = f"{query}\n\nContexto de an√°lisis previos:\n{context}"

        result = self.analyze(query)

        # Guardar en memoria con nombre descriptivo
        memory_key = self._generate_memory_key(query)
        self.analysis_memory[memory_key] = result

        return result

    def _get_relevant_history(self, query: str) -> str:
        """Obtiene historial relevante."""
        if not self.history:
            return "No hay an√°lisis previos"

        recent = self.history[-5:]
        context = []
        for i, h in enumerate(recent, 1):
            context.append(f"{i}. Query: {h.query}")
            if h.result_type == "scalar":
                context.append(f"   Resultado: {h.result_data}")
            context.append(f"   Insights: {h.insights[0] if h.insights else 'N/A'}")

        return "\n".join(context)

    def _generate_memory_key(self, query: str) -> str:
        """Genera clave de memoria descriptiva."""
        words = query.lower().split()[:5]
        return "_".join(words)

    def recall(self, topic: str) -> Optional[AnalysisResult]:
        """Recupera un an√°lisis previo por tema."""
        for key, result in self.analysis_memory.items():
            if topic.lower() in key:
                return result
        return None


# Uso
memory_agent = MemoryDataAnalysisAgent()
memory_agent.load_data(df)

# Primera consulta
result1 = memory_agent.analyze_with_memory("¬øCu√°l es el total de ventas por regi√≥n?")

# Segunda consulta que referencia la anterior
result2 = memory_agent.analyze_with_memory(
    "Compara el resultado anterior con las ventas por producto"
)
```

## Errores Comunes y Soluciones

### 1. C√≥digo Generado Inv√°lido

```python
# ‚ùå MAL: Ejecutar c√≥digo sin validaci√≥n
exec(generated_code)

# ‚úÖ BIEN: Validar y manejar errores
def safe_execute(self, code, df, max_attempts=3):
    for attempt in range(max_attempts):
        try:
            # Validar sintaxis
            ast.parse(code)

            # Ejecutar
            result, _ = self.executor.execute(code, df)
            return result

        except SyntaxError as e:
            # Pedir correcci√≥n al modelo
            code = self._fix_code_syntax(code, str(e))

        except Exception as e:
            # Intentar con c√≥digo m√°s simple
            code = self._simplify_code(code, str(e))

    raise RuntimeError("No se pudo ejecutar el an√°lisis")
```

### 2. Tipos de Datos Incorrectos

```python
# ‚ùå MAL: Asumir tipos de columnas
df['fecha'].dt.month  # Error si no es datetime

# ‚úÖ BIEN: Verificar y convertir tipos
def ensure_types(self, df, plan):
    for col in plan.get('date_columns', []):
        if col in df.columns:
            df[col] = pd.to_datetime(df[col], errors='coerce')

    for col in plan.get('numeric_columns', []):
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce')

    return df
```

### 3. Resultados Vac√≠os

```python
# ‚ùå MAL: No manejar resultados vac√≠os
result = df.groupby('region')['ventas'].sum()
insights = generate_insights(result)  # Error si result est√° vac√≠o

# ‚úÖ BIEN: Verificar antes de procesar
def analyze_safely(self, query):
    result = self._execute_analysis(query)

    if result is None or (hasattr(result, 'empty') and result.empty):
        return AnalysisResult(
            query=query,
            code_generated=self.last_code,
            result_data=None,
            result_type="empty",
            execution_time=0,
            insights=["El an√°lisis no produjo resultados. "
                     "Verifica los filtros o la consulta."]
        )

    return self._process_result(result)
```

## Resumen

El **agente de an√°lisis de datos** transforma consultas naturales en an√°lisis:

**Componentes clave**:
1. **Int√©rprete**: Entiende la intenci√≥n del usuario
2. **Generador de c√≥digo**: Traduce a pandas/Python
3. **Ejecutor seguro**: Sandbox para c√≥digo
4. **Generador de insights**: Interpreta resultados

**Mejores pr√°cticas**:
- Validar c√≥digo antes de ejecutar
- Manejar tipos de datos din√°micamente
- Generar insights contextuales
- Mantener historial para referencias
- Ofrecer visualizaciones autom√°ticas

---

## Navegaci√≥n

- **Anterior**: [4.3.1 Agente de Investigaci√≥n Web](./4.3.1-agente-investigacion-web.md)
- **Siguiente**: [4.3.3 Agente de Automatizaci√≥n de Tareas](./4.3.3-agente-automatizacion-tareas.md)
- **√çndice**: [README del Curso](../../README.md)
