# 4.3.3 Agente de Automatizaci√≥n de Tareas

## Tiempo estimado: 90 minutos
## Nivel: Intermedio-Avanzado

## Prerrequisitos
- Plan-and-Execute Pattern (4.2.2)
- Replanificaci√≥n Din√°mica (4.2.3)
- Function Calling (M√≥dulo 3)

## ¬øPor qu√© es importante?

Un **agente de automatizaci√≥n** es capaz de ejecutar flujos de trabajo complejos de forma aut√≥noma:
- Automatiza tareas repetitivas que consumen tiempo
- Orquesta m√∫ltiples herramientas y servicios
- Maneja errores y contingencias autom√°ticamente
- Libera tiempo humano para tareas de mayor valor

Este tipo de agente es la base para asistentes personales, bots de procesos empresariales y sistemas de automatizaci√≥n inteligente.

## Arquitectura del Agente de Automatizaci√≥n

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   AGENTE DE AUTOMATIZACI√ìN DE TAREAS                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                     TRIGGER / SOLICITUD                          ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   "Procesa los emails de soporte y crea tickets en Jira"        ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                   PLANIFICADOR DE WORKFLOW                       ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   1. Identificar sistemas involucrados                           ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   2. Mapear dependencias                                         ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   3. Definir pasos del workflow                                  ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   4. Establecer puntos de control                               ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                   ORQUESTADOR DE ACCIONES                        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ Email   ‚îÇ   ‚îÇ Jira    ‚îÇ   ‚îÇ Slack   ‚îÇ   ‚îÇ Drive   ‚îÇ        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ API     ‚îÇ   ‚îÇ API     ‚îÇ   ‚îÇ API     ‚îÇ   ‚îÇ API     ‚îÇ        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ        ‚îÇ             ‚îÇ             ‚îÇ             ‚îÇ              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                           ‚îÇ                                      ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                           ‚ñº                                      ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                    CONTROLADOR DE FLUJO                         ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                   GESTOR DE ERRORES                              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Detectar fallos en acciones                                 ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Aplicar estrategias de retry                                ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Ejecutar acciones de rollback                               ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ Notificar a humanos si es necesario                         ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ                                                                   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                               ‚îÇ                                         ‚îÇ
‚îÇ                               ‚ñº                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ                   MONITOR Y LOGGING                              ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ   üìä M√©tricas + üìù Logs + üîî Alertas                            ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Tipos de Automatizaci√≥n

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    PATRONES DE AUTOMATIZACI√ìN                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                        ‚îÇ
‚îÇ  1. SECUENCIAL (Pipeline)                                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÄ‚ñ∂ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÄ‚ñ∂ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÄ‚ñ∂ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                            ‚îÇ
‚îÇ  ‚îÇRead ‚îÇ    ‚îÇParse‚îÇ    ‚îÇTrans‚îÇ    ‚îÇWrite‚îÇ                            ‚îÇ
‚îÇ  ‚îÇEmail‚îÇ    ‚îÇData ‚îÇ    ‚îÇform ‚îÇ    ‚îÇJira ‚îÇ                            ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  2. PARALELO (Fan-out/Fan-in)                                          ‚îÇ
‚îÇ                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                                 ‚îÇ
‚îÇ           ‚îå‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇTask1‚îÇ‚îÄ‚îÄ‚îÄ‚îê                                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÄ‚î§    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îú‚îÄ‚ñ∂ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                 ‚îÇ
‚îÇ  ‚îÇSplit‚îÇ  ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ   ‚îÇMerge‚îÇ                                 ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇTask2‚îÇ‚îÄ‚îÄ‚îÄ‚î§   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
‚îÇ           ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ                                            ‚îÇ
‚îÇ           ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ                                            ‚îÇ
‚îÇ           ‚îî‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇTask3‚îÇ‚îÄ‚îÄ‚îÄ‚îò                                            ‚îÇ
‚îÇ                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                                 ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  3. CONDICIONAL (Branching)                                            ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                             ‚îÇ
‚îÇ               ‚îå‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇPath ‚îÇ‚îÄ‚îÄ‚ñ∂ ...                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇYes  ‚îÇ  A  ‚îÇ                                            ‚îÇ
‚îÇ  ‚îÇCheck‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                            ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                            ‚îÇ
‚îÇ               ‚îî‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇPath ‚îÇ‚îÄ‚îÄ‚ñ∂ ...                                     ‚îÇ
‚îÇ                No  ‚îÇ  B  ‚îÇ                                            ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                            ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  4. EVENTO-DRIVEN (Reactive)                                           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                ‚îÇ
‚îÇ  ‚îÇEvent‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇCheck‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇReact‚îÇ                                ‚îÇ
‚îÇ  ‚îÇWatch‚îÇ emit   ‚îÇRules‚îÇ match  ‚îÇAction‚îÇ                               ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementaci√≥n Completa

```python
import google.generativeai as genai
from dataclasses import dataclass, field
from typing import Optional, Callable, Any, Union
from enum import Enum, auto
from abc import ABC, abstractmethod
import json
import time
import asyncio
from datetime import datetime
import os

class ActionStatus(Enum):
    """Estados de una acci√≥n."""
    PENDING = auto()
    RUNNING = auto()
    SUCCESS = auto()
    FAILED = auto()
    SKIPPED = auto()
    ROLLED_BACK = auto()

@dataclass
class ActionResult:
    """Resultado de una acci√≥n."""
    action_name: str
    status: ActionStatus
    output: Any = None
    error: Optional[str] = None
    duration: float = 0.0
    metadata: dict = field(default_factory=dict)

@dataclass
class WorkflowStep:
    """Paso de un workflow."""
    id: str
    name: str
    action: str
    params: dict = field(default_factory=dict)
    depends_on: list[str] = field(default_factory=list)
    on_failure: str = "stop"  # stop, continue, rollback
    retry_count: int = 3
    timeout: float = 60.0
    status: ActionStatus = ActionStatus.PENDING
    result: Optional[ActionResult] = None

@dataclass
class Workflow:
    """Definici√≥n de un workflow completo."""
    id: str
    name: str
    description: str
    steps: list[WorkflowStep]
    variables: dict = field(default_factory=dict)
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())


class Action(ABC):
    """Clase base para acciones automatizables."""

    @property
    @abstractmethod
    def name(self) -> str:
        """Nombre de la acci√≥n."""
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        """Descripci√≥n de lo que hace la acci√≥n."""
        pass

    @abstractmethod
    def execute(self, params: dict, context: dict) -> ActionResult:
        """Ejecuta la acci√≥n."""
        pass

    def rollback(self, params: dict, context: dict) -> bool:
        """Deshace la acci√≥n (opcional)."""
        return True


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ACCIONES PREDEFINIDAS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class SendEmailAction(Action):
    """Acci√≥n para enviar emails."""

    @property
    def name(self) -> str:
        return "send_email"

    @property
    def description(self) -> str:
        return "Env√≠a un email a destinatarios especificados"

    def execute(self, params: dict, context: dict) -> ActionResult:
        start_time = time.time()
        try:
            # Simulaci√≥n - en producci√≥n usar smtplib o API
            to = params.get("to", [])
            subject = params.get("subject", "")
            body = params.get("body", "")

            # Interpolate variables from context
            body = self._interpolate(body, context)

            print(f"   üìß Enviando email a {to}: {subject[:30]}...")
            time.sleep(0.5)  # Simular env√≠o

            return ActionResult(
                action_name=self.name,
                status=ActionStatus.SUCCESS,
                output={"sent_to": to, "subject": subject},
                duration=time.time() - start_time
            )
        except Exception as e:
            return ActionResult(
                action_name=self.name,
                status=ActionStatus.FAILED,
                error=str(e),
                duration=time.time() - start_time
            )

    def _interpolate(self, text: str, context: dict) -> str:
        """Interpola variables en el texto."""
        for key, value in context.items():
            text = text.replace(f"{{{{{key}}}}}", str(value))
        return text


class ReadFileAction(Action):
    """Acci√≥n para leer archivos."""

    @property
    def name(self) -> str:
        return "read_file"

    @property
    def description(self) -> str:
        return "Lee contenido de un archivo"

    def execute(self, params: dict, context: dict) -> ActionResult:
        start_time = time.time()
        try:
            path = params.get("path", "")
            print(f"   üìÑ Leyendo archivo: {path}")

            # Simulaci√≥n
            content = f"Contenido simulado del archivo {path}"

            return ActionResult(
                action_name=self.name,
                status=ActionStatus.SUCCESS,
                output={"content": content, "path": path},
                duration=time.time() - start_time
            )
        except Exception as e:
            return ActionResult(
                action_name=self.name,
                status=ActionStatus.FAILED,
                error=str(e),
                duration=time.time() - start_time
            )


class CreateTicketAction(Action):
    """Acci√≥n para crear tickets (Jira, etc.)."""

    @property
    def name(self) -> str:
        return "create_ticket"

    @property
    def description(self) -> str:
        return "Crea un ticket en el sistema de seguimiento"

    def execute(self, params: dict, context: dict) -> ActionResult:
        start_time = time.time()
        try:
            title = params.get("title", "")
            description = params.get("description", "")
            priority = params.get("priority", "medium")

            print(f"   üé´ Creando ticket: {title[:30]}...")
            time.sleep(0.3)

            ticket_id = f"TICKET-{int(time.time())}"

            return ActionResult(
                action_name=self.name,
                status=ActionStatus.SUCCESS,
                output={"ticket_id": ticket_id, "title": title},
                duration=time.time() - start_time
            )
        except Exception as e:
            return ActionResult(
                action_name=self.name,
                status=ActionStatus.FAILED,
                error=str(e),
                duration=time.time() - start_time
            )

    def rollback(self, params: dict, context: dict) -> bool:
        """Elimina el ticket creado."""
        ticket_id = context.get("last_ticket_id")
        if ticket_id:
            print(f"   ‚Ü©Ô∏è Eliminando ticket {ticket_id}")
            return True
        return False


class NotifySlackAction(Action):
    """Acci√≥n para enviar notificaciones a Slack."""

    @property
    def name(self) -> str:
        return "notify_slack"

    @property
    def description(self) -> str:
        return "Env√≠a mensaje a un canal de Slack"

    def execute(self, params: dict, context: dict) -> ActionResult:
        start_time = time.time()
        try:
            channel = params.get("channel", "#general")
            message = params.get("message", "")

            print(f"   üí¨ Notificando a Slack {channel}: {message[:30]}...")
            time.sleep(0.2)

            return ActionResult(
                action_name=self.name,
                status=ActionStatus.SUCCESS,
                output={"channel": channel, "sent": True},
                duration=time.time() - start_time
            )
        except Exception as e:
            return ActionResult(
                action_name=self.name,
                status=ActionStatus.FAILED,
                error=str(e),
                duration=time.time() - start_time
            )


class HttpRequestAction(Action):
    """Acci√≥n para hacer requests HTTP."""

    @property
    def name(self) -> str:
        return "http_request"

    @property
    def description(self) -> str:
        return "Realiza una petici√≥n HTTP"

    def execute(self, params: dict, context: dict) -> ActionResult:
        import requests
        start_time = time.time()
        try:
            method = params.get("method", "GET").upper()
            url = params.get("url", "")
            headers = params.get("headers", {})
            body = params.get("body")

            print(f"   üåê {method} {url[:50]}...")

            response = requests.request(
                method=method,
                url=url,
                headers=headers,
                json=body if body else None,
                timeout=30
            )

            return ActionResult(
                action_name=self.name,
                status=ActionStatus.SUCCESS,
                output={
                    "status_code": response.status_code,
                    "body": response.text[:500]
                },
                duration=time.time() - start_time
            )
        except Exception as e:
            return ActionResult(
                action_name=self.name,
                status=ActionStatus.FAILED,
                error=str(e),
                duration=time.time() - start_time
            )


class TransformDataAction(Action):
    """Acci√≥n para transformar datos."""

    def __init__(self, model: genai.GenerativeModel):
        self.model = model

    @property
    def name(self) -> str:
        return "transform_data"

    @property
    def description(self) -> str:
        return "Transforma datos seg√∫n instrucciones"

    def execute(self, params: dict, context: dict) -> ActionResult:
        start_time = time.time()
        try:
            input_data = params.get("input") or context.get("last_output", {})
            transformation = params.get("transformation", "")

            prompt = f"""Transforma estos datos seg√∫n las instrucciones:

DATOS DE ENTRADA:
{json.dumps(input_data, indent=2)[:1000]}

TRANSFORMACI√ìN REQUERIDA:
{transformation}

Responde SOLO con el JSON transformado."""

            response = self.model.generate_content(prompt)
            text = response.text.strip()

            if text.startswith("```"):
                text = text.split("```")[1]
                if text.startswith("json"):
                    text = text[4:]

            transformed = json.loads(text)

            return ActionResult(
                action_name=self.name,
                status=ActionStatus.SUCCESS,
                output=transformed,
                duration=time.time() - start_time
            )
        except Exception as e:
            return ActionResult(
                action_name=self.name,
                status=ActionStatus.FAILED,
                error=str(e),
                duration=time.time() - start_time
            )


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# WORKFLOW ENGINE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class WorkflowEngine:
    """
    Motor de ejecuci√≥n de workflows.
    """

    def __init__(self):
        self.actions: dict[str, Action] = {}
        self.execution_history: list[dict] = []

    def register_action(self, action: Action):
        """Registra una acci√≥n disponible."""
        self.actions[action.name] = action

    def execute_workflow(
        self,
        workflow: Workflow,
        on_step_complete: Callable = None
    ) -> dict[str, ActionResult]:
        """
        Ejecuta un workflow completo.
        """
        results: dict[str, ActionResult] = {}
        context = dict(workflow.variables)
        rollback_stack: list[tuple[WorkflowStep, dict]] = []

        print(f"\n{'='*60}")
        print(f"‚ñ∂Ô∏è  EJECUTANDO WORKFLOW: {workflow.name}")
        print(f"{'='*60}\n")

        # Ordenar pasos por dependencias (topological sort simplificado)
        ordered_steps = self._order_steps(workflow.steps)

        for step in ordered_steps:
            # Verificar dependencias
            if not self._dependencies_met(step, results):
                step.status = ActionStatus.SKIPPED
                results[step.id] = ActionResult(
                    action_name=step.action,
                    status=ActionStatus.SKIPPED,
                    error="Dependencias no satisfechas"
                )
                continue

            print(f"[{step.id}] {step.name}")

            # Ejecutar con reintentos
            result = self._execute_with_retry(step, context)
            results[step.id] = result
            step.result = result

            if result.status == ActionStatus.SUCCESS:
                step.status = ActionStatus.SUCCESS
                # Actualizar contexto con output
                context["last_output"] = result.output
                context[f"{step.id}_output"] = result.output

                # Guardar para posible rollback
                rollback_stack.append((step, dict(context)))

                print(f"   ‚úÖ Completado en {result.duration:.2f}s")

                if on_step_complete:
                    on_step_complete(step, result)

            else:
                step.status = ActionStatus.FAILED
                print(f"   ‚ùå Error: {result.error}")

                # Manejar fallo seg√∫n configuraci√≥n
                if step.on_failure == "stop":
                    print("\nüõë Workflow detenido por error")
                    break
                elif step.on_failure == "rollback":
                    print("\n‚Ü©Ô∏è Iniciando rollback...")
                    self._execute_rollback(rollback_stack, context)
                    break
                # else: continue

        # Log final
        success_count = sum(1 for r in results.values()
                          if r.status == ActionStatus.SUCCESS)
        print(f"\n{'='*60}")
        print(f"üìä RESUMEN: {success_count}/{len(workflow.steps)} pasos exitosos")
        print(f"{'='*60}")

        return results

    def _order_steps(self, steps: list[WorkflowStep]) -> list[WorkflowStep]:
        """Ordena pasos respetando dependencias."""
        # Implementaci√≥n simplificada
        ordered = []
        remaining = list(steps)
        completed_ids = set()

        while remaining:
            for step in remaining[:]:
                if all(dep in completed_ids for dep in step.depends_on):
                    ordered.append(step)
                    completed_ids.add(step.id)
                    remaining.remove(step)
                    break
            else:
                # Ciclo detectado o dependencia faltante
                ordered.extend(remaining)
                break

        return ordered

    def _dependencies_met(
        self,
        step: WorkflowStep,
        results: dict[str, ActionResult]
    ) -> bool:
        """Verifica si las dependencias est√°n satisfechas."""
        for dep in step.depends_on:
            if dep not in results:
                return False
            if results[dep].status != ActionStatus.SUCCESS:
                return False
        return True

    def _execute_with_retry(
        self,
        step: WorkflowStep,
        context: dict
    ) -> ActionResult:
        """Ejecuta un paso con reintentos."""
        action = self.actions.get(step.action)
        if not action:
            return ActionResult(
                action_name=step.action,
                status=ActionStatus.FAILED,
                error=f"Acci√≥n '{step.action}' no registrada"
            )

        last_error = None
        for attempt in range(step.retry_count):
            if attempt > 0:
                print(f"   üîÑ Reintento {attempt + 1}/{step.retry_count}...")
                time.sleep(1)  # Espera entre reintentos

            result = action.execute(step.params, context)

            if result.status == ActionStatus.SUCCESS:
                return result

            last_error = result.error

        return ActionResult(
            action_name=step.action,
            status=ActionStatus.FAILED,
            error=f"Fall√≥ despu√©s de {step.retry_count} intentos: {last_error}"
        )

    def _execute_rollback(
        self,
        stack: list[tuple[WorkflowStep, dict]],
        context: dict
    ):
        """Ejecuta rollback de pasos completados."""
        while stack:
            step, step_context = stack.pop()
            action = self.actions.get(step.action)

            if action and hasattr(action, 'rollback'):
                print(f"   ‚Ü©Ô∏è Rollback: {step.name}")
                try:
                    action.rollback(step.params, step_context)
                    step.status = ActionStatus.ROLLED_BACK
                except Exception as e:
                    print(f"   ‚ö†Ô∏è Error en rollback: {e}")


class TaskAutomationAgent:
    """
    Agente completo de automatizaci√≥n de tareas.
    """

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
        self.model = genai.GenerativeModel(model_name)

        self.engine = WorkflowEngine()
        self._register_default_actions()

    def _register_default_actions(self):
        """Registra acciones predeterminadas."""
        self.engine.register_action(SendEmailAction())
        self.engine.register_action(ReadFileAction())
        self.engine.register_action(CreateTicketAction())
        self.engine.register_action(NotifySlackAction())
        self.engine.register_action(HttpRequestAction())
        self.engine.register_action(TransformDataAction(self.model))

    def register_custom_action(self, action: Action):
        """Registra una acci√≥n personalizada."""
        self.engine.register_action(action)

    def create_workflow_from_description(self, description: str) -> Workflow:
        """
        Crea un workflow a partir de una descripci√≥n en lenguaje natural.
        """
        actions_desc = "\n".join([
            f"- {name}: {action.description}"
            for name, action in self.engine.actions.items()
        ])

        prompt = f"""Crea un workflow de automatizaci√≥n para:

DESCRIPCI√ìN: {description}

ACCIONES DISPONIBLES:
{actions_desc}

Genera el workflow en JSON:
{{
    "name": "nombre_descriptivo",
    "description": "descripci√≥n del workflow",
    "steps": [
        {{
            "id": "step_1",
            "name": "Nombre del paso",
            "action": "nombre_accion",
            "params": {{"param1": "valor1"}},
            "depends_on": [],
            "on_failure": "stop|continue|rollback"
        }}
    ],
    "variables": {{"var1": "valor"}}
}}

Aseg√∫rate de que:
1. Los pasos tengan IDs √∫nicos
2. Las dependencias est√©n correctamente definidas
3. Los par√°metros correspondan a la acci√≥n

Responde SOLO con el JSON."""

        response = self.model.generate_content(prompt)

        try:
            text = response.text.strip()
            if text.startswith("```"):
                text = text.split("```")[1]
                if text.startswith("json"):
                    text = text[4:]

            data = json.loads(text)

            steps = []
            for step_data in data.get("steps", []):
                steps.append(WorkflowStep(
                    id=step_data.get("id", f"step_{len(steps)+1}"),
                    name=step_data.get("name", ""),
                    action=step_data.get("action", ""),
                    params=step_data.get("params", {}),
                    depends_on=step_data.get("depends_on", []),
                    on_failure=step_data.get("on_failure", "stop")
                ))

            return Workflow(
                id=f"wf_{int(time.time())}",
                name=data.get("name", "workflow"),
                description=data.get("description", description),
                steps=steps,
                variables=data.get("variables", {})
            )

        except json.JSONDecodeError as e:
            raise ValueError(f"Error creando workflow: {e}")

    def run(self, description: str) -> dict:
        """
        Ejecuta una automatizaci√≥n desde una descripci√≥n natural.
        """
        print(f"\n{'='*60}")
        print(f"ü§ñ AGENTE DE AUTOMATIZACI√ìN")
        print(f"{'='*60}")
        print(f"üìù Tarea: {description}\n")

        # 1. Crear workflow
        print("üìã Generando workflow...")
        workflow = self.create_workflow_from_description(description)

        print(f"   Workflow: {workflow.name}")
        print(f"   Pasos: {len(workflow.steps)}")
        for step in workflow.steps:
            deps = f" (deps: {step.depends_on})" if step.depends_on else ""
            print(f"     ‚Ä¢ {step.id}: {step.name}{deps}")

        # 2. Ejecutar workflow
        print()
        results = self.engine.execute_workflow(workflow)

        return {
            "workflow": workflow,
            "results": results,
            "success": all(r.status == ActionStatus.SUCCESS
                         for r in results.values())
        }

    def run_workflow(self, workflow: Workflow) -> dict:
        """Ejecuta un workflow predefinido."""
        results = self.engine.execute_workflow(workflow)

        return {
            "workflow": workflow,
            "results": results,
            "success": all(r.status == ActionStatus.SUCCESS
                         for r in results.values())
        }
```

## Ejemplo de Uso

```python
# Crear el agente
agent = TaskAutomationAgent()

# Automatizaci√≥n simple desde descripci√≥n
result = agent.run(
    "Cuando llegue un email de soporte, crear un ticket en Jira y notificar al equipo en Slack"
)

print(f"\n√âxito: {'‚úÖ' if result['success'] else '‚ùå'}")

# Workflow manual m√°s complejo
workflow = Workflow(
    id="process_leads",
    name="Procesar Leads de Marketing",
    description="Pipeline de procesamiento de leads",
    steps=[
        WorkflowStep(
            id="fetch_leads",
            name="Obtener leads de API",
            action="http_request",
            params={
                "method": "GET",
                "url": "https://api.example.com/leads"
            }
        ),
        WorkflowStep(
            id="transform",
            name="Filtrar leads calificados",
            action="transform_data",
            params={
                "transformation": "Filtra solo leads con score > 70"
            },
            depends_on=["fetch_leads"]
        ),
        WorkflowStep(
            id="create_tickets",
            name="Crear tickets para sales",
            action="create_ticket",
            params={
                "title": "Nuevo lead calificado",
                "priority": "high"
            },
            depends_on=["transform"]
        ),
        WorkflowStep(
            id="notify",
            name="Notificar equipo de ventas",
            action="notify_slack",
            params={
                "channel": "#sales",
                "message": "Nuevos leads calificados listos para contactar"
            },
            depends_on=["create_tickets"]
        )
    ]
)

result = agent.run_workflow(workflow)
```

## Variante: Agente con Triggers Programados

```python
import schedule
from threading import Thread

class ScheduledAutomationAgent(TaskAutomationAgent):
    """
    Agente con capacidad de ejecutar workflows programados.
    """

    def __init__(self, model_name: str = "gemini-2.0-flash"):
        super().__init__(model_name)
        self.scheduled_jobs: dict[str, Workflow] = {}
        self._scheduler_running = False

    def schedule_workflow(
        self,
        workflow: Workflow,
        schedule_expr: str  # "every day at 9:00", "every 5 minutes", etc.
    ):
        """Programa un workflow para ejecuci√≥n peri√≥dica."""

        def job():
            print(f"\n‚è∞ Ejecutando workflow programado: {workflow.name}")
            self.run_workflow(workflow)

        # Parsear expresi√≥n de programaci√≥n (simplificado)
        if "every day at" in schedule_expr:
            time_str = schedule_expr.split("at")[-1].strip()
            schedule.every().day.at(time_str).do(job)
        elif "every" in schedule_expr and "minutes" in schedule_expr:
            minutes = int(schedule_expr.split()[1])
            schedule.every(minutes).minutes.do(job)
        elif "every" in schedule_expr and "hours" in schedule_expr:
            hours = int(schedule_expr.split()[1])
            schedule.every(hours).hours.do(job)

        self.scheduled_jobs[workflow.id] = workflow
        print(f"üìÖ Workflow '{workflow.name}' programado: {schedule_expr}")

    def start_scheduler(self):
        """Inicia el scheduler en background."""
        def run_scheduler():
            self._scheduler_running = True
            while self._scheduler_running:
                schedule.run_pending()
                time.sleep(1)

        thread = Thread(target=run_scheduler, daemon=True)
        thread.start()
        print("üöÄ Scheduler iniciado")

    def stop_scheduler(self):
        """Detiene el scheduler."""
        self._scheduler_running = False
        print("‚èπÔ∏è Scheduler detenido")


# Uso
scheduled_agent = ScheduledAutomationAgent()

# Workflow de reporte diario
daily_report = Workflow(
    id="daily_report",
    name="Reporte Diario de M√©tricas",
    description="Genera y env√≠a reporte diario",
    steps=[
        WorkflowStep(id="fetch", name="Obtener m√©tricas", action="http_request",
                    params={"method": "GET", "url": "https://api.example.com/metrics"}),
        WorkflowStep(id="send", name="Enviar reporte", action="send_email",
                    params={"to": ["team@example.com"], "subject": "Reporte diario"},
                    depends_on=["fetch"])
    ]
)

scheduled_agent.schedule_workflow(daily_report, "every day at 09:00")
scheduled_agent.start_scheduler()
```

## Errores Comunes y Soluciones

### 1. Dependencias Circulares

```python
# ‚ùå MAL: Ciclo en dependencias
step_a = WorkflowStep(id="a", depends_on=["b"])
step_b = WorkflowStep(id="b", depends_on=["a"])  # ¬°Ciclo!

# ‚úÖ BIEN: Validar dependencias
def validate_workflow(workflow: Workflow) -> bool:
    visited = set()
    rec_stack = set()

    def has_cycle(step_id):
        visited.add(step_id)
        rec_stack.add(step_id)

        step = next((s for s in workflow.steps if s.id == step_id), None)
        if step:
            for dep in step.depends_on:
                if dep not in visited:
                    if has_cycle(dep):
                        return True
                elif dep in rec_stack:
                    return True

        rec_stack.remove(step_id)
        return False

    for step in workflow.steps:
        if step.id not in visited:
            if has_cycle(step.id):
                raise ValueError(f"Ciclo detectado en paso {step.id}")

    return True
```

### 2. Rollback Incompleto

```python
# ‚ùå MAL: No guardar estado para rollback
def execute(self, params, context):
    # Ejecuta sin guardar estado

# ‚úÖ BIEN: Guardar estado para rollback
def execute(self, params, context):
    # Guardar estado original
    context['_rollback_state'] = self._capture_state()

    # Ejecutar
    result = self._do_action(params)

    # Guardar ID para rollback
    context['_last_created_id'] = result.get('id')

    return result

def rollback(self, params, context):
    # Restaurar estado
    original_state = context.get('_rollback_state')
    created_id = context.get('_last_created_id')

    if created_id:
        self._delete(created_id)
    if original_state:
        self._restore_state(original_state)
```

## Aplicaciones del Agente

| Aplicaci√≥n | Descripci√≥n | Ejemplo |
|------------|-------------|---------|
| Onboarding | Configurar cuentas de nuevos empleados | Email + Slack + Jira + Access |
| Reportes | Generar y distribuir reportes peri√≥dicos | Fetch + Transform + Email |
| Alertas | Monitorear y alertar ante eventos | Watch + Check + Notify |
| ETL | Extraer, transformar y cargar datos | API + Transform + DB |
| Deployment | Automatizar despliegues | Build + Test + Deploy + Notify |

## Resumen

El **agente de automatizaci√≥n** orquesta acciones complejas:

**Componentes clave**:
1. **Acciones**: Unidades at√≥micas de trabajo
2. **Workflows**: Secuencias de acciones con dependencias
3. **Engine**: Motor de ejecuci√≥n con retry y rollback
4. **Scheduler**: Programaci√≥n de ejecuciones

**Mejores pr√°cticas**:
- Definir acciones at√≥micas y reutilizables
- Implementar rollback para acciones cr√≠ticas
- Validar dependencias antes de ejecutar
- Usar reintentos con backoff exponencial
- Registrar logs detallados de ejecuci√≥n

---

## Navegaci√≥n

- **Anterior**: [4.3.2 Agente de An√°lisis de Datos](./4.3.2-agente-analisis-datos.md)
- **Siguiente**: [5.1.1 Memoria de Trabajo (Short-term)](../../modulo_5/tema_5.1/5.1.1-memoria-trabajo.md)
- **√çndice**: [README del Curso](../../README.md)
