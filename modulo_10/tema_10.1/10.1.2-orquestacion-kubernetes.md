# 10.1.2 Orquestación con Kubernetes

## Objetivo de Aprendizaje

Al finalizar este subtema, serás capaz de desplegar y escalar agentes de IA en Kubernetes, configurando deployments, services, autoscaling y gestión de secretos.

## Introducción

Kubernetes permite orquestar agentes containerizados a escala, proporcionando alta disponibilidad, escalado automático y gestión declarativa de infraestructura.

```
┌─────────────────────────────────────────────────────────────────┐
│                    KUBERNETES CLUSTER                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    INGRESS CONTROLLER                   │   │
│  │              api.example.com → Service                  │   │
│  └───────────────────────┬─────────────────────────────────┘   │
│                          │                                      │
│  ┌───────────────────────▼─────────────────────────────────┐   │
│  │                 SERVICE (LoadBalancer)                   │   │
│  └───────────────────────┬─────────────────────────────────┘   │
│                          │                                      │
│  ┌─────────────┬─────────┴─────────┬─────────────┐             │
│  │             │                   │             │             │
│  ▼             ▼                   ▼             ▼             │
│  ┌─────┐    ┌─────┐            ┌─────┐       ┌─────┐          │
│  │ POD │    │ POD │            │ POD │  ...  │ POD │          │
│  │Agent│    │Agent│            │Agent│       │Agent│          │
│  └─────┘    └─────┘            └─────┘       └─────┘          │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    HPA (Autoscaler)                      │   │
│  │           CPU > 70% → Scale Up to max 10                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │
│  │ConfigMap     │  │   Secret     │  │    PVC       │         │
│  │(Settings)    │  │  (API Keys)  │  │  (Storage)   │         │
│  └──────────────┘  └──────────────┘  └──────────────┘         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Estructura de Manifiestos

```
k8s/
├── base/
│   ├── kustomization.yaml
│   ├── namespace.yaml
│   ├── deployment.yaml
│   ├── service.yaml
│   ├── configmap.yaml
│   ├── hpa.yaml
│   └── pdb.yaml
├── overlays/
│   ├── development/
│   │   ├── kustomization.yaml
│   │   └── patches/
│   ├── staging/
│   │   ├── kustomization.yaml
│   │   └── patches/
│   └── production/
│       ├── kustomization.yaml
│       ├── patches/
│       └── secrets/
└── scripts/
    ├── deploy.sh
    └── rollback.sh
```

## Manifiestos Base

### Namespace

```yaml
# k8s/base/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: gemini-agents
  labels:
    app.kubernetes.io/name: gemini-agents
    app.kubernetes.io/component: ai-agents
```

### ConfigMap

```yaml
# k8s/base/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: agent-config
  namespace: gemini-agents
data:
  # Configuración de la aplicación
  APP_NAME: "Gemini Agent"
  LOG_LEVEL: "INFO"
  LOG_FORMAT: "json"
  GEMINI_MODEL: "gemini-2.0-flash"
  MAX_TOKENS: "8192"
  RATE_LIMIT_REQUESTS: "100"
  RATE_LIMIT_WINDOW: "60"

  # URLs de servicios internos
  REDIS_HOST: "redis-master.gemini-agents.svc.cluster.local"
  REDIS_PORT: "6379"

  # Feature flags
  ENABLE_CACHING: "true"
  ENABLE_METRICS: "true"
  ENABLE_TRACING: "true"
```

### Secret (Template)

```yaml
# k8s/base/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: agent-secrets
  namespace: gemini-agents
type: Opaque
stringData:
  # Estos valores se sobrescriben en overlays/production
  GOOGLE_API_KEY: "placeholder"
  DATABASE_URL: "postgresql://user:pass@host:5432/db"
  SENTRY_DSN: ""
---
# External Secrets (si usas External Secrets Operator)
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: agent-external-secrets
  namespace: gemini-agents
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: gcp-secret-store
    kind: ClusterSecretStore
  target:
    name: agent-secrets
    creationPolicy: Owner
  data:
    - secretKey: GOOGLE_API_KEY
      remoteRef:
        key: gemini-agent-api-key
```

### Deployment

```yaml
# k8s/base/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: gemini-agent
  namespace: gemini-agents
  labels:
    app: gemini-agent
    app.kubernetes.io/name: gemini-agent
    app.kubernetes.io/component: api
spec:
  replicas: 3
  revisionHistoryLimit: 5
  selector:
    matchLabels:
      app: gemini-agent
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        app: gemini-agent
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: gemini-agent
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 1000

      # Anti-affinity para distribuir pods
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app: gemini-agent
                topologyKey: kubernetes.io/hostname

      # Init container para esperar dependencias
      initContainers:
        - name: wait-for-redis
          image: busybox:1.36
          command: ['sh', '-c', 'until nc -z redis-master 6379; do echo waiting for redis; sleep 2; done']

      containers:
        - name: agent
          image: ghcr.io/tu-org/gemini-agent:latest
          imagePullPolicy: Always

          ports:
            - name: http
              containerPort: 8080
              protocol: TCP

          # Variables de entorno desde ConfigMap
          envFrom:
            - configMapRef:
                name: agent-config

          # Variables de entorno desde Secrets
          env:
            - name: GOOGLE_API_KEY
              valueFrom:
                secretKeyRef:
                  name: agent-secrets
                  key: GOOGLE_API_KEY
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: agent-secrets
                  key: DATABASE_URL
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace

          # Recursos
          resources:
            requests:
              cpu: 500m
              memory: 1Gi
            limits:
              cpu: 2000m
              memory: 4Gi

          # Probes
          startupProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 10
            periodSeconds: 5
            failureThreshold: 30

          livenessProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 0
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3

          readinessProbe:
            httpGet:
              path: /ready
              port: http
            initialDelaySeconds: 0
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3

          # Security context del container
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - ALL

          # Volúmenes
          volumeMounts:
            - name: tmp
              mountPath: /tmp
            - name: cache
              mountPath: /app/.cache

      volumes:
        - name: tmp
          emptyDir: {}
        - name: cache
          emptyDir:
            sizeLimit: 1Gi

      # Graceful shutdown
      terminationGracePeriodSeconds: 30

      # Topology spread para alta disponibilidad
      topologySpreadConstraints:
        - maxSkew: 1
          topologyKey: topology.kubernetes.io/zone
          whenUnsatisfiable: ScheduleAnyway
          labelSelector:
            matchLabels:
              app: gemini-agent
```

### Service

```yaml
# k8s/base/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: gemini-agent
  namespace: gemini-agents
  labels:
    app: gemini-agent
spec:
  type: ClusterIP
  ports:
    - name: http
      port: 80
      targetPort: http
      protocol: TCP
  selector:
    app: gemini-agent
---
# Service Account
apiVersion: v1
kind: ServiceAccount
metadata:
  name: gemini-agent
  namespace: gemini-agents
  annotations:
    # Para Workload Identity en GKE
    iam.gke.io/gcp-service-account: gemini-agent@project-id.iam.gserviceaccount.com
```

### Ingress

```yaml
# k8s/base/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: gemini-agent
  namespace: gemini-agents
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
    nginx.ingress.kubernetes.io/proxy-body-size: "10m"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "300"
spec:
  tls:
    - hosts:
        - api.example.com
      secretName: gemini-agent-tls
  rules:
    - host: api.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: gemini-agent
                port:
                  number: 80
```

### HorizontalPodAutoscaler

```yaml
# k8s/base/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: gemini-agent
  namespace: gemini-agents
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: gemini-agent
  minReplicas: 3
  maxReplicas: 20
  metrics:
    # Escalar por CPU
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70

    # Escalar por memoria
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80

    # Escalar por requests por segundo (requiere metrics-server custom)
    - type: Pods
      pods:
        metric:
          name: http_requests_per_second
        target:
          type: AverageValue
          averageValue: 100

  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 10
          periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
        - type: Percent
          value: 100
          periodSeconds: 15
        - type: Pods
          value: 4
          periodSeconds: 15
      selectPolicy: Max
```

### PodDisruptionBudget

```yaml
# k8s/base/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: gemini-agent
  namespace: gemini-agents
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: gemini-agent
```

## Kustomization

### Base

```yaml
# k8s/base/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

namespace: gemini-agents

resources:
  - namespace.yaml
  - configmap.yaml
  - secret.yaml
  - deployment.yaml
  - service.yaml
  - ingress.yaml
  - hpa.yaml
  - pdb.yaml

commonLabels:
  app.kubernetes.io/managed-by: kustomize
  app.kubernetes.io/part-of: gemini-agents

images:
  - name: ghcr.io/tu-org/gemini-agent
    newTag: latest
```

### Overlay de Producción

```yaml
# k8s/overlays/production/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

namespace: gemini-agents-prod

resources:
  - ../../base

namePrefix: prod-

commonLabels:
  environment: production

# Parches
patches:
  # Aumentar réplicas
  - target:
      kind: Deployment
      name: gemini-agent
    patch: |-
      - op: replace
        path: /spec/replicas
        value: 5

  # Aumentar recursos
  - target:
      kind: Deployment
      name: gemini-agent
    patch: |-
      - op: replace
        path: /spec/template/spec/containers/0/resources/requests/cpu
        value: "1000m"
      - op: replace
        path: /spec/template/spec/containers/0/resources/requests/memory
        value: "2Gi"
      - op: replace
        path: /spec/template/spec/containers/0/resources/limits/cpu
        value: "4000m"
      - op: replace
        path: /spec/template/spec/containers/0/resources/limits/memory
        value: "8Gi"

  # HPA con más réplicas
  - target:
      kind: HorizontalPodAutoscaler
      name: gemini-agent
    patch: |-
      - op: replace
        path: /spec/minReplicas
        value: 5
      - op: replace
        path: /spec/maxReplicas
        value: 50

# Configuración de producción
configMapGenerator:
  - name: agent-config
    behavior: merge
    literals:
      - LOG_LEVEL=INFO
      - ENVIRONMENT=production
      - ENABLE_DEBUG=false

# Imagen de producción
images:
  - name: ghcr.io/tu-org/gemini-agent
    newTag: v1.2.3  # Tag específico

# Secrets desde archivos sealed
secretGenerator:
  - name: agent-secrets
    behavior: replace
    files:
      - secrets/sealed-secrets.yaml
```

## Helm Chart (Alternativa)

```yaml
# helm/gemini-agent/values.yaml
replicaCount: 3

image:
  repository: ghcr.io/tu-org/gemini-agent
  tag: latest
  pullPolicy: Always

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: true
  className: nginx
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
  hosts:
    - host: api.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: gemini-agent-tls
      hosts:
        - api.example.com

resources:
  requests:
    cpu: 500m
    memory: 1Gi
  limits:
    cpu: 2000m
    memory: 4Gi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 20
  targetCPUUtilizationPercentage: 70

config:
  logLevel: INFO
  geminiModel: gemini-2.0-flash
  maxTokens: 8192

secrets:
  googleApiKey: ""  # Usar external-secrets
  databaseUrl: ""

redis:
  enabled: true
  architecture: standalone
  auth:
    enabled: true

monitoring:
  enabled: true
  serviceMonitor:
    enabled: true
```

## Scripts de Despliegue

```bash
#!/bin/bash
# k8s/scripts/deploy.sh

set -euo pipefail

ENVIRONMENT="${1:-development}"
VERSION="${2:-latest}"

echo "Deploying to ${ENVIRONMENT} with version ${VERSION}"

# Validar manifiestos
echo "Validating manifests..."
kubectl kustomize "k8s/overlays/${ENVIRONMENT}" | kubectl apply --dry-run=client -f -

# Aplicar
echo "Applying manifests..."
kubectl kustomize "k8s/overlays/${ENVIRONMENT}" | kubectl apply -f -

# Esperar rollout
echo "Waiting for rollout..."
kubectl -n "gemini-agents-${ENVIRONMENT}" rollout status deployment/gemini-agent --timeout=300s

# Verificar pods
echo "Verifying pods..."
kubectl -n "gemini-agents-${ENVIRONMENT}" get pods -l app=gemini-agent

# Health check
echo "Running health check..."
POD=$(kubectl -n "gemini-agents-${ENVIRONMENT}" get pods -l app=gemini-agent -o jsonpath='{.items[0].metadata.name}')
kubectl -n "gemini-agents-${ENVIRONMENT}" exec "${POD}" -- curl -s http://localhost:8080/health

echo "Deployment complete!"
```

## Operaciones Comunes

```python
# scripts/k8s_operations.py
"""Operaciones comunes de Kubernetes para agentes"""

import subprocess
import json
from typing import Dict, List, Optional

class K8sOperations:
    def __init__(self, namespace: str = "gemini-agents"):
        self.namespace = namespace

    def run_kubectl(self, args: List[str]) -> str:
        """Ejecuta comando kubectl"""
        cmd = ["kubectl", "-n", self.namespace] + args
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0:
            raise Exception(f"kubectl error: {result.stderr}")
        return result.stdout

    def get_pods(self, label: str = "app=gemini-agent") -> List[Dict]:
        """Lista pods del agente"""
        output = self.run_kubectl([
            "get", "pods", "-l", label, "-o", "json"
        ])
        data = json.loads(output)
        return data.get("items", [])

    def get_pod_logs(self, pod_name: str, tail: int = 100) -> str:
        """Obtiene logs de un pod"""
        return self.run_kubectl([
            "logs", pod_name, "--tail", str(tail)
        ])

    def scale_deployment(self, replicas: int) -> str:
        """Escala el deployment"""
        return self.run_kubectl([
            "scale", "deployment/gemini-agent",
            "--replicas", str(replicas)
        ])

    def rollout_restart(self) -> str:
        """Reinicia el deployment"""
        return self.run_kubectl([
            "rollout", "restart", "deployment/gemini-agent"
        ])

    def rollout_status(self) -> str:
        """Estado del rollout"""
        return self.run_kubectl([
            "rollout", "status", "deployment/gemini-agent"
        ])

    def exec_in_pod(self, pod_name: str, command: List[str]) -> str:
        """Ejecuta comando en un pod"""
        return self.run_kubectl([
            "exec", pod_name, "--"
        ] + command)

    def port_forward(self, local_port: int, remote_port: int = 8080) -> subprocess.Popen:
        """Inicia port-forward"""
        pods = self.get_pods()
        if not pods:
            raise Exception("No pods found")

        pod_name = pods[0]["metadata"]["name"]
        cmd = [
            "kubectl", "-n", self.namespace,
            "port-forward", pod_name,
            f"{local_port}:{remote_port}"
        ]
        return subprocess.Popen(cmd)

    def get_metrics(self) -> Dict:
        """Obtiene métricas del HPA"""
        output = self.run_kubectl([
            "get", "hpa/gemini-agent", "-o", "json"
        ])
        return json.loads(output)


# Uso
if __name__ == "__main__":
    ops = K8sOperations(namespace="gemini-agents-prod")

    print("=== Pods ===")
    pods = ops.get_pods()
    for pod in pods:
        name = pod["metadata"]["name"]
        status = pod["status"]["phase"]
        print(f"  {name}: {status}")

    print("\n=== HPA Metrics ===")
    hpa = ops.get_metrics()
    spec = hpa.get("spec", {})
    status = hpa.get("status", {})
    print(f"  Current: {status.get('currentReplicas')}")
    print(f"  Desired: {status.get('desiredReplicas')}")
    print(f"  Min: {spec.get('minReplicas')}")
    print(f"  Max: {spec.get('maxReplicas')}")
```

## Ejercicios Prácticos

### Ejercicio 1: Blue-Green Deployment
Implementa despliegue blue-green:
- Dos deployments paralelos
- Cambio de tráfico via service
- Rollback instantáneo

### Ejercicio 2: Canary Deployment
Configura despliegue canary:
- 10% tráfico a nueva versión
- Métricas de comparación
- Promoción automática

### Ejercicio 3: GitOps con ArgoCD
Implementa GitOps:
- ArgoCD Application
- Sync automático
- Health checks custom

## Resumen

| Concepto | Descripción |
|----------|-------------|
| Deployment | Define estado deseado de pods |
| Service | Expone pods como servicio de red |
| HPA | Escala automáticamente por métricas |
| ConfigMap/Secret | Configuración y secretos externalizados |
| Ingress | Enrutamiento HTTP externo |
| Kustomize | Gestión de variantes por entorno |

---

**Siguiente:** [10.1.3 Serverless con Cloud Functions](./10.1.3-serverless-cloud-functions.md)
