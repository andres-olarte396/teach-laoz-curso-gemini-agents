# 10.1.3 Serverless con Cloud Functions

## Objetivo de Aprendizaje

Al finalizar este subtema, serás capaz de desplegar agentes de IA como funciones serverless en Google Cloud Functions y Cloud Run, optimizando costos y escalabilidad automática.

## Introducción

El modelo serverless permite ejecutar agentes sin gestionar infraestructura, pagando solo por el tiempo de ejecución. Ideal para cargas variables y prototipos rápidos.

```
┌─────────────────────────────────────────────────────────────────┐
│                  ARQUITECTURA SERVERLESS                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                     ┌─────────────┐                             │
│                     │   CLIENT    │                             │
│                     └──────┬──────┘                             │
│                            │ HTTPS                              │
│                            ▼                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   API GATEWAY                            │   │
│  │                  (Cloud Endpoints)                       │   │
│  └────────────────────────┬────────────────────────────────┘   │
│                           │                                     │
│      ┌────────────────────┼────────────────────┐               │
│      │                    │                    │               │
│      ▼                    ▼                    ▼               │
│  ┌────────┐          ┌────────┐          ┌────────┐           │
│  │ Cloud  │          │ Cloud  │          │ Cloud  │           │
│  │Function│          │  Run   │          │Function│           │
│  │ (Chat) │          │(Agent) │          │(Tools) │           │
│  └───┬────┘          └───┬────┘          └───┬────┘           │
│      │                   │                   │                 │
│      └─────────┬─────────┴─────────┬─────────┘                 │
│                │                   │                           │
│                ▼                   ▼                           │
│         ┌──────────┐        ┌──────────┐                       │
│         │ Firestore│        │ Pub/Sub  │                       │
│         │ (Memory) │        │ (Events) │                       │
│         └──────────┘        └──────────┘                       │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  BENEFICIOS:                                            │   │
│  │  • Auto-scaling 0→∞    • Pay per use                   │   │
│  │  • No server mgmt      • Built-in HA                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Cloud Functions (Gen 2)

### Estructura del Proyecto

```
serverless-agent/
├── chat_function/
│   ├── main.py
│   └── requirements.txt
├── agent_function/
│   ├── main.py
│   └── requirements.txt
├── tool_functions/
│   ├── search/
│   │   ├── main.py
│   │   └── requirements.txt
│   └── calculator/
│       ├── main.py
│       └── requirements.txt
├── shared/
│   ├── __init__.py
│   ├── agent_core.py
│   └── utils.py
├── deploy.sh
└── cloudbuild.yaml
```

### Función de Chat Simple

```python
# chat_function/main.py
import functions_framework
from flask import jsonify
import google.generativeai as genai
from google.cloud import firestore
import os
import json
from datetime import datetime

# Configuración
genai.configure(api_key=os.environ.get("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-2.0-flash")

# Firestore para memoria
db = firestore.Client()

@functions_framework.http
def chat(request):
    """
    Cloud Function para chat con Gemini

    Request JSON:
    {
        "message": "string",
        "session_id": "string (optional)",
        "system_instruction": "string (optional)"
    }
    """
    # CORS headers
    if request.method == 'OPTIONS':
        headers = {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'POST',
            'Access-Control-Allow-Headers': 'Content-Type',
            'Access-Control-Max-Age': '3600'
        }
        return ('', 204, headers)

    headers = {'Access-Control-Allow-Origin': '*'}

    try:
        # Parsear request
        request_json = request.get_json(silent=True)

        if not request_json or 'message' not in request_json:
            return jsonify({
                "error": "Missing 'message' in request body"
            }), 400, headers

        message = request_json['message']
        session_id = request_json.get('session_id', 'default')
        system_instruction = request_json.get('system_instruction')

        # Recuperar historial de sesión
        history = get_session_history(session_id)

        # Crear modelo con system instruction si se proporciona
        if system_instruction:
            chat_model = genai.GenerativeModel(
                "gemini-2.0-flash",
                system_instruction=system_instruction
            )
        else:
            chat_model = model

        # Crear chat con historial
        chat = chat_model.start_chat(history=history)

        # Generar respuesta
        response = chat.send_message(message)

        # Guardar en historial
        save_to_history(session_id, message, response.text)

        # Métricas
        token_count = response.usage_metadata.total_token_count

        return jsonify({
            "response": response.text,
            "session_id": session_id,
            "tokens_used": token_count
        }), 200, headers

    except Exception as e:
        return jsonify({
            "error": str(e)
        }), 500, headers


def get_session_history(session_id: str, limit: int = 20):
    """Recupera historial de Firestore"""
    try:
        doc_ref = db.collection('chat_sessions').document(session_id)
        doc = doc_ref.get()

        if doc.exists:
            data = doc.to_dict()
            messages = data.get('messages', [])[-limit:]

            # Convertir a formato de Gemini
            history = []
            for msg in messages:
                history.append({
                    "role": msg['role'],
                    "parts": [msg['content']]
                })
            return history

        return []

    except Exception:
        return []


def save_to_history(session_id: str, user_message: str, assistant_response: str):
    """Guarda mensajes en Firestore"""
    try:
        doc_ref = db.collection('chat_sessions').document(session_id)

        doc_ref.set({
            'updated_at': datetime.utcnow(),
            'messages': firestore.ArrayUnion([
                {'role': 'user', 'content': user_message},
                {'role': 'model', 'content': assistant_response}
            ])
        }, merge=True)

    except Exception as e:
        print(f"Error saving history: {e}")
```

### requirements.txt para Cloud Function

```
# chat_function/requirements.txt
functions-framework==3.*
google-generativeai>=0.3.0
google-cloud-firestore>=2.11.0
flask>=2.0.0
```

### Función de Agente Completo

```python
# agent_function/main.py
import functions_framework
from flask import jsonify
import google.generativeai as genai
from google.cloud import firestore, pubsub_v1
import os
import json
from typing import Dict, Any, List
from datetime import datetime
import traceback

# Configuración
genai.configure(api_key=os.environ.get("GOOGLE_API_KEY"))
db = firestore.Client()
publisher = pubsub_v1.PublisherClient()
PROJECT_ID = os.environ.get("GCP_PROJECT")

# Definición de tools
TOOLS = [
    {
        "name": "search_web",
        "description": "Busca información en la web",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "Consulta de búsqueda"
                }
            },
            "required": ["query"]
        }
    },
    {
        "name": "calculate",
        "description": "Realiza cálculos matemáticos",
        "parameters": {
            "type": "object",
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Expresión matemática"
                }
            },
            "required": ["expression"]
        }
    },
    {
        "name": "store_memory",
        "description": "Guarda información en memoria",
        "parameters": {
            "type": "object",
            "properties": {
                "key": {"type": "string"},
                "value": {"type": "string"}
            },
            "required": ["key", "value"]
        }
    }
]

# Modelo con tools
model = genai.GenerativeModel(
    "gemini-2.0-flash",
    tools=TOOLS,
    system_instruction="""Eres un agente inteligente que puede usar herramientas.
    Analiza las solicitudes y usa las herramientas apropiadas para completar tareas.
    Siempre verifica tus resultados antes de responder."""
)


@functions_framework.http
def agent(request):
    """
    Cloud Function para agente con tools

    Request JSON:
    {
        "task": "string",
        "session_id": "string (optional)",
        "max_steps": int (optional, default 10),
        "async": bool (optional, default false)
    }
    """
    if request.method == 'OPTIONS':
        return handle_cors_preflight()

    headers = {'Access-Control-Allow-Origin': '*'}

    try:
        request_json = request.get_json(silent=True)

        if not request_json or 'task' not in request_json:
            return jsonify({"error": "Missing 'task'"}), 400, headers

        task = request_json['task']
        session_id = request_json.get('session_id', 'default')
        max_steps = min(request_json.get('max_steps', 10), 20)
        run_async = request_json.get('async', False)

        # Si es async, publicar a Pub/Sub y retornar ID
        if run_async:
            task_id = publish_task(task, session_id, max_steps)
            return jsonify({
                "task_id": task_id,
                "status": "queued",
                "message": "Task queued for processing"
            }), 202, headers

        # Ejecución síncrona
        result = execute_agent(task, session_id, max_steps)

        return jsonify(result), 200, headers

    except Exception as e:
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500, headers


def execute_agent(task: str, session_id: str, max_steps: int) -> Dict[str, Any]:
    """Ejecuta el agente con loop de tools"""

    steps = []
    chat = model.start_chat()

    # Enviar tarea inicial
    response = chat.send_message(task)
    steps.append({"type": "initial", "content": task})

    for step_num in range(max_steps):
        # Verificar si hay function calls
        if not hasattr(response.candidates[0].content, 'parts'):
            break

        function_calls = []
        for part in response.candidates[0].content.parts:
            if hasattr(part, 'function_call'):
                function_calls.append(part.function_call)

        if not function_calls:
            # No hay más tools que llamar
            break

        # Ejecutar cada tool
        tool_responses = []
        for fc in function_calls:
            tool_result = execute_tool(fc.name, dict(fc.args), session_id)
            steps.append({
                "type": "tool_call",
                "tool": fc.name,
                "args": dict(fc.args),
                "result": tool_result
            })

            tool_responses.append({
                "function_response": {
                    "name": fc.name,
                    "response": {"result": tool_result}
                }
            })

        # Enviar resultados de tools al modelo
        response = chat.send_message(tool_responses)

    # Extraer respuesta final
    final_response = ""
    for part in response.candidates[0].content.parts:
        if hasattr(part, 'text'):
            final_response += part.text

    # Guardar resultado
    save_result(session_id, task, final_response, steps)

    return {
        "task": task,
        "response": final_response,
        "steps": steps,
        "total_steps": len(steps)
    }


def execute_tool(tool_name: str, args: Dict, session_id: str) -> str:
    """Ejecuta una herramienta"""

    if tool_name == "search_web":
        return mock_search(args.get("query", ""))

    elif tool_name == "calculate":
        return safe_calculate(args.get("expression", ""))

    elif tool_name == "store_memory":
        return store_memory(session_id, args.get("key"), args.get("value"))

    else:
        return f"Unknown tool: {tool_name}"


def mock_search(query: str) -> str:
    """Búsqueda simulada (en producción, usar API real)"""
    return f"Resultados de búsqueda para '{query}': [Resultado 1, Resultado 2, Resultado 3]"


def safe_calculate(expression: str) -> str:
    """Cálculo seguro de expresiones"""
    try:
        # Sanitizar - solo permitir caracteres matemáticos
        allowed = set('0123456789+-*/.() ')
        if not all(c in allowed for c in expression):
            return "Error: expresión inválida"

        result = eval(expression)
        return str(result)
    except Exception as e:
        return f"Error: {str(e)}"


def store_memory(session_id: str, key: str, value: str) -> str:
    """Almacena en memoria del agente"""
    try:
        doc_ref = db.collection('agent_memory').document(session_id)
        doc_ref.set({key: value}, merge=True)
        return f"Almacenado: {key} = {value}"
    except Exception as e:
        return f"Error almacenando: {str(e)}"


def save_result(session_id: str, task: str, response: str, steps: List):
    """Guarda resultado de la ejecución"""
    try:
        db.collection('agent_results').add({
            'session_id': session_id,
            'task': task,
            'response': response,
            'steps': steps,
            'created_at': datetime.utcnow()
        })
    except Exception as e:
        print(f"Error saving result: {e}")


def publish_task(task: str, session_id: str, max_steps: int) -> str:
    """Publica tarea a Pub/Sub para ejecución async"""
    import uuid

    task_id = str(uuid.uuid4())
    topic_path = publisher.topic_path(PROJECT_ID, 'agent-tasks')

    message = json.dumps({
        'task_id': task_id,
        'task': task,
        'session_id': session_id,
        'max_steps': max_steps
    }).encode('utf-8')

    publisher.publish(topic_path, message)

    return task_id


def handle_cors_preflight():
    """Maneja preflight CORS"""
    headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Max-Age': '3600'
    }
    return ('', 204, headers)
```

## Cloud Run

### Dockerfile para Cloud Run

```dockerfile
# Dockerfile.cloudrun
FROM python:3.11-slim

WORKDIR /app

# Instalar dependencias
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copiar código
COPY . .

# Puerto configurable
ENV PORT=8080

# Usar gunicorn para producción
CMD exec gunicorn --bind :$PORT --workers 1 --threads 8 --timeout 0 main:app
```

### Aplicación Cloud Run

```python
# main.py (Cloud Run)
from flask import Flask, request, jsonify
import google.generativeai as genai
from google.cloud import firestore
import os
from functools import wraps
import time

app = Flask(__name__)

# Configuración
genai.configure(api_key=os.environ.get("GOOGLE_API_KEY"))
db = firestore.Client()

# Modelo global (reutilizado entre requests)
model = genai.GenerativeModel("gemini-2.0-flash")


def require_api_key(f):
    """Decorator para validar API key"""
    @wraps(f)
    def decorated(*args, **kwargs):
        api_key = request.headers.get('X-API-Key')
        expected_key = os.environ.get('CLIENT_API_KEY')

        if not api_key or api_key != expected_key:
            return jsonify({"error": "Invalid API key"}), 401

        return f(*args, **kwargs)
    return decorated


def rate_limit(max_requests: int, window_seconds: int):
    """Rate limiting usando Firestore"""
    def decorator(f):
        @wraps(f)
        def decorated(*args, **kwargs):
            client_id = request.headers.get('X-Client-ID', request.remote_addr)
            key = f"rate_limit:{client_id}"

            doc_ref = db.collection('rate_limits').document(key)
            doc = doc_ref.get()

            now = time.time()

            if doc.exists:
                data = doc.to_dict()
                window_start = data.get('window_start', 0)
                count = data.get('count', 0)

                if now - window_start < window_seconds:
                    if count >= max_requests:
                        return jsonify({
                            "error": "Rate limit exceeded",
                            "retry_after": window_seconds - (now - window_start)
                        }), 429
                    count += 1
                else:
                    window_start = now
                    count = 1
            else:
                window_start = now
                count = 1

            doc_ref.set({
                'window_start': window_start,
                'count': count
            })

            return f(*args, **kwargs)
        return decorated
    return decorator


@app.route('/health', methods=['GET'])
def health():
    """Health check"""
    return jsonify({"status": "healthy"})


@app.route('/api/v1/chat', methods=['POST'])
@require_api_key
@rate_limit(max_requests=100, window_seconds=60)
def chat():
    """Endpoint de chat"""
    data = request.get_json()

    if not data or 'message' not in data:
        return jsonify({"error": "Missing message"}), 400

    try:
        response = model.generate_content(data['message'])

        return jsonify({
            "response": response.text,
            "tokens": response.usage_metadata.total_token_count
        })

    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route('/api/v1/agent', methods=['POST'])
@require_api_key
@rate_limit(max_requests=20, window_seconds=60)
def agent():
    """Endpoint de agente con tools"""
    data = request.get_json()

    if not data or 'task' not in data:
        return jsonify({"error": "Missing task"}), 400

    # Importar y ejecutar agente
    from agent_core import execute_agent

    try:
        result = execute_agent(
            task=data['task'],
            session_id=data.get('session_id', 'default'),
            max_steps=min(data.get('max_steps', 10), 20)
        )
        return jsonify(result)

    except Exception as e:
        return jsonify({"error": str(e)}), 500


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 8080)))
```

## Despliegue

### Script de Despliegue

```bash
#!/bin/bash
# deploy.sh

set -e

PROJECT_ID="${GCP_PROJECT:-your-project-id}"
REGION="${REGION:-us-central1}"

echo "Deploying to project: $PROJECT_ID, region: $REGION"

# 1. Deploy Chat Function
echo "Deploying chat function..."
gcloud functions deploy chat-function \
    --gen2 \
    --runtime=python311 \
    --region=$REGION \
    --source=./chat_function \
    --entry-point=chat \
    --trigger-http \
    --allow-unauthenticated \
    --memory=512MB \
    --timeout=60s \
    --min-instances=0 \
    --max-instances=100 \
    --set-env-vars="GOOGLE_API_KEY=${GOOGLE_API_KEY}"

# 2. Deploy Agent Function
echo "Deploying agent function..."
gcloud functions deploy agent-function \
    --gen2 \
    --runtime=python311 \
    --region=$REGION \
    --source=./agent_function \
    --entry-point=agent \
    --trigger-http \
    --allow-unauthenticated \
    --memory=1GB \
    --timeout=540s \
    --min-instances=1 \
    --max-instances=50 \
    --set-env-vars="GOOGLE_API_KEY=${GOOGLE_API_KEY},GCP_PROJECT=${PROJECT_ID}"

# 3. Deploy Cloud Run (API Gateway)
echo "Building and deploying Cloud Run..."
gcloud builds submit --tag gcr.io/$PROJECT_ID/agent-api

gcloud run deploy agent-api \
    --image=gcr.io/$PROJECT_ID/agent-api \
    --platform=managed \
    --region=$REGION \
    --allow-unauthenticated \
    --memory=2Gi \
    --cpu=2 \
    --timeout=300 \
    --min-instances=1 \
    --max-instances=100 \
    --set-env-vars="GOOGLE_API_KEY=${GOOGLE_API_KEY}"

echo "Deployment complete!"

# Mostrar URLs
echo ""
echo "=== Deployed URLs ==="
gcloud functions describe chat-function --region=$REGION --format='value(serviceConfig.uri)'
gcloud functions describe agent-function --region=$REGION --format='value(serviceConfig.uri)'
gcloud run services describe agent-api --region=$REGION --format='value(status.url)'
```

### Cloud Build

```yaml
# cloudbuild.yaml
steps:
  # Build y test
  - name: 'python:3.11'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        pip install -r requirements.txt
        pip install pytest
        pytest tests/ -v

  # Build imagen
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/agent-api:$SHORT_SHA', '.']

  # Push imagen
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/agent-api:$SHORT_SHA']

  # Deploy a Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: 'gcloud'
    args:
      - 'run'
      - 'deploy'
      - 'agent-api'
      - '--image=gcr.io/$PROJECT_ID/agent-api:$SHORT_SHA'
      - '--region=us-central1'
      - '--platform=managed'

images:
  - 'gcr.io/$PROJECT_ID/agent-api:$SHORT_SHA'

options:
  logging: CLOUD_LOGGING_ONLY
```

## Ejemplo de Uso

```python
# client_example.py
import requests
import time

# URLs de las funciones
CHAT_URL = "https://chat-function-xxxxx.cloudfunctions.net/chat"
AGENT_URL = "https://agent-function-xxxxx.cloudfunctions.net/agent"

def test_chat():
    """Test función de chat"""
    response = requests.post(
        CHAT_URL,
        json={
            "message": "¿Qué es Cloud Functions?",
            "session_id": "test-session"
        }
    )
    print("Chat Response:", response.json())

def test_agent_sync():
    """Test agente síncrono"""
    response = requests.post(
        AGENT_URL,
        json={
            "task": "Calcula 15 * 23 y busca información sobre matemáticas",
            "session_id": "agent-test",
            "max_steps": 5
        }
    )
    result = response.json()
    print("Agent Response:", result['response'])
    print("Steps:", len(result['steps']))

def test_agent_async():
    """Test agente asíncrono"""
    # Crear tarea
    response = requests.post(
        AGENT_URL,
        json={
            "task": "Investiga sobre machine learning",
            "async": True
        }
    )
    task_id = response.json()['task_id']
    print(f"Task created: {task_id}")

    # Poll para resultado
    # (en producción, usar webhook o Pub/Sub)

if __name__ == "__main__":
    test_chat()
    test_agent_sync()
```

## Ejercicios Prácticos

### Ejercicio 1: Function Chaining
Implementa cadena de functions:
- Function 1: Recibe y valida request
- Function 2: Procesa con Gemini
- Function 3: Post-procesa y almacena

### Ejercicio 2: Event-Driven Agent
Crea agente disparado por eventos:
- Trigger desde Pub/Sub
- Procesamiento asíncrono
- Notificación al completar

### Ejercicio 3: Cold Start Optimization
Optimiza tiempo de arranque:
- Lazy loading de dependencias
- Conexiones persistentes
- Min instances para funciones críticas

## Resumen

| Concepto | Cloud Functions | Cloud Run |
|----------|-----------------|-----------|
| Modelo | FaaS | Container as a Service |
| Escalado | 0 a N automático | 0 a N automático |
| Timeout máximo | 9 min (gen2) | 60 min |
| Concurrencia | 1 por instancia | Configurable (hasta 1000) |
| Caso de uso | Funciones simples | APIs complejas |
| Cold start | ~2-3s | ~1-2s |

---

**Siguiente:** [10.2.1 Autenticación y Autorización](../tema_10.2/10.2.1-autenticacion-autorizacion.md)
