# 10.2.3 Logging y Auditoría

## Objetivo de Aprendizaje

Al finalizar este subtema, serás capaz de implementar sistemas de logging estructurado y auditoría para agentes de IA, permitiendo debugging, compliance y análisis de comportamiento.

## Introducción

El logging y auditoría en sistemas de agentes es especialmente importante porque necesitamos entender no solo qué hizo el agente, sino por qué lo hizo y con qué datos. Esto es crítico para debugging, seguridad y compliance.

```
┌─────────────────────────────────────────────────────────────────┐
│                SISTEMA DE LOGGING Y AUDITORÍA                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  AGENT ACTIONS                                                  │
│      │                                                          │
│      ▼                                                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              LOGGING PIPELINE                            │   │
│  │                                                          │   │
│  │  ┌─────────┐   ┌─────────┐   ┌─────────┐               │   │
│  │  │ Request │──►│ Process │──►│Response │               │   │
│  │  │  Log    │   │   Log   │   │   Log   │               │   │
│  │  └────┬────┘   └────┬────┘   └────┬────┘               │   │
│  │       │             │             │                     │   │
│  │       └─────────────┼─────────────┘                     │   │
│  │                     ▼                                    │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │              STRUCTURED LOG                      │    │   │
│  │  │  {                                              │    │   │
│  │  │    "timestamp": "...",                          │    │   │
│  │  │    "trace_id": "...",                           │    │   │
│  │  │    "user_id": "...",                            │    │   │
│  │  │    "action": "tool_call",                       │    │   │
│  │  │    "tool": "search",                            │    │   │
│  │  │    "duration_ms": 150                           │    │   │
│  │  │  }                                              │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  └───────────────────────┬─────────────────────────────────┘   │
│                          │                                      │
│      ┌───────────────────┼───────────────────┐                 │
│      ▼                   ▼                   ▼                 │
│  ┌────────┐         ┌────────┐         ┌────────┐             │
│  │ Cloud  │         │BigQuery│         │Elastic │             │
│  │Logging │         │(Audit) │         │ Stack  │             │
│  └────────┘         └────────┘         └────────┘             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Sistema de Logging Estructurado

### Configuración del Logger

```python
import logging
import json
import sys
from datetime import datetime
from typing import Any, Dict, Optional
from dataclasses import dataclass, asdict
from contextvars import ContextVar
import traceback
import uuid

# Context variables para tracing
trace_id_var: ContextVar[str] = ContextVar('trace_id', default='')
user_id_var: ContextVar[str] = ContextVar('user_id', default='')
session_id_var: ContextVar[str] = ContextVar('session_id', default='')

@dataclass
class LogContext:
    """Contexto para logs"""
    trace_id: str
    user_id: Optional[str] = None
    session_id: Optional[str] = None
    environment: str = "development"
    service: str = "agent-api"
    version: str = "1.0.0"

class StructuredFormatter(logging.Formatter):
    """Formatter que produce JSON estructurado"""

    def __init__(self, service: str = "agent-api", version: str = "1.0.0"):
        super().__init__()
        self.service = service
        self.version = version

    def format(self, record: logging.LogRecord) -> str:
        log_entry = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "service": self.service,
            "version": self.version,
            "trace_id": trace_id_var.get() or str(uuid.uuid4()),
            "user_id": user_id_var.get() or None,
            "session_id": session_id_var.get() or None,
        }

        # Añadir información de ubicación
        if record.levelno >= logging.WARNING:
            log_entry["location"] = {
                "file": record.pathname,
                "line": record.lineno,
                "function": record.funcName
            }

        # Añadir excepción si existe
        if record.exc_info:
            log_entry["exception"] = {
                "type": record.exc_info[0].__name__,
                "message": str(record.exc_info[1]),
                "traceback": traceback.format_exception(*record.exc_info)
            }

        # Añadir campos extra
        if hasattr(record, 'extra_fields'):
            log_entry.update(record.extra_fields)

        return json.dumps(log_entry, default=str)


def setup_logging(
    level: str = "INFO",
    service: str = "agent-api",
    version: str = "1.0.0"
):
    """Configura logging estructurado"""

    # Remover handlers existentes
    root = logging.getLogger()
    for handler in root.handlers[:]:
        root.removeHandler(handler)

    # Crear handler con formatter estructurado
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(StructuredFormatter(service, version))

    # Configurar root logger
    root.addHandler(handler)
    root.setLevel(getattr(logging, level.upper()))

    # Silenciar loggers ruidosos
    logging.getLogger("urllib3").setLevel(logging.WARNING)
    logging.getLogger("google").setLevel(logging.WARNING)

    return root


class AgentLogger:
    """Logger especializado para agentes"""

    def __init__(self, name: str = "agent"):
        self.logger = logging.getLogger(name)

    def _log(self, level: int, message: str, **kwargs):
        """Log con campos extra"""
        record = self.logger.makeRecord(
            self.logger.name, level, "", 0, message, (), None
        )
        record.extra_fields = kwargs
        self.logger.handle(record)

    def info(self, message: str, **kwargs):
        self._log(logging.INFO, message, **kwargs)

    def warning(self, message: str, **kwargs):
        self._log(logging.WARNING, message, **kwargs)

    def error(self, message: str, **kwargs):
        self._log(logging.ERROR, message, **kwargs)

    def debug(self, message: str, **kwargs):
        self._log(logging.DEBUG, message, **kwargs)

    # Métodos específicos para agentes
    def log_request(
        self,
        method: str,
        path: str,
        user_id: str,
        **kwargs
    ):
        """Log de request entrante"""
        self.info(
            "Request received",
            event_type="request",
            http_method=method,
            http_path=path,
            user_id=user_id,
            **kwargs
        )

    def log_response(
        self,
        status_code: int,
        duration_ms: float,
        **kwargs
    ):
        """Log de response"""
        self.info(
            "Response sent",
            event_type="response",
            status_code=status_code,
            duration_ms=round(duration_ms, 2),
            **kwargs
        )

    def log_llm_call(
        self,
        model: str,
        input_tokens: int,
        output_tokens: int,
        duration_ms: float,
        **kwargs
    ):
        """Log de llamada a LLM"""
        self.info(
            "LLM call completed",
            event_type="llm_call",
            model=model,
            input_tokens=input_tokens,
            output_tokens=output_tokens,
            total_tokens=input_tokens + output_tokens,
            duration_ms=round(duration_ms, 2),
            **kwargs
        )

    def log_tool_call(
        self,
        tool_name: str,
        success: bool,
        duration_ms: float,
        **kwargs
    ):
        """Log de llamada a tool"""
        level = "info" if success else "warning"
        getattr(self, level)(
            f"Tool call: {tool_name}",
            event_type="tool_call",
            tool=tool_name,
            success=success,
            duration_ms=round(duration_ms, 2),
            **kwargs
        )

    def log_agent_step(
        self,
        step_number: int,
        step_type: str,
        **kwargs
    ):
        """Log de paso del agente"""
        self.info(
            f"Agent step {step_number}",
            event_type="agent_step",
            step_number=step_number,
            step_type=step_type,
            **kwargs
        )

    def log_security_event(
        self,
        event_type: str,
        severity: str,
        **kwargs
    ):
        """Log de evento de seguridad"""
        level = logging.WARNING if severity in ["high", "critical"] else logging.INFO
        self._log(
            level,
            f"Security event: {event_type}",
            event_type="security",
            security_event=event_type,
            severity=severity,
            **kwargs
        )
```

## Sistema de Auditoría

```python
from google.cloud import bigquery
from google.cloud import firestore
from datetime import datetime
from typing import Dict, Any, List, Optional
from enum import Enum
import hashlib

class AuditEventType(Enum):
    # Autenticación
    LOGIN_SUCCESS = "auth.login.success"
    LOGIN_FAILURE = "auth.login.failure"
    LOGOUT = "auth.logout"
    API_KEY_CREATED = "auth.apikey.created"
    API_KEY_REVOKED = "auth.apikey.revoked"

    # Agente
    AGENT_TASK_START = "agent.task.start"
    AGENT_TASK_COMPLETE = "agent.task.complete"
    AGENT_TASK_FAIL = "agent.task.fail"
    AGENT_TOOL_USED = "agent.tool.used"

    # Datos
    DATA_ACCESS = "data.access"
    DATA_MODIFY = "data.modify"
    DATA_DELETE = "data.delete"
    DATA_EXPORT = "data.export"

    # Admin
    CONFIG_CHANGE = "admin.config.change"
    USER_CREATE = "admin.user.create"
    USER_DELETE = "admin.user.delete"
    PERMISSION_CHANGE = "admin.permission.change"

@dataclass
class AuditEvent:
    """Evento de auditoría"""
    event_id: str
    event_type: AuditEventType
    timestamp: datetime
    actor_id: str
    actor_type: str  # "user", "service", "system"
    resource_type: str
    resource_id: Optional[str]
    action: str
    outcome: str  # "success", "failure", "error"
    details: Dict[str, Any]
    ip_address: Optional[str]
    user_agent: Optional[str]
    trace_id: Optional[str]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "event_id": self.event_id,
            "event_type": self.event_type.value,
            "timestamp": self.timestamp.isoformat(),
            "actor_id": self.actor_id,
            "actor_type": self.actor_type,
            "resource_type": self.resource_type,
            "resource_id": self.resource_id,
            "action": self.action,
            "outcome": self.outcome,
            "details": self.details,
            "ip_address": self.ip_address,
            "user_agent": self.user_agent,
            "trace_id": self.trace_id,
            "details_hash": self._hash_details()
        }

    def _hash_details(self) -> str:
        """Hash de details para integridad"""
        content = json.dumps(self.details, sort_keys=True)
        return hashlib.sha256(content.encode()).hexdigest()[:16]


class AuditLogger:
    """Logger de auditoría con múltiples backends"""

    def __init__(
        self,
        bigquery_client: Optional[bigquery.Client] = None,
        firestore_client: Optional[firestore.Client] = None,
        dataset_id: str = "audit_logs",
        table_id: str = "events"
    ):
        self.bq = bigquery_client
        self.fs = firestore_client
        self.dataset_id = dataset_id
        self.table_id = table_id
        self.logger = AgentLogger("audit")

        # Buffer para batch inserts
        self._buffer: List[AuditEvent] = []
        self._buffer_size = 100

    async def log(self, event: AuditEvent):
        """Registra evento de auditoría"""

        # Log inmediato estructurado
        self.logger.info(
            f"Audit: {event.event_type.value}",
            event_type="audit",
            audit_event=event.event_type.value,
            actor_id=event.actor_id,
            resource_type=event.resource_type,
            outcome=event.outcome
        )

        # Guardar en Firestore (para consultas rápidas)
        if self.fs:
            await self._save_to_firestore(event)

        # Buffer para BigQuery (para analytics)
        self._buffer.append(event)
        if len(self._buffer) >= self._buffer_size:
            await self._flush_to_bigquery()

    async def _save_to_firestore(self, event: AuditEvent):
        """Guarda evento en Firestore"""
        doc_ref = self.fs.collection('audit_events').document(event.event_id)
        doc_ref.set(event.to_dict())

    async def _flush_to_bigquery(self):
        """Envía buffer a BigQuery"""
        if not self._buffer or not self.bq:
            return

        table_ref = f"{self.dataset_id}.{self.table_id}"

        rows = [event.to_dict() for event in self._buffer]

        errors = self.bq.insert_rows_json(table_ref, rows)

        if errors:
            self.logger.error(
                "BigQuery insert errors",
                errors=errors[:5]  # Limitar errores logueados
            )

        self._buffer = []

    async def query_events(
        self,
        actor_id: Optional[str] = None,
        event_type: Optional[AuditEventType] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        limit: int = 100
    ) -> List[AuditEvent]:
        """Consulta eventos de auditoría"""

        if not self.fs:
            return []

        query = self.fs.collection('audit_events')

        if actor_id:
            query = query.where('actor_id', '==', actor_id)

        if event_type:
            query = query.where('event_type', '==', event_type.value)

        if start_time:
            query = query.where('timestamp', '>=', start_time.isoformat())

        if end_time:
            query = query.where('timestamp', '<=', end_time.isoformat())

        query = query.order_by('timestamp', direction=firestore.Query.DESCENDING)
        query = query.limit(limit)

        docs = query.stream()

        events = []
        for doc in docs:
            data = doc.to_dict()
            events.append(AuditEvent(
                event_id=data['event_id'],
                event_type=AuditEventType(data['event_type']),
                timestamp=datetime.fromisoformat(data['timestamp']),
                actor_id=data['actor_id'],
                actor_type=data['actor_type'],
                resource_type=data['resource_type'],
                resource_id=data.get('resource_id'),
                action=data['action'],
                outcome=data['outcome'],
                details=data['details'],
                ip_address=data.get('ip_address'),
                user_agent=data.get('user_agent'),
                trace_id=data.get('trace_id')
            ))

        return events


class AgentAuditMixin:
    """Mixin para añadir auditoría a agentes"""

    def __init__(self, audit_logger: AuditLogger):
        self.audit = audit_logger

    async def audit_task_start(
        self,
        task_id: str,
        task_description: str,
        user_id: str,
        **kwargs
    ):
        """Audita inicio de tarea"""
        event = AuditEvent(
            event_id=f"evt_{uuid.uuid4().hex[:12]}",
            event_type=AuditEventType.AGENT_TASK_START,
            timestamp=datetime.utcnow(),
            actor_id=user_id,
            actor_type="user",
            resource_type="agent_task",
            resource_id=task_id,
            action="start",
            outcome="success",
            details={
                "task_description": task_description[:500],
                **kwargs
            },
            ip_address=kwargs.get('ip_address'),
            user_agent=kwargs.get('user_agent'),
            trace_id=trace_id_var.get()
        )
        await self.audit.log(event)

    async def audit_tool_usage(
        self,
        task_id: str,
        tool_name: str,
        tool_args: Dict,
        result: Any,
        user_id: str,
        success: bool
    ):
        """Audita uso de herramienta"""
        # Sanitizar argumentos sensibles
        safe_args = self._sanitize_args(tool_args)

        event = AuditEvent(
            event_id=f"evt_{uuid.uuid4().hex[:12]}",
            event_type=AuditEventType.AGENT_TOOL_USED,
            timestamp=datetime.utcnow(),
            actor_id=user_id,
            actor_type="agent",
            resource_type="tool",
            resource_id=tool_name,
            action="execute",
            outcome="success" if success else "failure",
            details={
                "task_id": task_id,
                "tool_name": tool_name,
                "arguments": safe_args,
                "result_preview": str(result)[:200] if result else None
            },
            ip_address=None,
            user_agent=None,
            trace_id=trace_id_var.get()
        )
        await self.audit.log(event)

    def _sanitize_args(self, args: Dict) -> Dict:
        """Elimina datos sensibles de argumentos"""
        sensitive_keys = {'password', 'api_key', 'secret', 'token', 'credential'}
        sanitized = {}

        for key, value in args.items():
            if any(s in key.lower() for s in sensitive_keys):
                sanitized[key] = "[REDACTED]"
            elif isinstance(value, dict):
                sanitized[key] = self._sanitize_args(value)
            else:
                sanitized[key] = value

        return sanitized
```

## Middleware de Logging

```python
from fastapi import FastAPI, Request, Response
from starlette.middleware.base import BaseHTTPMiddleware
import time
import uuid

class LoggingMiddleware(BaseHTTPMiddleware):
    """Middleware de logging para FastAPI"""

    def __init__(self, app: FastAPI, logger: AgentLogger):
        super().__init__(app)
        self.logger = logger

    async def dispatch(self, request: Request, call_next):
        # Generar trace ID
        trace_id = request.headers.get("X-Trace-ID", str(uuid.uuid4()))
        trace_id_var.set(trace_id)

        # Extraer user ID si está autenticado
        user_id = None
        if hasattr(request.state, 'identity'):
            user_id = request.state.identity.id
            user_id_var.set(user_id)

        # Log request
        self.logger.log_request(
            method=request.method,
            path=request.url.path,
            user_id=user_id or "anonymous",
            query_params=dict(request.query_params),
            headers={
                "content-type": request.headers.get("content-type"),
                "user-agent": request.headers.get("user-agent")
            }
        )

        # Procesar request
        start_time = time.time()

        try:
            response = await call_next(request)
            duration_ms = (time.time() - start_time) * 1000

            # Log response
            self.logger.log_response(
                status_code=response.status_code,
                duration_ms=duration_ms
            )

            # Añadir trace ID a response
            response.headers["X-Trace-ID"] = trace_id

            return response

        except Exception as e:
            duration_ms = (time.time() - start_time) * 1000

            self.logger.error(
                "Request failed",
                error=str(e),
                error_type=type(e).__name__,
                duration_ms=duration_ms
            )
            raise
```

## Ejemplo Práctico

```python
import asyncio
from fastapi import FastAPI, Depends

# Setup
app = FastAPI()
setup_logging(level="INFO", service="agent-api", version="1.0.0")

logger = AgentLogger("agent")
audit_logger = AuditLogger(
    firestore_client=firestore.Client()
)

# Añadir middleware
app.add_middleware(LoggingMiddleware, logger=logger)

@app.post("/api/v1/agent/execute")
async def execute_agent(
    request: dict,
    identity: Identity = Depends(get_current_identity)
):
    task_id = str(uuid.uuid4())

    # Audit inicio
    await audit_logger.log(AuditEvent(
        event_id=f"evt_{uuid.uuid4().hex[:12]}",
        event_type=AuditEventType.AGENT_TASK_START,
        timestamp=datetime.utcnow(),
        actor_id=identity.id,
        actor_type="user",
        resource_type="agent_task",
        resource_id=task_id,
        action="execute",
        outcome="success",
        details={"task": request.get("task", "")[:500]},
        ip_address=None,
        user_agent=None,
        trace_id=trace_id_var.get()
    ))

    # Log de pasos del agente
    for i in range(3):
        logger.log_agent_step(
            step_number=i + 1,
            step_type="reasoning",
            task_id=task_id
        )

        # Simular llamada a LLM
        logger.log_llm_call(
            model="gemini-2.0-flash",
            input_tokens=500,
            output_tokens=200,
            duration_ms=150.5,
            task_id=task_id
        )

        # Simular llamada a tool
        logger.log_tool_call(
            tool_name="search",
            success=True,
            duration_ms=85.3,
            task_id=task_id
        )

    # Audit completado
    await audit_logger.log(AuditEvent(
        event_id=f"evt_{uuid.uuid4().hex[:12]}",
        event_type=AuditEventType.AGENT_TASK_COMPLETE,
        timestamp=datetime.utcnow(),
        actor_id=identity.id,
        actor_type="user",
        resource_type="agent_task",
        resource_id=task_id,
        action="complete",
        outcome="success",
        details={"steps_taken": 3, "total_tokens": 2100},
        ip_address=None,
        user_agent=None,
        trace_id=trace_id_var.get()
    ))

    return {"task_id": task_id, "status": "completed"}

# Endpoint para consultar audit logs
@app.get("/api/v1/admin/audit")
async def get_audit_logs(
    actor_id: Optional[str] = None,
    event_type: Optional[str] = None,
    limit: int = 100,
    identity: Identity = Depends(get_current_identity)
):
    # Verificar permisos admin
    # ...

    event_type_enum = None
    if event_type:
        event_type_enum = AuditEventType(event_type)

    events = await audit_logger.query_events(
        actor_id=actor_id,
        event_type=event_type_enum,
        limit=limit
    )

    return {
        "events": [e.to_dict() for e in events],
        "count": len(events)
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8080)
```

## Ejercicios Prácticos

### Ejercicio 1: Log Analysis Pipeline
Implementa pipeline de análisis:
- Exportar logs a BigQuery
- Crear vistas de análisis
- Dashboard en Looker/Data Studio

### Ejercicio 2: Alertas de Seguridad
Configura alertas basadas en logs:
- Múltiples intentos de auth fallidos
- Acceso a datos sensibles
- Patrones de uso anómalos

### Ejercicio 3: Compliance Report
Genera reportes de compliance:
- Accesos por usuario
- Datos accedidos
- Retención y eliminación

## Resumen

| Concepto | Descripción |
|----------|-------------|
| Structured Logging | Logs en formato JSON parseable |
| Trace ID | Identificador que conecta logs relacionados |
| Audit Event | Registro inmutable de acción importante |
| Context Variables | Variables que se propagan en el contexto |
| Log Levels | DEBUG, INFO, WARNING, ERROR, CRITICAL |
| Sanitization | Eliminar datos sensibles de logs |

---

**Siguiente:** [10.3.1 Métricas y Dashboards](../tema_10.3/10.3.1-metricas-dashboards.md)
