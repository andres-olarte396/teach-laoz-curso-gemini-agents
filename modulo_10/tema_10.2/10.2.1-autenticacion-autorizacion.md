# 10.2.1 Autenticación y Autorización

## Objetivo de Aprendizaje

Al finalizar este subtema, serás capaz de implementar sistemas robustos de autenticación y autorización para APIs de agentes, protegiendo recursos y controlando acceso granular.

## Introducción

La seguridad en APIs de agentes es crítica porque estos sistemas pueden acceder a datos sensibles y ejecutar acciones con consecuencias reales. Un sistema de autenticación y autorización bien diseñado es la primera línea de defensa.

```
┌─────────────────────────────────────────────────────────────────┐
│                 MODELO DE SEGURIDAD                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  CLIENT                                                         │
│    │                                                            │
│    │ 1. Request + Credentials                                   │
│    ▼                                                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                AUTHENTICATION LAYER                      │   │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐    │   │
│  │  │API Keys │  │  JWT    │  │ OAuth2  │  │  mTLS   │    │   │
│  │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘    │   │
│  │       └───────────┬┴───────────┬┴────────────┘         │   │
│  │                   ▼                                     │   │
│  │            ┌─────────────┐                              │   │
│  │            │  Identity   │                              │   │
│  │            │  Validated  │                              │   │
│  │            └──────┬──────┘                              │   │
│  └───────────────────┼─────────────────────────────────────┘   │
│                      ▼                                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                AUTHORIZATION LAYER                       │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │  RBAC: Roles → Permissions → Resources          │    │   │
│  │  │                                                  │    │   │
│  │  │  admin ──► [all permissions]                    │    │   │
│  │  │  user  ──► [chat, read_history]                 │    │   │
│  │  │  agent ──► [use_tools, access_memory]           │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  └───────────────────┬─────────────────────────────────────┘   │
│                      ▼                                          │
│              ┌──────────────┐                                   │
│              │ AGENT API    │                                   │
│              └──────────────┘                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Sistema de Autenticación

### Modelos de Autenticación

```python
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from enum import Enum
from datetime import datetime, timedelta
from abc import ABC, abstractmethod
import hashlib
import secrets
import jwt
import bcrypt

class AuthMethod(Enum):
    API_KEY = "api_key"
    JWT = "jwt"
    OAUTH2 = "oauth2"
    MTLS = "mtls"

@dataclass
class Identity:
    """Identidad autenticada"""
    id: str
    type: str  # "user", "service", "agent"
    name: str
    email: Optional[str] = None
    roles: List[str] = field(default_factory=list)
    permissions: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    authenticated_at: datetime = field(default_factory=datetime.utcnow)
    auth_method: AuthMethod = AuthMethod.API_KEY

@dataclass
class APIKey:
    """API Key para autenticación"""
    key_id: str
    key_hash: str  # Hash del key, nunca almacenar en texto plano
    name: str
    owner_id: str
    scopes: List[str]
    created_at: datetime
    expires_at: Optional[datetime]
    last_used_at: Optional[datetime]
    is_active: bool = True
    rate_limit: int = 1000  # requests por hora
    metadata: Dict[str, Any] = field(default_factory=dict)

class AuthenticationError(Exception):
    """Error de autenticación"""
    def __init__(self, message: str, code: str = "AUTH_ERROR"):
        super().__init__(message)
        self.code = code
```

### Autenticación con API Keys

```python
from google.cloud import firestore
import os

class APIKeyAuthenticator:
    """Autenticador basado en API Keys"""

    def __init__(self):
        self.db = firestore.Client()
        self.cache: Dict[str, APIKey] = {}
        self.cache_ttl = 300  # 5 minutos

    def generate_api_key(
        self,
        owner_id: str,
        name: str,
        scopes: List[str],
        expires_in_days: Optional[int] = None
    ) -> tuple[str, APIKey]:
        """
        Genera un nuevo API Key

        Returns:
            Tuple de (key_plaintext, APIKey object)
            El key_plaintext solo se muestra una vez
        """
        # Generar key seguro
        key_plaintext = f"agent_{secrets.token_urlsafe(32)}"
        key_hash = self._hash_key(key_plaintext)
        key_id = secrets.token_urlsafe(16)

        expires_at = None
        if expires_in_days:
            expires_at = datetime.utcnow() + timedelta(days=expires_in_days)

        api_key = APIKey(
            key_id=key_id,
            key_hash=key_hash,
            name=name,
            owner_id=owner_id,
            scopes=scopes,
            created_at=datetime.utcnow(),
            expires_at=expires_at,
            last_used_at=None
        )

        # Guardar en Firestore
        self._save_key(api_key)

        return key_plaintext, api_key

    def authenticate(self, key_plaintext: str) -> Identity:
        """Autentica usando API Key"""

        if not key_plaintext:
            raise AuthenticationError("API key required", "MISSING_KEY")

        # Buscar key
        key_hash = self._hash_key(key_plaintext)
        api_key = self._find_key_by_hash(key_hash)

        if not api_key:
            raise AuthenticationError("Invalid API key", "INVALID_KEY")

        # Validar estado
        if not api_key.is_active:
            raise AuthenticationError("API key is disabled", "KEY_DISABLED")

        # Validar expiración
        if api_key.expires_at and datetime.utcnow() > api_key.expires_at:
            raise AuthenticationError("API key expired", "KEY_EXPIRED")

        # Actualizar último uso
        self._update_last_used(api_key.key_id)

        # Crear identidad
        return Identity(
            id=api_key.owner_id,
            type="service",
            name=api_key.name,
            roles=["api_user"],
            permissions=api_key.scopes,
            auth_method=AuthMethod.API_KEY,
            metadata={"key_id": api_key.key_id}
        )

    def _hash_key(self, key: str) -> str:
        """Hash seguro del API key"""
        return hashlib.sha256(key.encode()).hexdigest()

    def _save_key(self, api_key: APIKey):
        """Guarda API key en Firestore"""
        doc_ref = self.db.collection('api_keys').document(api_key.key_id)
        doc_ref.set({
            'key_hash': api_key.key_hash,
            'name': api_key.name,
            'owner_id': api_key.owner_id,
            'scopes': api_key.scopes,
            'created_at': api_key.created_at,
            'expires_at': api_key.expires_at,
            'is_active': api_key.is_active,
            'rate_limit': api_key.rate_limit
        })

    def _find_key_by_hash(self, key_hash: str) -> Optional[APIKey]:
        """Busca key por hash"""
        # Primero buscar en cache
        if key_hash in self.cache:
            return self.cache[key_hash]

        # Buscar en Firestore
        query = self.db.collection('api_keys').where('key_hash', '==', key_hash).limit(1)
        docs = list(query.stream())

        if not docs:
            return None

        doc = docs[0]
        data = doc.to_dict()

        api_key = APIKey(
            key_id=doc.id,
            key_hash=data['key_hash'],
            name=data['name'],
            owner_id=data['owner_id'],
            scopes=data['scopes'],
            created_at=data['created_at'],
            expires_at=data.get('expires_at'),
            last_used_at=data.get('last_used_at'),
            is_active=data.get('is_active', True),
            rate_limit=data.get('rate_limit', 1000)
        )

        # Guardar en cache
        self.cache[key_hash] = api_key

        return api_key

    def _update_last_used(self, key_id: str):
        """Actualiza timestamp de último uso"""
        self.db.collection('api_keys').document(key_id).update({
            'last_used_at': datetime.utcnow()
        })
```

### Autenticación con JWT

```python
from datetime import datetime, timedelta
import jwt

class JWTAuthenticator:
    """Autenticador basado en JWT"""

    def __init__(
        self,
        secret_key: str,
        algorithm: str = "HS256",
        access_token_expire_minutes: int = 30,
        refresh_token_expire_days: int = 7
    ):
        self.secret_key = secret_key
        self.algorithm = algorithm
        self.access_token_expire = timedelta(minutes=access_token_expire_minutes)
        self.refresh_token_expire = timedelta(days=refresh_token_expire_days)

    def create_access_token(
        self,
        identity: Identity,
        additional_claims: Optional[Dict] = None
    ) -> str:
        """Crea token de acceso JWT"""

        now = datetime.utcnow()
        expire = now + self.access_token_expire

        payload = {
            "sub": identity.id,
            "type": identity.type,
            "name": identity.name,
            "roles": identity.roles,
            "permissions": identity.permissions,
            "iat": now,
            "exp": expire,
            "token_type": "access"
        }

        if additional_claims:
            payload.update(additional_claims)

        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)

    def create_refresh_token(self, identity: Identity) -> str:
        """Crea token de refresh"""

        now = datetime.utcnow()
        expire = now + self.refresh_token_expire

        payload = {
            "sub": identity.id,
            "iat": now,
            "exp": expire,
            "token_type": "refresh"
        }

        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)

    def authenticate(self, token: str) -> Identity:
        """Valida JWT y retorna identidad"""

        try:
            payload = jwt.decode(
                token,
                self.secret_key,
                algorithms=[self.algorithm]
            )

            if payload.get("token_type") != "access":
                raise AuthenticationError(
                    "Invalid token type",
                    "INVALID_TOKEN_TYPE"
                )

            return Identity(
                id=payload["sub"],
                type=payload.get("type", "user"),
                name=payload.get("name", ""),
                roles=payload.get("roles", []),
                permissions=payload.get("permissions", []),
                auth_method=AuthMethod.JWT,
                metadata={"exp": payload["exp"]}
            )

        except jwt.ExpiredSignatureError:
            raise AuthenticationError("Token expired", "TOKEN_EXPIRED")
        except jwt.InvalidTokenError as e:
            raise AuthenticationError(f"Invalid token: {e}", "INVALID_TOKEN")

    def refresh_access_token(self, refresh_token: str) -> str:
        """Genera nuevo access token usando refresh token"""

        try:
            payload = jwt.decode(
                refresh_token,
                self.secret_key,
                algorithms=[self.algorithm]
            )

            if payload.get("token_type") != "refresh":
                raise AuthenticationError(
                    "Invalid token type",
                    "INVALID_TOKEN_TYPE"
                )

            # Crear nueva identidad básica
            identity = Identity(
                id=payload["sub"],
                type="user",
                name="",
                roles=[],
                permissions=[]
            )

            # TODO: Recargar roles y permisos desde DB

            return self.create_access_token(identity)

        except jwt.ExpiredSignatureError:
            raise AuthenticationError(
                "Refresh token expired",
                "REFRESH_TOKEN_EXPIRED"
            )
        except jwt.InvalidTokenError as e:
            raise AuthenticationError(f"Invalid token: {e}", "INVALID_TOKEN")
```

## Sistema de Autorización

### RBAC (Role-Based Access Control)

```python
from enum import Enum
from typing import Set

class Permission(Enum):
    """Permisos del sistema"""
    # Chat
    CHAT_READ = "chat:read"
    CHAT_WRITE = "chat:write"

    # Agente
    AGENT_EXECUTE = "agent:execute"
    AGENT_CONFIGURE = "agent:configure"

    # Tools
    TOOL_USE = "tool:use"
    TOOL_CREATE = "tool:create"
    TOOL_DELETE = "tool:delete"

    # Memory
    MEMORY_READ = "memory:read"
    MEMORY_WRITE = "memory:write"
    MEMORY_DELETE = "memory:delete"

    # Admin
    ADMIN_USERS = "admin:users"
    ADMIN_KEYS = "admin:keys"
    ADMIN_AUDIT = "admin:audit"

    # System
    SYSTEM_METRICS = "system:metrics"
    SYSTEM_CONFIG = "system:config"


class Role(Enum):
    """Roles predefinidos"""
    ANONYMOUS = "anonymous"
    USER = "user"
    AGENT = "agent"
    DEVELOPER = "developer"
    ADMIN = "admin"
    SUPER_ADMIN = "super_admin"


# Mapeo de roles a permisos
ROLE_PERMISSIONS: Dict[Role, Set[Permission]] = {
    Role.ANONYMOUS: {
        Permission.CHAT_READ,
    },
    Role.USER: {
        Permission.CHAT_READ,
        Permission.CHAT_WRITE,
        Permission.MEMORY_READ,
    },
    Role.AGENT: {
        Permission.CHAT_READ,
        Permission.CHAT_WRITE,
        Permission.AGENT_EXECUTE,
        Permission.TOOL_USE,
        Permission.MEMORY_READ,
        Permission.MEMORY_WRITE,
    },
    Role.DEVELOPER: {
        Permission.CHAT_READ,
        Permission.CHAT_WRITE,
        Permission.AGENT_EXECUTE,
        Permission.AGENT_CONFIGURE,
        Permission.TOOL_USE,
        Permission.TOOL_CREATE,
        Permission.MEMORY_READ,
        Permission.MEMORY_WRITE,
        Permission.SYSTEM_METRICS,
    },
    Role.ADMIN: {
        Permission.CHAT_READ,
        Permission.CHAT_WRITE,
        Permission.AGENT_EXECUTE,
        Permission.AGENT_CONFIGURE,
        Permission.TOOL_USE,
        Permission.TOOL_CREATE,
        Permission.TOOL_DELETE,
        Permission.MEMORY_READ,
        Permission.MEMORY_WRITE,
        Permission.MEMORY_DELETE,
        Permission.ADMIN_USERS,
        Permission.ADMIN_KEYS,
        Permission.ADMIN_AUDIT,
        Permission.SYSTEM_METRICS,
    },
    Role.SUPER_ADMIN: set(Permission),  # Todos los permisos
}


class Authorizer:
    """Sistema de autorización"""

    def __init__(self):
        self.role_permissions = ROLE_PERMISSIONS
        self.custom_permissions: Dict[str, Set[Permission]] = {}

    def get_permissions(self, identity: Identity) -> Set[Permission]:
        """Obtiene todos los permisos de una identidad"""

        permissions = set()

        # Permisos de roles
        for role_name in identity.roles:
            try:
                role = Role(role_name)
                permissions.update(self.role_permissions.get(role, set()))
            except ValueError:
                pass  # Rol desconocido

        # Permisos explícitos
        for perm_name in identity.permissions:
            try:
                permissions.add(Permission(perm_name))
            except ValueError:
                pass  # Permiso desconocido

        # Permisos custom del usuario
        if identity.id in self.custom_permissions:
            permissions.update(self.custom_permissions[identity.id])

        return permissions

    def has_permission(
        self,
        identity: Identity,
        permission: Permission
    ) -> bool:
        """Verifica si la identidad tiene un permiso"""
        return permission in self.get_permissions(identity)

    def require_permission(
        self,
        identity: Identity,
        permission: Permission
    ):
        """Requiere permiso o lanza excepción"""
        if not self.has_permission(identity, permission):
            raise AuthorizationError(
                f"Missing permission: {permission.value}",
                "INSUFFICIENT_PERMISSIONS"
            )

    def require_any_permission(
        self,
        identity: Identity,
        permissions: List[Permission]
    ):
        """Requiere al menos uno de los permisos"""
        user_perms = self.get_permissions(identity)
        if not any(p in user_perms for p in permissions):
            raise AuthorizationError(
                f"Missing any of: {[p.value for p in permissions]}",
                "INSUFFICIENT_PERMISSIONS"
            )

    def require_all_permissions(
        self,
        identity: Identity,
        permissions: List[Permission]
    ):
        """Requiere todos los permisos"""
        user_perms = self.get_permissions(identity)
        missing = [p for p in permissions if p not in user_perms]
        if missing:
            raise AuthorizationError(
                f"Missing permissions: {[p.value for p in missing]}",
                "INSUFFICIENT_PERMISSIONS"
            )


class AuthorizationError(Exception):
    """Error de autorización"""
    def __init__(self, message: str, code: str = "AUTHZ_ERROR"):
        super().__init__(message)
        self.code = code
```

## Middleware de Seguridad

### FastAPI Security Middleware

```python
from fastapi import FastAPI, Request, HTTPException, Depends, Security
from fastapi.security import APIKeyHeader, HTTPBearer, HTTPAuthorizationCredentials
from functools import wraps
from typing import Callable

# Security schemes
api_key_header = APIKeyHeader(name="X-API-Key", auto_error=False)
bearer_scheme = HTTPBearer(auto_error=False)

class SecurityMiddleware:
    """Middleware de seguridad para FastAPI"""

    def __init__(
        self,
        api_key_auth: APIKeyAuthenticator,
        jwt_auth: JWTAuthenticator,
        authorizer: Authorizer
    ):
        self.api_key_auth = api_key_auth
        self.jwt_auth = jwt_auth
        self.authorizer = authorizer

    async def authenticate(
        self,
        request: Request,
        api_key: Optional[str] = Security(api_key_header),
        bearer: Optional[HTTPAuthorizationCredentials] = Security(bearer_scheme)
    ) -> Identity:
        """Autentica request usando API Key o JWT"""

        # Intentar API Key primero
        if api_key:
            try:
                return self.api_key_auth.authenticate(api_key)
            except AuthenticationError:
                pass

        # Intentar JWT
        if bearer:
            try:
                return self.jwt_auth.authenticate(bearer.credentials)
            except AuthenticationError:
                pass

        raise HTTPException(
            status_code=401,
            detail="Authentication required",
            headers={"WWW-Authenticate": "Bearer"}
        )

    def require_permissions(self, *permissions: Permission):
        """Decorator para requerir permisos"""

        def decorator(func: Callable):
            @wraps(func)
            async def wrapper(*args, identity: Identity = None, **kwargs):
                if identity is None:
                    raise HTTPException(status_code=401, detail="Not authenticated")

                try:
                    for permission in permissions:
                        self.authorizer.require_permission(identity, permission)
                except AuthorizationError as e:
                    raise HTTPException(
                        status_code=403,
                        detail=str(e)
                    )

                return await func(*args, identity=identity, **kwargs)

            return wrapper
        return decorator


# Uso en FastAPI
def create_secured_app():
    app = FastAPI()

    # Inicializar servicios de seguridad
    api_key_auth = APIKeyAuthenticator()
    jwt_auth = JWTAuthenticator(secret_key=os.environ["JWT_SECRET"])
    authorizer = Authorizer()
    security = SecurityMiddleware(api_key_auth, jwt_auth, authorizer)

    # Dependency para obtener identidad autenticada
    async def get_current_identity(
        request: Request,
        api_key: Optional[str] = Security(api_key_header),
        bearer: Optional[HTTPAuthorizationCredentials] = Security(bearer_scheme)
    ) -> Identity:
        return await security.authenticate(request, api_key, bearer)

    # Endpoint protegido
    @app.post("/api/v1/chat")
    async def chat(
        request: dict,
        identity: Identity = Depends(get_current_identity)
    ):
        # Verificar permisos
        authorizer.require_permission(identity, Permission.CHAT_WRITE)

        return {"message": "Chat response", "user": identity.id}

    # Endpoint con decorator de permisos
    @app.post("/api/v1/agent/execute")
    @security.require_permissions(Permission.AGENT_EXECUTE, Permission.TOOL_USE)
    async def execute_agent(
        request: dict,
        identity: Identity = Depends(get_current_identity)
    ):
        return {"message": "Agent executed", "user": identity.id}

    # Endpoint admin
    @app.get("/api/v1/admin/users")
    async def list_users(
        identity: Identity = Depends(get_current_identity)
    ):
        authorizer.require_permission(identity, Permission.ADMIN_USERS)
        return {"users": []}

    return app
```

## Gestión de Sesiones

```python
import redis.asyncio as redis
import json
from uuid import uuid4

class SessionManager:
    """Gestión de sesiones de usuario"""

    def __init__(self, redis_url: str, session_ttl: int = 3600):
        self.redis = redis.from_url(redis_url)
        self.session_ttl = session_ttl

    async def create_session(self, identity: Identity) -> str:
        """Crea nueva sesión"""
        session_id = str(uuid4())

        session_data = {
            "identity_id": identity.id,
            "identity_type": identity.type,
            "roles": identity.roles,
            "permissions": identity.permissions,
            "created_at": datetime.utcnow().isoformat(),
            "auth_method": identity.auth_method.value
        }

        await self.redis.setex(
            f"session:{session_id}",
            self.session_ttl,
            json.dumps(session_data)
        )

        return session_id

    async def get_session(self, session_id: str) -> Optional[dict]:
        """Obtiene datos de sesión"""
        data = await self.redis.get(f"session:{session_id}")
        if data:
            # Renovar TTL
            await self.redis.expire(f"session:{session_id}", self.session_ttl)
            return json.loads(data)
        return None

    async def destroy_session(self, session_id: str):
        """Destruye sesión (logout)"""
        await self.redis.delete(f"session:{session_id}")

    async def destroy_all_sessions(self, identity_id: str):
        """Destruye todas las sesiones de un usuario"""
        pattern = "session:*"
        cursor = 0

        while True:
            cursor, keys = await self.redis.scan(cursor, match=pattern, count=100)

            for key in keys:
                data = await self.redis.get(key)
                if data:
                    session = json.loads(data)
                    if session.get("identity_id") == identity_id:
                        await self.redis.delete(key)

            if cursor == 0:
                break
```

## Ejemplo Práctico Completo

```python
import os
from fastapi import FastAPI, Depends, HTTPException
from pydantic import BaseModel

# Inicializar app
app = FastAPI(title="Secure Agent API")

# Servicios de seguridad
api_key_auth = APIKeyAuthenticator()
jwt_auth = JWTAuthenticator(secret_key=os.environ.get("JWT_SECRET", "dev-secret"))
authorizer = Authorizer()
session_manager = SessionManager(redis_url=os.environ.get("REDIS_URL", "redis://localhost"))

# Schemas
class LoginRequest(BaseModel):
    username: str
    password: str

class ChatRequest(BaseModel):
    message: str
    session_id: Optional[str] = None

# Endpoints
@app.post("/api/v1/auth/login")
async def login(request: LoginRequest):
    """Login y obtención de tokens"""
    # TODO: Validar credenciales contra DB
    # Por ahora, demo
    if request.username == "demo" and request.password == "demo":
        identity = Identity(
            id="user_123",
            type="user",
            name="Demo User",
            email="demo@example.com",
            roles=["user", "developer"],
            permissions=[]
        )

        access_token = jwt_auth.create_access_token(identity)
        refresh_token = jwt_auth.create_refresh_token(identity)
        session_id = await session_manager.create_session(identity)

        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "session_id": session_id,
            "token_type": "bearer",
            "expires_in": 1800
        }

    raise HTTPException(status_code=401, detail="Invalid credentials")

@app.post("/api/v1/auth/api-key")
async def create_api_key(
    name: str,
    scopes: List[str],
    identity: Identity = Depends(get_current_identity)
):
    """Crea nuevo API Key"""
    authorizer.require_permission(identity, Permission.ADMIN_KEYS)

    key_plaintext, api_key = api_key_auth.generate_api_key(
        owner_id=identity.id,
        name=name,
        scopes=scopes,
        expires_in_days=365
    )

    return {
        "api_key": key_plaintext,
        "key_id": api_key.key_id,
        "message": "Save this key securely. It won't be shown again."
    }

@app.post("/api/v1/chat")
async def chat(
    request: ChatRequest,
    identity: Identity = Depends(get_current_identity)
):
    """Chat protegido"""
    authorizer.require_permission(identity, Permission.CHAT_WRITE)

    # Procesar chat...
    return {
        "response": f"Hello {identity.name}! You said: {request.message}",
        "user_id": identity.id
    }

@app.get("/api/v1/me")
async def get_current_user(identity: Identity = Depends(get_current_identity)):
    """Obtiene información del usuario actual"""
    permissions = authorizer.get_permissions(identity)

    return {
        "id": identity.id,
        "name": identity.name,
        "type": identity.type,
        "roles": identity.roles,
        "permissions": [p.value for p in permissions]
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8080)
```

## Ejercicios Prácticos

### Ejercicio 1: OAuth2 con Google
Implementa autenticación OAuth2:
- Login con Google
- Intercambio de tokens
- Refresh automático

### Ejercicio 2: Permisos Dinámicos
Extiende el sistema de permisos:
- Permisos por recurso específico
- Permisos temporales
- Delegación de permisos

### Ejercicio 3: Auditoría de Acceso
Implementa logging de seguridad:
- Registrar todos los intentos de autenticación
- Alertas por accesos sospechosos
- Dashboard de seguridad

## Resumen

| Concepto | Descripción |
|----------|-------------|
| API Key | Autenticación simple para servicios |
| JWT | Tokens stateless con claims |
| RBAC | Control de acceso basado en roles |
| Permissions | Permisos granulares por acción |
| Session | Estado de sesión en servidor |
| Middleware | Intercepta y valida requests |

---

**Siguiente:** [10.2.2 Rate Limiting y Quotas](./10.2.2-rate-limiting-quotas.md)
