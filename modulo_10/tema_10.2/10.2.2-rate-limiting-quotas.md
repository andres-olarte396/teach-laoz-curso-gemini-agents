# 10.2.2 Rate Limiting y Quotas

## Objetivo de Aprendizaje

Al finalizar este subtema, serás capaz de implementar sistemas de rate limiting y gestión de quotas para proteger APIs de agentes contra abusos y garantizar uso justo de recursos.

## Introducción

El rate limiting protege tu API de sobrecarga, mientras que las quotas aseguran distribución justa de recursos. Para agentes que consumen APIs costosas como Gemini, esto es especialmente crítico.

```
┌─────────────────────────────────────────────────────────────────┐
│                 SISTEMA DE RATE LIMITING                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  REQUEST ──────────────────────────────────────────────────►    │
│      │                                                          │
│      ▼                                                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              RATE LIMITER                                │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │  Algoritmos:                                     │    │   │
│  │  │  • Fixed Window    • Sliding Window             │    │   │
│  │  │  • Token Bucket    • Leaky Bucket               │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │                                                          │   │
│  │  Límites por:                                            │   │
│  │  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐           │   │
│  │  │  IP    │ │ User   │ │API Key │ │Endpoint│           │   │
│  │  └────────┘ └────────┘ └────────┘ └────────┘           │   │
│  └─────────────────────────────────────────────────────────┘   │
│      │                              │                           │
│      ▼ ALLOW                        ▼ DENY                      │
│  ┌────────┐                    ┌────────────┐                   │
│  │  API   │                    │ 429 Error  │                   │
│  │Handler │                    │Retry-After │                   │
│  └────────┘                    └────────────┘                   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    QUOTA MANAGER                         │   │
│  │  • Monthly token limit: 1,000,000                       │   │
│  │  • Daily request limit: 10,000                          │   │
│  │  • Cost tracking: $0.50/1M tokens                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Algoritmos de Rate Limiting

### Token Bucket

```python
import time
import redis.asyncio as redis
from dataclasses import dataclass
from typing import Tuple, Optional
import asyncio

@dataclass
class RateLimitResult:
    """Resultado de verificación de rate limit"""
    allowed: bool
    remaining: int
    reset_at: float
    retry_after: Optional[float] = None

class TokenBucketLimiter:
    """
    Implementación de Token Bucket para rate limiting

    El bucket se llena con tokens a una tasa constante.
    Cada request consume un token. Si no hay tokens, se deniega.
    """

    def __init__(
        self,
        redis_client: redis.Redis,
        bucket_size: int = 100,      # Capacidad máxima
        refill_rate: float = 10.0,   # Tokens por segundo
        key_prefix: str = "ratelimit"
    ):
        self.redis = redis_client
        self.bucket_size = bucket_size
        self.refill_rate = refill_rate
        self.key_prefix = key_prefix

    async def check(
        self,
        identifier: str,
        tokens_needed: int = 1
    ) -> RateLimitResult:
        """
        Verifica y consume tokens

        Args:
            identifier: ID único (user_id, ip, api_key)
            tokens_needed: Tokens a consumir
        """
        key = f"{self.key_prefix}:bucket:{identifier}"
        now = time.time()

        # Script Lua para atomicidad
        lua_script = """
        local key = KEYS[1]
        local bucket_size = tonumber(ARGV[1])
        local refill_rate = tonumber(ARGV[2])
        local tokens_needed = tonumber(ARGV[3])
        local now = tonumber(ARGV[4])

        -- Obtener estado actual
        local data = redis.call('HMGET', key, 'tokens', 'last_update')
        local tokens = tonumber(data[1]) or bucket_size
        local last_update = tonumber(data[2]) or now

        -- Calcular tokens añadidos desde última actualización
        local elapsed = now - last_update
        local added_tokens = elapsed * refill_rate
        tokens = math.min(bucket_size, tokens + added_tokens)

        -- Verificar si hay suficientes tokens
        if tokens >= tokens_needed then
            tokens = tokens - tokens_needed
            redis.call('HMSET', key, 'tokens', tokens, 'last_update', now)
            redis.call('EXPIRE', key, 3600)
            return {1, tokens, 0}
        else
            -- Calcular tiempo hasta que haya tokens suficientes
            local needed = tokens_needed - tokens
            local wait_time = needed / refill_rate
            return {0, tokens, wait_time}
        end
        """

        result = await self.redis.eval(
            lua_script,
            1,
            key,
            self.bucket_size,
            self.refill_rate,
            tokens_needed,
            now
        )

        allowed = bool(result[0])
        remaining = int(result[1])
        wait_time = float(result[2])

        return RateLimitResult(
            allowed=allowed,
            remaining=remaining,
            reset_at=now + (self.bucket_size - remaining) / self.refill_rate,
            retry_after=wait_time if not allowed else None
        )


class SlidingWindowLimiter:
    """
    Rate limiter con ventana deslizante

    Más preciso que fixed window, evita picos en bordes de ventana.
    """

    def __init__(
        self,
        redis_client: redis.Redis,
        max_requests: int = 100,
        window_seconds: int = 60,
        key_prefix: str = "ratelimit"
    ):
        self.redis = redis_client
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self.key_prefix = key_prefix

    async def check(self, identifier: str) -> RateLimitResult:
        """Verifica rate limit con sliding window"""

        key = f"{self.key_prefix}:sliding:{identifier}"
        now = time.time()
        window_start = now - self.window_seconds

        # Usar pipeline para atomicidad
        async with self.redis.pipeline(transaction=True) as pipe:
            # Eliminar entradas viejas
            pipe.zremrangebyscore(key, 0, window_start)
            # Contar requests en ventana
            pipe.zcard(key)
            # Añadir request actual
            pipe.zadd(key, {str(now): now})
            # Establecer expiración
            pipe.expire(key, self.window_seconds)

            results = await pipe.execute()

        current_count = results[1]

        if current_count < self.max_requests:
            return RateLimitResult(
                allowed=True,
                remaining=self.max_requests - current_count - 1,
                reset_at=now + self.window_seconds
            )
        else:
            # Calcular cuando expira el request más viejo
            oldest = await self.redis.zrange(key, 0, 0, withscores=True)
            if oldest:
                retry_after = oldest[0][1] + self.window_seconds - now
            else:
                retry_after = self.window_seconds

            return RateLimitResult(
                allowed=False,
                remaining=0,
                reset_at=now + retry_after,
                retry_after=retry_after
            )


class AdaptiveRateLimiter:
    """
    Rate limiter adaptativo que ajusta límites según carga

    Reduce límites cuando el sistema está sobrecargado.
    """

    def __init__(
        self,
        redis_client: redis.Redis,
        base_limit: int = 100,
        window_seconds: int = 60
    ):
        self.redis = redis_client
        self.base_limit = base_limit
        self.window_seconds = window_seconds
        self.sliding_limiter = SlidingWindowLimiter(
            redis_client, base_limit, window_seconds
        )

    async def get_current_limit(self) -> int:
        """Obtiene límite actual basado en carga del sistema"""

        # Obtener métricas de carga (ejemplo simplificado)
        load_key = "system:load"
        load = await self.redis.get(load_key)

        if load:
            load_value = float(load)
            if load_value > 0.9:
                return int(self.base_limit * 0.5)  # 50% en carga alta
            elif load_value > 0.7:
                return int(self.base_limit * 0.75)  # 75% en carga media

        return self.base_limit

    async def check(self, identifier: str) -> RateLimitResult:
        """Verifica con límite adaptativo"""

        current_limit = await self.get_current_limit()
        self.sliding_limiter.max_requests = current_limit

        result = await self.sliding_limiter.check(identifier)
        return result

    async def update_load(self, load_value: float):
        """Actualiza métrica de carga del sistema"""
        await self.redis.setex("system:load", 60, str(load_value))
```

## Sistema de Quotas

```python
from datetime import datetime, timedelta
from enum import Enum
from typing import Dict, Any

class QuotaPeriod(Enum):
    HOURLY = "hourly"
    DAILY = "daily"
    MONTHLY = "monthly"

@dataclass
class QuotaLimit:
    """Definición de límite de quota"""
    name: str
    limit: int
    period: QuotaPeriod
    resource: str  # "requests", "tokens", "cost_cents"

@dataclass
class QuotaUsage:
    """Uso actual de quota"""
    used: int
    limit: int
    remaining: int
    reset_at: datetime
    percentage_used: float

class QuotaManager:
    """Gestión de quotas por usuario/organización"""

    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client

        # Quotas por defecto por tier
        self.tier_quotas: Dict[str, List[QuotaLimit]] = {
            "free": [
                QuotaLimit("daily_requests", 100, QuotaPeriod.DAILY, "requests"),
                QuotaLimit("daily_tokens", 50000, QuotaPeriod.DAILY, "tokens"),
                QuotaLimit("monthly_cost", 0, QuotaPeriod.MONTHLY, "cost_cents"),
            ],
            "basic": [
                QuotaLimit("daily_requests", 1000, QuotaPeriod.DAILY, "requests"),
                QuotaLimit("daily_tokens", 500000, QuotaPeriod.DAILY, "tokens"),
                QuotaLimit("monthly_cost", 1000, QuotaPeriod.MONTHLY, "cost_cents"),
            ],
            "pro": [
                QuotaLimit("daily_requests", 10000, QuotaPeriod.DAILY, "requests"),
                QuotaLimit("daily_tokens", 5000000, QuotaPeriod.DAILY, "tokens"),
                QuotaLimit("monthly_cost", 10000, QuotaPeriod.MONTHLY, "cost_cents"),
            ],
            "enterprise": [
                QuotaLimit("daily_requests", 100000, QuotaPeriod.DAILY, "requests"),
                QuotaLimit("daily_tokens", 50000000, QuotaPeriod.DAILY, "tokens"),
                QuotaLimit("monthly_cost", 100000, QuotaPeriod.MONTHLY, "cost_cents"),
            ]
        }

    def _get_period_key(self, period: QuotaPeriod) -> str:
        """Obtiene key para el período actual"""
        now = datetime.utcnow()

        if period == QuotaPeriod.HOURLY:
            return now.strftime("%Y%m%d%H")
        elif period == QuotaPeriod.DAILY:
            return now.strftime("%Y%m%d")
        elif period == QuotaPeriod.MONTHLY:
            return now.strftime("%Y%m")

    def _get_reset_time(self, period: QuotaPeriod) -> datetime:
        """Calcula cuando se resetea el período"""
        now = datetime.utcnow()

        if period == QuotaPeriod.HOURLY:
            return now.replace(minute=0, second=0, microsecond=0) + timedelta(hours=1)
        elif period == QuotaPeriod.DAILY:
            return now.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)
        elif period == QuotaPeriod.MONTHLY:
            if now.month == 12:
                return now.replace(year=now.year+1, month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
            return now.replace(month=now.month+1, day=1, hour=0, minute=0, second=0, microsecond=0)

    async def check_quota(
        self,
        user_id: str,
        tier: str,
        resource: str,
        amount: int = 1
    ) -> Tuple[bool, QuotaUsage]:
        """
        Verifica si la operación está dentro de quota

        Args:
            user_id: ID del usuario
            tier: Tier del usuario (free, basic, pro, enterprise)
            resource: Tipo de recurso (requests, tokens, cost_cents)
            amount: Cantidad a consumir
        """
        quotas = self.tier_quotas.get(tier, self.tier_quotas["free"])

        # Encontrar quota relevante
        relevant_quota = None
        for quota in quotas:
            if quota.resource == resource:
                relevant_quota = quota
                break

        if not relevant_quota:
            # Sin quota definida = sin límite
            return True, QuotaUsage(0, -1, -1, datetime.utcnow(), 0)

        period_key = self._get_period_key(relevant_quota.period)
        redis_key = f"quota:{user_id}:{relevant_quota.name}:{period_key}"

        # Obtener uso actual
        current_usage = await self.redis.get(redis_key)
        current = int(current_usage) if current_usage else 0

        # Calcular TTL basado en período
        reset_time = self._get_reset_time(relevant_quota.period)
        ttl = int((reset_time - datetime.utcnow()).total_seconds())

        # Verificar si excede
        new_total = current + amount
        allowed = new_total <= relevant_quota.limit

        usage = QuotaUsage(
            used=current,
            limit=relevant_quota.limit,
            remaining=max(0, relevant_quota.limit - current),
            reset_at=reset_time,
            percentage_used=(current / relevant_quota.limit * 100) if relevant_quota.limit > 0 else 0
        )

        return allowed, usage

    async def consume_quota(
        self,
        user_id: str,
        tier: str,
        resource: str,
        amount: int = 1
    ) -> Tuple[bool, QuotaUsage]:
        """Consume quota si está disponible"""

        allowed, usage = await self.check_quota(user_id, tier, resource, amount)

        if allowed:
            quotas = self.tier_quotas.get(tier, self.tier_quotas["free"])
            for quota in quotas:
                if quota.resource == resource:
                    period_key = self._get_period_key(quota.period)
                    redis_key = f"quota:{user_id}:{quota.name}:{period_key}"

                    reset_time = self._get_reset_time(quota.period)
                    ttl = int((reset_time - datetime.utcnow()).total_seconds())

                    # Incrementar uso
                    new_value = await self.redis.incrby(redis_key, amount)
                    await self.redis.expire(redis_key, ttl)

                    usage = QuotaUsage(
                        used=new_value,
                        limit=quota.limit,
                        remaining=max(0, quota.limit - new_value),
                        reset_at=reset_time,
                        percentage_used=(new_value / quota.limit * 100)
                    )
                    break

        return allowed, usage

    async def get_all_quotas(
        self,
        user_id: str,
        tier: str
    ) -> Dict[str, QuotaUsage]:
        """Obtiene estado de todas las quotas del usuario"""

        quotas = self.tier_quotas.get(tier, self.tier_quotas["free"])
        result = {}

        for quota in quotas:
            period_key = self._get_period_key(quota.period)
            redis_key = f"quota:{user_id}:{quota.name}:{period_key}"

            current = await self.redis.get(redis_key)
            current = int(current) if current else 0

            reset_time = self._get_reset_time(quota.period)

            result[quota.name] = QuotaUsage(
                used=current,
                limit=quota.limit,
                remaining=max(0, quota.limit - current),
                reset_at=reset_time,
                percentage_used=(current / quota.limit * 100) if quota.limit > 0 else 0
            )

        return result
```

## Middleware Integrado

```python
from fastapi import FastAPI, Request, HTTPException, Depends
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware

class RateLimitMiddleware(BaseHTTPMiddleware):
    """Middleware de rate limiting para FastAPI"""

    def __init__(
        self,
        app: FastAPI,
        limiter: TokenBucketLimiter,
        quota_manager: QuotaManager
    ):
        super().__init__(app)
        self.limiter = limiter
        self.quota_manager = quota_manager

    async def dispatch(self, request: Request, call_next):
        # Identificar cliente
        identifier = self._get_identifier(request)
        user_id = request.state.identity.id if hasattr(request.state, 'identity') else identifier
        tier = getattr(request.state, 'tier', 'free')

        # Verificar rate limit
        rate_result = await self.limiter.check(identifier)

        if not rate_result.allowed:
            return JSONResponse(
                status_code=429,
                content={
                    "error": "Rate limit exceeded",
                    "retry_after": rate_result.retry_after
                },
                headers={
                    "Retry-After": str(int(rate_result.retry_after)),
                    "X-RateLimit-Limit": str(self.limiter.bucket_size),
                    "X-RateLimit-Remaining": str(rate_result.remaining),
                    "X-RateLimit-Reset": str(int(rate_result.reset_at))
                }
            )

        # Verificar quota de requests
        quota_allowed, quota_usage = await self.quota_manager.check_quota(
            user_id, tier, "requests", 1
        )

        if not quota_allowed:
            return JSONResponse(
                status_code=429,
                content={
                    "error": "Quota exceeded",
                    "usage": {
                        "used": quota_usage.used,
                        "limit": quota_usage.limit,
                        "reset_at": quota_usage.reset_at.isoformat()
                    }
                },
                headers={
                    "X-Quota-Limit": str(quota_usage.limit),
                    "X-Quota-Remaining": str(quota_usage.remaining),
                    "X-Quota-Reset": quota_usage.reset_at.isoformat()
                }
            )

        # Procesar request
        response = await call_next(request)

        # Consumir quota después de request exitoso
        if response.status_code < 400:
            await self.quota_manager.consume_quota(user_id, tier, "requests", 1)

        # Añadir headers de rate limit
        response.headers["X-RateLimit-Limit"] = str(self.limiter.bucket_size)
        response.headers["X-RateLimit-Remaining"] = str(rate_result.remaining)
        response.headers["X-RateLimit-Reset"] = str(int(rate_result.reset_at))

        return response

    def _get_identifier(self, request: Request) -> str:
        """Extrae identificador del cliente"""
        # Prioridad: API Key > User ID > IP
        api_key = request.headers.get("X-API-Key")
        if api_key:
            return f"key:{api_key[:8]}"

        if hasattr(request.state, 'identity'):
            return f"user:{request.state.identity.id}"

        # Fallback a IP
        forwarded = request.headers.get("X-Forwarded-For")
        if forwarded:
            return f"ip:{forwarded.split(',')[0].strip()}"

        return f"ip:{request.client.host}"


class TokenQuotaMiddleware:
    """Middleware para tracking de tokens consumidos"""

    def __init__(self, quota_manager: QuotaManager):
        self.quota_manager = quota_manager

    async def track_tokens(
        self,
        user_id: str,
        tier: str,
        input_tokens: int,
        output_tokens: int
    ):
        """Registra tokens consumidos después de una llamada a Gemini"""

        total_tokens = input_tokens + output_tokens

        # Consumir quota de tokens
        allowed, usage = await self.quota_manager.consume_quota(
            user_id, tier, "tokens", total_tokens
        )

        # Calcular y registrar costo (ejemplo: $0.075/1M input, $0.30/1M output)
        cost_cents = int(
            (input_tokens * 0.075 / 1000) +
            (output_tokens * 0.30 / 1000)
        )

        if cost_cents > 0:
            await self.quota_manager.consume_quota(
                user_id, tier, "cost_cents", cost_cents
            )

        return usage
```

## Dashboard de Quotas

```python
from fastapi import APIRouter
from typing import Dict

router = APIRouter(prefix="/api/v1/usage", tags=["usage"])

@router.get("/quotas")
async def get_quota_status(
    identity: Identity = Depends(get_current_identity),
    quota_manager: QuotaManager = Depends(get_quota_manager)
):
    """Obtiene estado actual de todas las quotas"""

    tier = identity.metadata.get("tier", "free")
    quotas = await quota_manager.get_all_quotas(identity.id, tier)

    return {
        "tier": tier,
        "quotas": {
            name: {
                "used": usage.used,
                "limit": usage.limit,
                "remaining": usage.remaining,
                "percentage_used": round(usage.percentage_used, 2),
                "reset_at": usage.reset_at.isoformat()
            }
            for name, usage in quotas.items()
        }
    }

@router.get("/history")
async def get_usage_history(
    days: int = 30,
    identity: Identity = Depends(get_current_identity),
    db = Depends(get_db)
):
    """Obtiene historial de uso"""

    # Query historial desde DB
    history = await db.fetch_all(
        """
        SELECT date, requests, tokens, cost_cents
        FROM usage_history
        WHERE user_id = :user_id
        AND date >= :start_date
        ORDER BY date DESC
        """,
        {
            "user_id": identity.id,
            "start_date": datetime.utcnow() - timedelta(days=days)
        }
    )

    return {
        "period_days": days,
        "history": [dict(row) for row in history],
        "totals": {
            "requests": sum(row["requests"] for row in history),
            "tokens": sum(row["tokens"] for row in history),
            "cost_cents": sum(row["cost_cents"] for row in history)
        }
    }
```

## Ejemplo Práctico

```python
import asyncio
import redis.asyncio as redis

async def main():
    # Conectar a Redis
    redis_client = redis.from_url("redis://localhost")

    # Inicializar limiters
    rate_limiter = TokenBucketLimiter(
        redis_client,
        bucket_size=100,
        refill_rate=10
    )

    quota_manager = QuotaManager(redis_client)

    # Simular requests
    user_id = "user_123"
    tier = "basic"

    print("=== Rate Limiting Test ===")
    for i in range(15):
        result = await rate_limiter.check(user_id)
        status = "✓ Allowed" if result.allowed else "✗ Denied"
        print(f"Request {i+1}: {status}, Remaining: {result.remaining}")

        if not result.allowed:
            print(f"  Retry after: {result.retry_after:.2f}s")
            await asyncio.sleep(result.retry_after)

    print("\n=== Quota Test ===")
    for i in range(5):
        allowed, usage = await quota_manager.consume_quota(
            user_id, tier, "requests", 1
        )
        status = "✓ Allowed" if allowed else "✗ Quota exceeded"
        print(f"Request {i+1}: {status}")
        print(f"  Used: {usage.used}/{usage.limit} ({usage.percentage_used:.1f}%)")

    print("\n=== Token Quota Test ===")
    # Simular consumo de tokens
    token_amounts = [1000, 2500, 5000, 10000]
    for tokens in token_amounts:
        allowed, usage = await quota_manager.consume_quota(
            user_id, tier, "tokens", tokens
        )
        status = "✓" if allowed else "✗"
        print(f"{status} Consumed {tokens} tokens. Total: {usage.used}/{usage.limit}")

    print("\n=== All Quotas ===")
    all_quotas = await quota_manager.get_all_quotas(user_id, tier)
    for name, usage in all_quotas.items():
        print(f"  {name}: {usage.used}/{usage.limit} ({usage.percentage_used:.1f}%)")

    await redis_client.close()

if __name__ == "__main__":
    asyncio.run(main())
```

## Ejercicios Prácticos

### Ejercicio 1: Rate Limit por Endpoint
Implementa rate limits diferentes por endpoint:
- `/chat`: 60 req/min
- `/agent`: 20 req/min
- `/admin`: 10 req/min

### Ejercicio 2: Quotas con Alertas
Añade sistema de alertas:
- Notificar al 80% de uso
- Notificar al 95% de uso
- Email cuando se excede

### Ejercicio 3: Billing Integration
Integra con sistema de billing:
- Cobro por exceso de quota
- Upgrade automático de tier
- Facturación mensual

## Resumen

| Concepto | Descripción |
|----------|-------------|
| Token Bucket | Tokens se llenan gradualmente, requests los consumen |
| Sliding Window | Ventana que se mueve en el tiempo |
| Quota | Límite total por período (día/mes) |
| Tier | Nivel de servicio con límites diferentes |
| 429 Response | Código HTTP para rate limit excedido |
| Retry-After | Header que indica cuándo reintentar |

---

**Siguiente:** [10.2.3 Logging y Auditoría](./10.2.3-logging-auditoria.md)
