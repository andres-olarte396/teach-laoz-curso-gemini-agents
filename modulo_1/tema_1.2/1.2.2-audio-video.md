# Procesamiento de Audio y Video

**Tiempo estimado**: 40 minutos
**Nivel**: Intermedio
**Prerrequisitos**: API de Gemini (1.1), Análisis de imágenes (1.2.1)

## ¿Por qué importa este concepto?

Gemini 1.5 puede procesar audio y video completos en una sola llamada. Esto permite:
- Transcripción y resumen de reuniones
- Análisis de contenido de video
- Búsqueda semántica en videos
- Moderación de contenido multimedia
- Agentes que entienden contenido audiovisual

---

## Procesamiento de Audio

### Formatos soportados
- MP3, WAV, FLAC, OGG, M4A
- Hasta varias horas de audio

### Subir y analizar audio

```python
import google.generativeai as genai
import os

genai.configure(api_key=os.environ["GOOGLE_API_KEY"])


def upload_and_analyze_audio(audio_path: str, prompt: str) -> str:
    """
    Sube un archivo de audio y lo analiza.

    Args:
        audio_path: Ruta al archivo de audio
        prompt: Instrucción para el análisis

    Returns:
        Respuesta del modelo
    """
    # Subir archivo a la API de Files
    audio_file = genai.upload_file(audio_path)

    # Esperar a que se procese
    import time
    while audio_file.state.name == "PROCESSING":
        time.sleep(2)
        audio_file = genai.get_file(audio_file.name)

    if audio_file.state.name == "FAILED":
        raise ValueError(f"Procesamiento fallido: {audio_file.state.name}")

    # Analizar con el modelo
    model = genai.GenerativeModel("gemini-1.5-flash")
    response = model.generate_content([prompt, audio_file])

    return response.text


# Uso
transcription = upload_and_analyze_audio(
    "reunion.mp3",
    "Transcribe este audio y genera un resumen de los puntos principales"
)
print(transcription)
```

### Transcripción con timestamps

```python
def transcribe_with_timestamps(audio_path: str) -> str:
    """Transcribe audio con marcas de tiempo."""
    audio_file = genai.upload_file(audio_path)

    # Esperar procesamiento
    import time
    while audio_file.state.name == "PROCESSING":
        time.sleep(2)
        audio_file = genai.get_file(audio_file.name)

    prompt = """
    Transcribe este audio con timestamps.
    Formato:
    [MM:SS] Texto hablado

    Incluye:
    - Identificación de hablantes si hay múltiples
    - Pausas significativas marcadas como [pausa]
    - Sonidos relevantes como [risas], [aplausos]
    """

    model = genai.GenerativeModel("gemini-1.5-flash")
    response = model.generate_content([prompt, audio_file])

    return response.text
```

### Análisis de sentimiento en audio

```python
def analyze_audio_sentiment(audio_path: str) -> dict:
    """Analiza el sentimiento y tono del audio."""
    audio_file = genai.upload_file(audio_path)

    import time
    while audio_file.state.name == "PROCESSING":
        time.sleep(2)
        audio_file = genai.get_file(audio_file.name)

    prompt = """
    Analiza el sentimiento y tono de este audio.
    Responde en JSON:
    {
        "overall_sentiment": "positivo/negativo/neutro",
        "confidence": 0.0-1.0,
        "emotional_tones": ["lista", "de", "emociones"],
        "energy_level": "alto/medio/bajo",
        "key_moments": [
            {"timestamp": "MM:SS", "sentiment": "...", "reason": "..."}
        ]
    }
    """

    model = genai.GenerativeModel("gemini-1.5-flash")
    response = model.generate_content([prompt, audio_file])

    import json
    try:
        text = response.text.strip()
        if "```" in text:
            text = text.split("```")[1].replace("json", "").strip()
        return json.loads(text)
    except:
        return {"raw": response.text}
```

---

## Procesamiento de Video

### Formatos soportados
- MP4, MPEG, MOV, AVI, MKV, WebM
- Hasta ~1 hora de video (Gemini 1.5 Pro)

### Subir y analizar video

```python
def upload_and_analyze_video(video_path: str, prompt: str) -> str:
    """
    Sube y analiza un video completo.

    Args:
        video_path: Ruta al archivo de video
        prompt: Instrucción de análisis

    Returns:
        Análisis del modelo
    """
    print(f"Subiendo video: {video_path}")
    video_file = genai.upload_file(video_path)

    # El procesamiento de video puede tomar más tiempo
    import time
    print("Procesando video...")
    while video_file.state.name == "PROCESSING":
        time.sleep(5)
        video_file = genai.get_file(video_file.name)
        print(".", end="", flush=True)

    print("\nProcesamiento completado")

    if video_file.state.name == "FAILED":
        raise ValueError(f"Error: {video_file.state.name}")

    model = genai.GenerativeModel("gemini-1.5-pro")  # Pro para videos largos
    response = model.generate_content([prompt, video_file])

    return response.text


# Uso
summary = upload_and_analyze_video(
    "presentacion.mp4",
    "Resume los puntos principales de esta presentación"
)
```

### Búsqueda en video

```python
def search_in_video(video_path: str, query: str) -> list:
    """
    Busca momentos específicos en un video.

    Args:
        video_path: Ruta al video
        query: Qué buscar

    Returns:
        Lista de momentos encontrados
    """
    video_file = genai.upload_file(video_path)

    import time
    while video_file.state.name == "PROCESSING":
        time.sleep(5)
        video_file = genai.get_file(video_file.name)

    prompt = f"""
    Busca en este video: "{query}"

    Para cada momento relevante encontrado, responde en JSON:
    [
        {{
            "timestamp": "MM:SS",
            "description": "qué está pasando",
            "relevance": "por qué es relevante para la búsqueda"
        }}
    ]

    Si no encuentras nada relevante, responde con array vacío [].
    """

    model = genai.GenerativeModel("gemini-1.5-pro")
    response = model.generate_content([prompt, video_file])

    import json
    try:
        text = response.text.strip()
        if "```" in text:
            text = text.split("```")[1].replace("json", "").strip()
        return json.loads(text)
    except:
        return [{"raw": response.text}]


# Uso
moments = search_in_video(
    "tutorial.mp4",
    "momentos donde se explica cómo instalar"
)
for m in moments:
    print(f"[{m['timestamp']}] {m['description']}")
```

### Extracción de información estructurada

```python
def extract_video_metadata(video_path: str) -> dict:
    """
    Extrae metadatos e información del video.
    """
    video_file = genai.upload_file(video_path)

    import time
    while video_file.state.name == "PROCESSING":
        time.sleep(5)
        video_file = genai.get_file(video_file.name)

    prompt = """
    Analiza este video y extrae:

    1. **Información general**:
       - Tipo de contenido (tutorial, presentación, entretenimiento, etc.)
       - Idioma principal
       - Número aproximado de personas que aparecen
       - Escenario/ubicación

    2. **Estructura**:
       - Capítulos o secciones principales
       - Duración aproximada de cada sección

    3. **Contenido**:
       - Temas principales discutidos
       - Palabras clave
       - Call-to-actions si los hay

    4. **Calidad técnica**:
       - Calidad de audio (buena/regular/mala)
       - Calidad de video (buena/regular/mala)
       - Presencia de subtítulos

    Responde en JSON estructurado.
    """

    model = genai.GenerativeModel("gemini-1.5-pro")
    response = model.generate_content([prompt, video_file])

    import json
    try:
        text = response.text.strip()
        if "```" in text:
            text = text.split("```")[1].replace("json", "").strip()
        return json.loads(text)
    except:
        return {"raw_analysis": response.text}
```

---

## Gestión de archivos subidos

```python
def list_uploaded_files() -> list:
    """Lista todos los archivos subidos."""
    files = []
    for f in genai.list_files():
        files.append({
            "name": f.name,
            "display_name": f.display_name,
            "mime_type": f.mime_type,
            "size": f.size_bytes,
            "state": f.state.name,
            "uri": f.uri,
        })
    return files


def delete_file(file_name: str):
    """Elimina un archivo subido."""
    genai.delete_file(file_name)
    print(f"Eliminado: {file_name}")


def cleanup_old_files(max_age_hours: int = 24):
    """Elimina archivos más viejos que max_age_hours."""
    from datetime import datetime, timedelta

    cutoff = datetime.now() - timedelta(hours=max_age_hours)

    for f in genai.list_files():
        # Nota: create_time puede no estar disponible en todos los casos
        try:
            if hasattr(f, 'create_time') and f.create_time < cutoff:
                genai.delete_file(f.name)
                print(f"Eliminado (antiguo): {f.name}")
        except Exception as e:
            print(f"Error eliminando {f.name}: {e}")


# Ver archivos actuales
for f in list_uploaded_files():
    print(f"{f['name']}: {f['state']} ({f['size']/1024/1024:.1f} MB)")
```

---

## Consideraciones de rendimiento

### Tokens de audio/video
- **Audio**: ~25 tokens por segundo de audio
- **Video**: Más variable, depende del contenido visual

### Tiempos de procesamiento
```python
# Estimaciones aproximadas
PROCESSING_TIMES = {
    "audio_per_minute": 5,   # segundos de procesamiento por minuto de audio
    "video_per_minute": 15,  # segundos de procesamiento por minuto de video
}

def estimate_processing_time(duration_minutes: float, media_type: str) -> float:
    """Estima tiempo de procesamiento."""
    rate = PROCESSING_TIMES.get(f"{media_type}_per_minute", 10)
    return duration_minutes * rate
```

### Costos
El procesamiento de audio/video se factura por tokens:
- Audio ~25 tokens/segundo
- Video variable pero significativamente más que imágenes estáticas

---

## Resumen del concepto

**En una frase**: Gemini 1.5 puede procesar horas de audio y video en una sola llamada, habilitando análisis profundo de contenido multimedia.

**API de Files**:
```python
file = genai.upload_file("video.mp4")  # Subir
genai.get_file(file.name)               # Verificar estado
genai.delete_file(file.name)            # Eliminar
```

**Casos de uso clave**:
- Transcripción de reuniones
- Resumen de videos
- Búsqueda semántica en contenido multimedia
- Análisis de sentimiento en audio

**Siguiente paso**: Tema 1.2.3 - Generación Multimodal.
